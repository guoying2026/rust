#copy
#clone
#移动
浅拷贝 两个变量对应的指针指向一个内存里的数据，在rust语言里是 移动。
深拷贝 两个变量指向的内存地址不一样。数据一样。互相独立的。在rust语言里，需要使用clone。

还有一种特殊情况，如果类型实现了copy使用它的变量不会移动，而是被简单地复制，使得它们在分配给另一个变量后仍然有效。

以下是一些实现 `Copy` 的类型：

1、所有整数类型，例如 `u32` 。
2、布尔类型， `bool` ，具有值 `true` 和 `false` 。
3、所有的浮点类型，比如 `f64` 。
4、字符类型， `char` 。
5、元组，如果它们只包含也实现 `Copy` 的类型。例如， `(i32, i32)` 实现 `Copy` ，但 `(i32, String)` 不实现。

#引用
将值分配给另一个变量会移动它，当包含堆上数据的变量超出范围时，该值将由drop清理，除非数据的所有权已转移到另一个变量。

不需要使用所有权，但是使用值，就是引用。

引用与指针的不同之处在于，引用保证在引用的生命周期内制定特定类型的有效值。

![[Pasted image 20240510094633.png]]

![[Pasted image 20240510094857.png]]

#切片引用
&s[0..5]
&s[6..11]
&s[0..len]
&s[..]

#结构体
struct类似于php的class。里面有字段。就是关于这个结构体的数据字段。结构体里面的定义是关联函数。

#元组结构体
不具有与字段管理的名称，只具有字段的类型
struct Color(i32,i32,i32);
struct Point(i32,i32,i32);

#没有任何字段的结构体
struct AlwaysEqual;

#结构体也可以存储对其他所有者的数据的引用，但需要使用生命周期

为结构体上下文定义函数，启动impl来实现。
将第一个参数改成self，&self。在impl块中，类型Self是impl块所用类型的别名。方法必须有一个名为self且类型为Self的参数作为它们的第一个参数。不用拥有，只是借用。

