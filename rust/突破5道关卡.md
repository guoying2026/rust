###  #1、所有权机制
在不需要垃圾收集器的情况下提供内存安全性保证，因此了解所有权的工作原理非常重要。

>借用

> 切片

> rust如何在内存中布局

所有权是一组规则，用于指导rust程序如何管理内存。所有程序在运行时都必须管理它们使用计算机内存的方式。一些语言具有垃圾回收机制，会定期查找程序运行时不再使用的内存。而在其他语言中，程序员必须显示的分配和释放内存。rust使用第三种方法，通过一套所有权规则管理内存，编译器会检查这些规则。如果违反任何规则，程序将无法编译。所有权的任何特性都不会在程序运行时减慢程序的运行速度。

许多编程语言不需要您经常考虑栈和堆。但在像 Rust 这样的系统编程语言中，值是存储在栈上还是堆上会影响语言的行为，以及为什么您必须做出某些决策。本章后面将描述与栈和堆相关的所有权部分，因此在此之前，这里是一个简要的准备说明。

栈和堆都是您的代码在运行时可以使用的内存部分，但它们的结构方式不同。栈按照获取值的顺序存储值，并以相反的顺序移除值。这被称为后进先出。想象一下一叠盘子：当您添加更多盘子时，您将它们放在堆叠的顶部，当您需要一只盘子时，您从顶部取走一只。从中间或底部添加或移除盘子不会那么有效！添加数据称为推入栈，移除数据称为弹出栈。存储在栈上的所有数据必须具有已知的固定大小。在编译时大小未知或大小可能会更改的数据必须存储在堆上。

堆的组织性较差：当您将数据放入堆时，您请求一定量的空间。内存分配器在堆中找到一个足够大的空位，标记为正在使用，并返回一个指针，即该位置的地址。这个过程称为在堆上分配，有时简称为分配（将值推送到堆栈上不被视为分配）。由于堆的指针是已知的固定大小，您可以将指针存储在堆栈上，但当您需要实际数据时，必须跟随指针。想象一下在餐厅就座。当您进入时，告知您组里的人数，主人找到一个适合所有人的空桌并带您过去。如果您组里有人迟到，他们可以询问您就座的位置以找到您。

将数据推送到堆栈比在堆上分配更快，因为分配器永远不必搜索存储新数据的位置；该位置始终位于堆栈顶部。相比之下，在堆上分配空间需要更多工作，因为分配器必须首先找到足够大的空间来容纳数据，然后执行簿记以准备下一次分配。

在堆中访问数据比在栈中访问数据慢，因为你必须跟随指针才能到达那里。当代处理器在内存中跳跃较少时速度更快。延续这个类比，考虑一家餐厅的服务器从许多桌子上接订单。在转移到下一桌之前，最有效的方法是先获取一桌的所有订单。先从 A 桌接订单，然后从 B 桌接订单，再从 A 桌接订单，然后再从 B 桌接订单会是一个更慢的过程。同样地，处理器可以更好地完成工作，如果它处理的数据靠近其他数据（就像在栈上）而不是远离（就像在堆上）。

当您的代码调用一个函数时，传递给函数的值（包括可能指向堆上数据的指针）和函数的局部变量被推送到堆栈上。当函数结束时，这些值会从堆栈中弹出。

跟踪代码的哪些部分正在使用堆上的数据，最小化堆上重复数据的数量，并清理未使用的堆数据，以免空间不足，这些都是所有权解决的问题。一旦理解了所有权，你就不需要经常考虑栈和堆，但知道所有权的主要目的是管理堆数据可以帮助解释它为什么以这种方式工作。

----------------------------------------------------
所有权规则
一、Rust 中的每个值都有一个所有者。
二、一次只能有一个所有者。
三、当所有者超出范围时，该值将被丢弃。

作为所有权的第一个示例，我们将看一下一些变量的范围。范围是程序中项目有效的范围。拿以下变量为例：

`let s = "hello";`

变量 `s` 指的是一个字符串字面量，其中字符串的值是硬编码到我们程序的文本中的。该变量从声明的点开始有效，直到当前作用域的结束。图 4-1 显示了一个程序，其中有注释标注变量 `s` 的有效范围。
    {                      // s is not valid here, it’s not yet declared
        let s = "hello";   // s is valid from this point forward

        // do stuff with s
    }                      // this scope is now over, and s is no longer valid

当 `s` 进入范围时，它是有效的。
它在超出范围之前仍然有效。

在这一点上，作用域和变量有效的时间之间的关系类似于其他编程语言中的情况。现在我们将在这种理解的基础上介绍 `String` 类型。

为了说明所有权规则，我们需要一种比我们在第 3 章“数据类型”部分中涵盖的更复杂的数据类型。之前涵盖的类型是已知大小的，可以存储在堆栈上，并在其作用域结束时从堆栈中弹出，并且可以快速且轻松地复制以创建一个新的、独立的实例，如果代码的另一部分需要在不同的作用域中使用相同的值。但我们想要查看存储在堆上的数据，并探讨 Rust 如何知道何时清理这些数据， `String` 类型是一个很好的例子。

我们将集中讨论与所有权相关的 `String` 部分。这些方面也适用于其他复杂数据类型，无论是由标准库提供还是由您创建。我们将在第 8 章更深入地讨论 `String` 。

我们已经看到了字符串字面量，其中字符串值是硬编码到我们的程序中的。字符串字面量很方便，但并不适用于我们可能希望使用文本的每种情况。一个原因是它们是不可变的。另一个原因是，当我们编写代码时，并不是每个字符串值都是已知的：例如，如果我们想要接受用户输入并存储它会怎样？对于这些情况，Rust 有第二种字符串类型， `String` 。这种类型管理在堆上分配的数据，因此能够存储我们在编译时不知道的文本量。您可以使用 `from` 函数从字符串字面量创建一个 `String` ，就像这样：

`let s = String::from("hello");`

双冒号 `::` 运算符允许我们将这个特定的 `from` 函数命名空间化到 `String` 类型下，而不是使用类似 `string_from` 的名称。我们将在第 5 章的“方法语法”部分更详细地讨论这种语法，以及在第 7 章的“模块中项目引用路径”中讨论使用模块进行命名空间化。

这种字符串可以被改变：

那么，这里有什么区别呢？为什么 `String` 可以被改变，但字面值不能呢？区别在于这两种类型处理内存的方式。

在字符串字面值的情况下，我们在编译时知道内容，因此文本直接硬编码到最终可执行文件中。这就是为什么字符串字面值快速高效的原因。但这些特性只来自于字符串字面值的不可变性。不幸的是，我们无法为每个在编译时大小未知且在运行程序时可能会更改大小的文本块放入二进制文件中。

使用 `String` 类型，为了支持一个可变的、可增长的文本片段，我们需要在堆上分配一定数量的内存，编译时未知，以容纳内容。这意味着：
一、内存必须在运行时从内存分配器请求。
二、当我们完成 `String` 后，我们需要一种将这些内存返回给分配器的方法。

第一部分由我们完成：当我们调用 `String::from` 时，其实现会请求所需的内存。这在编程语言中几乎是普遍的。

然而，第二部分是不同的。在具有垃圾收集器（GC）的语言中，GC 会跟踪和清理不再使用的内存，我们不需要考虑这一点。在大多数没有 GC 的语言中，我们有责任识别何时不再使用内存，并调用代码显式释放它，就像我们请求它一样。正确地执行这一点在历史上一直是一个困难的编程问题。如果我们忘记了，我们会浪费内存。如果我们太早这样做，我们会有一个无效的变量。如果我们这样做两次，那也是一个错误。我们需要精确地将一个 `allocate` 与一个 `free` 配对。

rust采取了一种不同的路径：一旦拥有它的变量超出范围，内存就会自动返回。这是我们在列表 4-1 中使用 `String` 而不是字符串文字的作用域示例的一个版本：

    {
        let s = String::from("hello"); // s is valid from this point forward

        // do stuff with s
    }                                  // this scope is now over, and s is no
                                       // longer valid

当 `s` 超出范围时，我们可以在自然点将 `String` 需要的内存返回给分配器。当变量超出范围时，Rust 会为我们调用一个特殊函数。这个函数被称为 `drop` ，作者可以在其中放置返回内存的代码。Rust 会在闭合大括号处自动调用 `drop`.

这种模式对 Rust 代码的编写方式产生了深远影响。现在看起来可能很简单，但当我们想要让多个变量使用我们在堆上分配的数据时，在更复杂的情况下，代码的行为可能会出乎意料。让我们现在探讨一些这些情况。

#### [变量和数据与移动交互](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#variables-and-data-interacting-with-move)

    let x = 5;
    let y = x;
我们可能猜到这是在做什么：“将值 `5` 绑定到 `x` ；然后复制 `x` 中的值并绑定到 `y` 。”现在我们有两个变量， `x` 和 `y` ，两者都等于 `5` 。这确实是正在发生的事情，因为整数是已知固定大小的简单值，并且这两个 `5` 值被推送到堆栈上。

    let s1 = String::from("hello");
    let s2 = s1;

这看起来非常相似，因此我们可能会假设它的工作方式是相同的：也就是说，第二行会复制 `s1` 中的值并将其绑定到 `s2` 。但实际情况并非完全如此。
看看 `String` 在底层发生了什么。一个 `String` 由三部分组成，如左侧所示：指向保存字符串内容的内存的指针，长度和容量。这组数据存储在堆栈上。右侧是保存内容的堆上的内存。
![[Pasted image 20240509151230.png]]
长度是 `String` 内容当前使用的内存量（以字节为单位）。容量是 `String` 从分配器接收的总内存量（以字节为单位）。长度和容量之间的差异很重要，但在这种情况下并不重要，所以现在可以忽略容量。

当我们将 `s1` 分配给 `s2` 时， `String` 数据被复制，意味着我们复制了在堆栈上的指针、长度和容量。我们没有复制指针所指向的堆上的数据。换句话说，内存中的数据表示如图 4-2 所示。

![[Pasted image 20240509151402.png]]
如果 Rust 复制堆数据，内存看起来会是什么样子。如果 Rust 这样做了，如果堆上的数据很大，操作 `s2 = s1` 在运行时性能方面可能会非常昂贵。
![[Pasted image 20240509151450.png]]
当一个变量超出作用域时，Rust 会自动调用 `drop` 函数并清理该变量的堆内存。但图 4-2 显示两个数据指针指向同一位置。这是一个问题：当 `s2` 和 `s1` 超出作用域时，它们都会尝试释放相同的内存。这被称为双重释放错误，是我们之前提到的内存安全错误之一。释放内存两次可能导致内存损坏，进而可能导致安全漏洞。

为了确保内存安全，在 `let s2 = s1;` 之后，Rust 认为 `s1` 不再有效。因此，当 `s1` 超出范围时，Rust 不需要释放任何内容。看看当你尝试在创建 `s2` 之后使用 `s1` 时会发生什么；它不会起作用：
    let s1 = String::from("hello");
    let s2 = s1;

    println!("{}, world!", s1);
由于 Rust 阻止您使用无效的引用，您会收到这样的错误。
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:5:28
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{}, world!", s1);
  |                            ^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
  |
3 |     let s2 = s1.clone();
  |                ++++++++

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error

如果您在使用其他语言时听过浅拷贝和深拷贝这两个术语，那么在不拷贝数据的情况下拷贝指针、长度和容量的概念可能听起来像是在进行浅拷贝。但是因为 Rust 还会使第一个变量无效，所以不叫浅拷贝，而是称为移动。在这个例子中，我们会说 `s1` 被移动到 `s2`。
![[Pasted image 20240509151642.png]]
这解决了我们的问题！只有 `s2` 有效，当它超出范围时，它将自行释放内存，我们就完成了。
这暗示了一个设计选择：Rust 永远不会自动创建您的数据的“深”副本。因此，可以假定任何自动复制在运行时性能方面都是廉价的。

#### [变量和数据与克隆交互](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#variables-and-data-interacting-with-clone)

如果我们确实想要深度复制 `String` 的堆数据，而不仅仅是栈数据，我们可以使用一种常见的方法称为 `clone` 。我们将在第 5 章讨论方法语法，但由于方法是许多编程语言中的常见特性，您可能以前见过它们。
    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {}, s2 = {}", s1, s2);
当您看到对 `clone` 的调用时，您知道正在执行一些任意代码，并且该代码可能很昂贵。这是一个视觉指示，表明正在发生一些不同的事情。

#### [堆栈数据：复制](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#stack-only-data-copy)

还有一个我们还没有讨论的问题。这个使用整数的代码——其中部分在列表 4-2 中显示——是有效的。

    let x = 5;
    let y = x;

    println!("x = {}, y = {}", x, y);

但是这段代码似乎与我们刚学到的内容相矛盾：我们没有调用 `clone` ，但 `x` 仍然有效，并且没有移动到 `y` 。

原因是在编译时已知大小的整数等类型完全存储在堆栈上，因此实际值的副本制作起来很快。这意味着在创建变量 `y` 后，我们不希望阻止 `x` 有效。换句话说，在这里深复制和浅复制没有区别，因此调用 `clone` 不会产生任何与通常的浅复制不同的效果，我们可以省略它。

rust有一个特殊的注解叫做 `Copy` 特性，我们可以放在存储在堆栈上的类型上，就像整数一样（我们会在第 10 章更多地讨论特性）。如果一个类型实现了 `Copy` 特性，使用它的变量不会移动，而是被简单地复制，使得它们在分配给另一个变量后仍然有效。

如果类型或其任何部分已实现 `Drop` 特性，则rust不会让我们使用 `Copy` 注释类型。如果类型在值超出范围时需要发生特殊情况，并且我们为该类型添加 `Copy` 注释，则会收到编译时错误。要了解如何添加 `Copy` 注释以实现特性，请参阅附录 C 中的“可派生特性”。

那么，哪些类型实现了 `Copy` 特质？您可以查看给定类型的文档以确保，但通常来说，任何一组简单标量值都可以实现 `Copy` ，而任何需要分配或是某种资源形式的内容都不能实现 `Copy` 。以下是一些实现 `Copy` 的类型：

1、所有整数类型，例如 `u32` 。
2、布尔类型， `bool` ，具有值 `true` 和 `false` 。
3、所有的浮点类型，比如 `f64` 。
4、字符类型， `char` 。
5、元组，如果它们只包含也实现 `Copy` 的类型。例如， `(i32, i32)` 实现 `Copy` ，但 `(i32, String)` 不实现。

将值传递给函数的机制与将值分配给变量时类似。将变量传递给函数将移动或复制，就像赋值一样。图 4-3 中有一个示例，其中一些注释显示变量何时进入和退出作用域。
![[Pasted image 20240509153340.png]]
如果我们在调用 `takes_ownership` 之后尝试使用 `s` ，Rust 会抛出编译时错误。这些静态检查可以保护我们免受错误的影响。尝试添加代码到 `main` ，使用 `s` 和 `x` ，看看在哪里可以使用它们，以及所有权规则阻止你这样做的地方。

### [返回值和作用域](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#return-values-and-scope)

返回值也可以转移所有权。图 4-4 显示了一个返回某个值的函数示例，其注释与图 4-3 中的注释类似。
![[Pasted image 20240509153458.png]]

变量的所有权每次都遵循相同的模式：将值分配给另一个变量会移动它。当包含堆上数据的变量超出范围时，该值将由 `drop` 清理，除非数据的所有权已转移到另一个变量。

虽然这样可以运作，但是在每个函数中都要获取所有权然后再归还所有权有点繁琐。如果我们想让一个函数使用一个值但不获取所有权怎么办？如果我们想要再次使用传入的任何东西，除了可能想要返回的函数体产生的任何数据，也需要将其传回，这是相当烦人的。

rust让我们使用元组返回多个值。
![[Pasted image 20240509153617.png]]
但这太过于繁琐，对于一个本应普遍的概念来说，需要做很多工作。幸运的是，Rust 有一个特性，可以使用值而不转移所有权，称为引用。
###  #2、借用和生命周期

在列表 4-5 中的元组代码存在的问题是，我们必须将 `String` 返回给调用函数，这样我们在调用 `calculate_length` 后仍然可以使用 `String` ，因为 `String` 已经移动到 `calculate_length` 中。相反，我们可以提供对 `String` 值的引用。引用类似于指针，因为它是一个地址，我们可以跟随该地址以访问存储在该地址的数据；该数据由其他变量拥有。与指针不同，引用保证在引用的生命周期内指向特定类型的有效值。

这是您如何定义和使用一个具有对象引用作为参数而不是获取值所有权的 `calculate_length` 函数：
![[Pasted image 20240509153815.png]]
首先，请注意变量声明和函数返回值中的所有元组代码已经消失。其次，请注意我们将 `&s1` 传递给 `calculate_length` ，在其定义中，我们取 `&String` 而不是 `String` 。这些和符号代表引用，它们允许您引用某个值而不获取其所有权。图 4-5 描绘了这个概念。
![[Pasted image 20240509153900.png]]
![[Pasted image 20240509153915.png]]
让我们仔细看一下这里的函数调用：
![[Pasted image 20240509153947.png]]
`&s1` 语法允许我们创建一个引用，该引用指向 `s1` 的值，但并不拥有它。因为它不拥有该值，所以当引用停止使用时，它指向的值不会被丢弃。
同样，函数的签名使用 `&` 来表示参数 `s` 的类型是一个引用。

变量 `s` 有效的范围与任何函数参数的范围相同，但引用指向的值在 `s` 停止使用时不会被丢弃，因为 `s` 没有所有权。当函数的参数是引用而不是实际值时，我们不需要返回值来归还所有权，因为我们从未拥有过所有权。

我们称创建引用的行为为借用。就像在现实生活中，如果一个人拥有某物，你可以向他们借用。借用完毕后，你必须归还。你并不拥有它。

那么，如果我们尝试修改我们借用的东西会发生什么呢？尝试列表 4-6 中的代码。剧透警告：它不起作用！
![[Pasted image 20240509154136.png]]
![[Pasted image 20240509154156.png]]
变量默认是不可变的，引用也是如此。我们不允许修改我们引用的内容。

我们可以通过对清单 4-6 中的代码进行一些小的调整，使用可变引用来允许我们修改一个借用值。

![[Pasted image 20240509154227.png]]
首先我们将 `s` 更改为 `mut` 。然后我们使用 `&mut s` 创建一个可变引用，在其中调用 `change` 函数，并更新函数签名以接受一个带有 `some_string: &mut String` 的可变引用。这样非常清楚地表明 `change` 函数将改变它借用的值。

可变引用有一个重要限制：如果您有一个对值的可变引用，那么您不能有对该值的其他引用。试图创建两个对 `s` 的可变引用的代码将失败：

这个错误表示这段代码无效，因为我们不能同时多次借用 `s` 作为可变的。第一个可变借用在 `r1` 中，并且必须持续到在 `println!` 中使用它之前，但在创建该可变引用和使用它之间，我们尝试在 `r2` 中创建另一个可变引用，它借用与 `r1` 相同的数据。

阻止同时对相同数据进行多个可变引用的限制允许进行变异，但以非常受控的方式进行。这是新的 Rustaceans 会遇到困难的地方，因为大多数语言都允许您随时进行变异。具有此限制的好处是 Rust 可以在编译时防止数据竞争。数据竞争类似于竞争条件，当出现以下三种行为时会发生数据竞争：
1、两个或更多指针同时访问相同数据。
2、至少有一个指针被用于写入数据。
3、没有机制用于同步对数据的访问。

数据竞争会导致未定义的行为，并且在运行时尝试跟踪它们时可能很难诊断和修复；Rust 通过拒绝编译具有数据竞争的代码来防止这个问题！

与往常一样，我们可以使用花括号创建新的作用域，允许多个可变引用，只是不能同时存在。
![[Pasted image 20240509154545.png]]

Rust 对于组合可变引用和不可变引用实施了类似的规则。这段代码会导致错误：
![[Pasted image 20240509154604.png]]
![[Pasted image 20240509154652.png]]
当我们拥有对相同值的不可变引用时，也不能拥有可变引用。

不可变引用的用户不希望值在他们底下突然改变！然而，允许多个不可变引用，因为只是读取数据的人没有能力影响其他人对数据的读取。

请注意，引用的范围从引入引用的地方开始，并持续到最后一次使用该引用。例如，此代码将编译，因为不可变引用的最后使用发生在引入可变引用之前：
![[Pasted image 20240509154724.png]]
不可变引用 `r1` 和 `r2` 的作用域在它们最后使用的 `println!` 结束之后，即在可变引用 `r3` 创建之前。这些作用域不重叠，因此这段代码是允许的：编译器可以确定在作用域结束之前引用不再被使用。

尽管有时候借用错误可能会让人沮丧，但请记住，这是 Rust 编译器在编译时早期指出潜在错误（而不是在运行时），并准确告诉您问题出在哪里。这样，您就不必追踪为什么您的数据不是您所认为的那样。

### [悬空引用](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#dangling-references)

在具有指针的语言中，很容易错误地创建悬空指针——指向内存中可能已经分配给其他人的位置的指针——通过释放一些内存同时保留对该内存的指针。相比之下，在 Rust 中，编译器保证引用永远不会是悬空引用：如果您有对某些数据的引用，编译器将确保在对数据的引用消失之前，数据不会超出范围。

让我们尝试创建一个悬空引用，看看 Rust 如何通过编译时错误来防止它们：

![[Pasted image 20240509154922.png]]

![[Pasted image 20240509154939.png]]

这个错误消息指的是一个我们还没有涉及的特性：生命周期。我们将在第 10 章详细讨论生命周期。但是，如果你忽略了关于生命周期的部分，这条消息确实包含了为什么这段代码有问题的关键：

让我们更仔细地看看我们的 `dangle` 代码在每个阶段到底发生了什么：
![[Pasted image 20240509155016.png]]
因为 `s` 是在 `dangle` 内创建的，当 `dangle` 的代码完成时， `s` 将被释放。但我们尝试返回一个对它的引用。这意味着这个引用将指向一个无效的 `String` 。这样不好！Rust 不会让我们这样做。

这里的解决方案是直接返回 `String` ：
![[Pasted image 20240509155044.png]]

在任何时候，您可以拥有一个可变引用或任意数量的不可变引用。

参考文献必须始终有效。

## [切片类型](https://doc.rust-lang.org/book/ch04-03-slices.html#the-slice-type)不同类型的引用

切片允许您引用集合中的连续元素序列，而不是整个集合。切片是一种引用，因此它没有所有权。
这里有一个小的编程问题：编写一个函数，该函数接受一个由空格分隔的单词字符串，并返回在该字符串中找到的第一个单词。如果函数在字符串中找不到空格，则整个字符串必须是一个单词，因此应返回整个字符串。

让我们通过不使用切片来编写此函数的签名，以了解切片将解决的问题：
![[Pasted image 20240509155412.png]]

`first_word` 函数有一个 `&String` 作为参数。我们不想要所有权，所以这很好。但是我们应该返回什么？我们实际上没有办法谈论字符串的一部分。但是，我们可以返回单词结束的索引，由空格表示。让我们尝试一下，如清单 4-7 所示。
![[Pasted image 20240509155436.png]]
因为我们需要逐个遍历 `String` 元素并检查值是否为空格，所以我们将使用 `as_bytes` 方法将我们的 `String` 转换为字节数组。

![[Pasted image 20240509155458.png]]
接下来，我们使用 `iter` 方法在字节数组上创建一个迭代器：
![[Pasted image 20240509155515.png]]
我们将在第 13 章更详细地讨论迭代器。现在，知道 `iter` 是一个方法，它返回集合中的每个元素， `enumerate` 包装 `iter` 的结果，并将每个元素作为元组的一部分返回。从 `enumerate` 返回的元组的第一个元素是索引，第二个元素是元素的引用。这比我们自己计算索引要方便一些。

因为 `enumerate` 方法返回一个元组，我们可以使用模式来解构该元组。我们将在第 6 章更多地讨论模式。在 `for` 循环中，我们指定一个模式，该模式在元组中具有 `i` 索引和 `&item` 单字节。因为我们从 `.iter().enumerate()` 获取元素的引用，所以在模式中使用 `&` 。

在 `for` 循环中，我们使用字节文字语法搜索表示空格的字节。如果找到空格，我们返回位置。否则，我们使用 `s.len()` 返回字符串的长度。

我们现在有一种方法可以找出字符串中第一个单词的末尾索引，但是有一个问题。我们只返回一个 `usize` ，但在 `&String` 的上下文中才是一个有意义的数字。换句话说，因为它是一个独立于 `String` 的值，所以不能保证它在将来仍然有效。考虑使用列表 4-7 中的 `first_word` 函数的列表 4-8 中的程序。

![[Pasted image 20240509155712.png]]
该程序编译时没有任何错误，如果在调用 `s.clear()` 后使用 `word` ，也是如此。因为 `word` 与 `s` 的状态没有任何关联， `word` 仍然包含值 `5` 。我们可以使用该值 `5` 与变量 `s` 尝试提取第一个单词，但这将是一个错误，因为自从我们在 `word` 中保存 `5` 以来， `s` 的内容已经改变。

必须担心 `word` 中的索引与 `s` 中的数据不同步是繁琐且容易出错的！如果编写 `second_word` 函数，管理这些索引将变得更加脆弱。其签名必须如下所示：
![[Pasted image 20240509155739.png]]
现在我们正在跟踪起始索引和结束索引，并且有更多的值是从特定状态中的数据计算出来的，但与该状态没有任何关联。我们有三个无关的变量漂浮在周围，需要保持同步。

幸运的是，Rust 有一个解决这个问题的方法：字符串切片。

### [字符串切片](https://doc.rust-lang.org/book/ch04-03-slices.html#string-slices)

字符串切片是对 `String` 的一部分的引用，它看起来像这样：
![[Pasted image 20240509160514.png]]
与整个 `String` 的引用不同， `hello` 是对 `String` 的一部分的引用，该部分在额外的 `[0..5]` 位中指定。我们使用方括号内的范围指定 `[starting_index..ending_index]` 来创建切片，其中 `starting_index` 是切片中的第一个位置， `ending_index` 比切片中的最后一个位置多一个。在内部，切片数据结构存储切片的起始位置和长度，对应于 `ending_index` 减 `starting_index` 。因此，在 `let world = &s[6..11];` 的情况下， `world` 将是一个包含指向 `s` 索引为 6 的字节的切片，其长度值为 `5` 。
![[Pasted image 20240509160838.png]]
使用 Rust 的 `..` 范围语法，如果要从索引 0 开始，可以在两个句点之前省略值。换句话说，以下两者相等：
![[Pasted image 20240509161000.png]]
同样地，如果您的切片包括 `String` 的最后一个字节，则可以删除尾随的数字。这意味着这些是相等的：
![[Pasted image 20240509161021.png]]
您也可以放弃这两个值，以获取整个字符串的片段。因此，这两者是相等的：
![[Pasted image 20240509161039.png]]
注意：字符串切片范围索引必须出现在有效的 UTF-8 字符边界上。如果您尝试在多字节字符的中间创建字符串切片，您的程序将以错误退出。为了介绍字符串切片，我们在本节中假设仅使用 ASCII；有关 UTF-8 处理的更全面讨论，请参阅第 8 章“使用字符串存储 UTF-8 编码文本”部分。

考虑到所有这些信息，让我们重写 `first_word` 以返回一个切片。表示“字符串切片”的类型写作 `&str`。

![[Pasted image 20240509161118.png]]
我们获取单词结尾的索引方式与在列表 4-7 中相同，即查找第一个空格的出现。当我们找到一个空格时，我们使用字符串的起始和空格的索引作为起始和结束索引返回一个字符串切片。

现在当我们调用 `first_word` 时，我们会得到一个与底层数据相关联的单个值。该值由对切片起始点的引用和切片中元素数量组成。

返回一个切片也适用于 `second_word` 函数：
![[Pasted image 20240509161254.png]]
我们现在有一个简单直接的 API，更难出错，因为编译器会确保对 `String` 的引用保持有效。还记得程序清单 4-8 中的 bug 吗？当我们将索引移到第一个单词的末尾，然后清除字符串，导致我们的索引无效？那段代码在逻辑上是错误的，但没有显示任何立即错误。如果我们继续尝试使用已清空字符串的第一个单词索引，问题将在以后出现。切片使这个 bug 不可能出现，并让我们更早地知道代码存在问题。使用 `first_word` 的切片版本将会抛出编译时错误：
![[Pasted image 20240509161321.png]]
![[Pasted image 20240509161412.png]]
根据借用规则，如果我们有对某物的不可变引用，就不能再获取可变引用。因为 `clear` 需要截断 `String` ，所以它需要获取可变引用。调用 `clear` 后的 `println!` 使用 `word` 中的引用，因此在那一点上不可变引用仍然有效。Rust 不允许同时存在 `clear` 中的可变引用和 `word` 中的不可变引用，因此编译失败。Rust 不仅使我们的 API 更易于使用，还在编译时消除了整个类别的错误！

#### [字符串字面量作为切片](https://doc.rust-lang.org/book/ch04-03-slices.html#string-literals-as-slices)

回想一下我们谈到的字符串字面值存储在二进制中。现在我们了解了切片，我们可以正确理解字符串字面值：
![[Pasted image 20240509161743.png]]
这里的 `s` 类型是 `&str` ：它是指向二进制特定点的切片。这也是为什么字符串字面值是不可变的； `&str` 是一个不可变引用。
#### [字符串切片作为参数](https://doc.rust-lang.org/book/ch04-03-slices.html#string-slices-as-parameters)

知道你可以取字面量和 `String` 值的片段，这让我们对 `first_word` 有了更多的改进，那就是它的签名：
![[Pasted image 20240509161836.png]]
一个更有经验的 Rustacean 会选择在列表 4-9 中显示的签名，因为它允许我们在 `&String` 值和 `&str` 值上使用相同的函数。
![[Pasted image 20240509161859.png]]
如果我们有一个字符串切片，我们可以直接传递它。如果我们有一个 `String` ，我们可以传递一个 `String` 的切片或一个 `String` 的引用。这种灵活性利用了解引用强制转换的特性，这是我们将在第 15 章“函数和方法中的隐式解引用强制转换”部分介绍的功能。

定义一个函数以接受字符串切片而不是 `String` 的引用，使我们的 API 更通用和有用，而不会失去任何功能：
![[Pasted image 20240509162013.png]]

字符串切片，正如你所想象的那样，是特定于字符串的。但也有一种更通用的切片类型。考虑这个数组：
`let a = [1, 2, 3, 4, 5];`

就像我们可能想要引用字符串的一部分一样，我们可能想要引用数组的一部分。我们可以这样做：
![[Pasted image 20240509162110.png]]
这个切片的类型是 `&[i32]` 。它的工作方式与字符串切片相同，通过存储对第一个元素的引用和长度来实现。您将使用这种类型的切片来处理各种其他集合。在第 8 章讨论向量时，我们将详细讨论这些集合。

所有权、借用和切片的概念确保了 Rust 程序在编译时的内存安全。Rust 语言让您像其他系统编程语言一样控制内存使用，但当所有者超出范围时自动清理数据的所有者意味着您无需编写和调试额外代码来获得此控制。

所有权影响 Rust 的许多其他部分的工作方式，因此我们将在本书的其余部分进一步讨论这些概念。让我们继续阅读第 5 章，看看如何将数据片段组合在一个 `struct` 中。

### #3、类型系统与trait

##### 1、结构体
结构体是一种自定义数据类型，允许您打包并命名多个相关值，这些值组成一个有意义的组。如果您熟悉面向对象的语言，那么结构体就像对象的数据属性。在本章中，我们将比较和对比元组与结构体，以便在您已经了解的基础上构建，并演示何时结构体是更好的数据分组方式。

我们将演示如何定义和实例化结构体。我们将讨论如何定义关联函数，特别是称为方法的关联函数，以指定与结构体类型相关联的行为。结构体和枚举（在第 6 章中讨论）是在程序领域中创建新类型的基本组件，以充分利用 Rust 的编译时类型检查。

结构体类似于元组，在“元组类型”部分讨论过，因为两者都包含多个相关值。与元组类似，结构体的各部分可以是不同类型。与元组不同的是，在结构体中，您将为每个数据部分命名，以便清楚地表示值的含义。添加这些名称意味着结构体比元组更灵活：您不必依赖数据的顺序来指定或访问实例的值。

要定义一个结构体，我们输入关键字 `struct` 并命名整个结构体。结构体的名称应描述被组合在一起的数据部分的重要性。然后，在花括号内，我们定义数据部分的名称和类型，我们称之为字段。例如，第 5-1 节显示了一个存储有关用户帐户信息的结构体。

![[Pasted image 20240509163446.png]]
在定义结构体后使用它，我们通过为每个字段指定具体值来创建该结构体的实例。我们通过声明结构体的名称并添加包含键值对的花括号来创建一个实例，其中键是字段的名称，值是我们要存储在这些字段中的数据。我们不必按照在结构体中声明它们的顺序指定字段。换句话说，结构体定义就像类型的通用模板，实例使用特定数据填充该模板以创建类型的值。例如，我们可以声明特定用户，如第 5-2 节所示。
![[Pasted image 20240509163515.png]]
要从结构体中获取特定值，我们使用点表示法。例如，要访问此用户的电子邮件地址，我们使用 `user1.email` 。如果实例是可变的，我们可以通过使用点表示法并分配到特定字段来更改值。图 5-3 显示了如何更改可变 `User` 实例中 `email` 字段中的值。
![[Pasted image 20240509163928.png]]
请注意整个实例必须是可变的；Rust 不允许我们仅标记某些字段为可变的。与任何表达式一样，我们可以在函数体中的最后一个表达式中构造结构体的新实例，以隐式返回该新实例。
清单 5-4 显示了一个 `build_user` 函数，该函数返回一个具有给定电子邮件和用户名的 `User` 实例。 `active` 字段获取 `true` 的值， `sign_in_count` 获取 `1` 的值。

![[Pasted image 20240509164006.png]]
将函数参数命名为与结构字段相同的名称是有道理的，但不得不重复 `email` 和 `username` 字段名称和变量有点乏味。如果结构体有更多字段，重复每个名称会变得更加恼人。幸运的是，有一个方便的简写方式！
![[Pasted image 20240509164347.png]]
### [使用结构更新语法从其他实例创建实例](https://doc.rust-lang.org/book/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax)

通常情况下，创建一个包含另一个实例大部分数值但有所改变的结构体新实例是很有用的。您可以使用结构体更新语法来实现这一点。

首先，在列表 5-6 中，我们展示了如何在 `user2` 中定期创建一个新的 `User` 实例，而不使用更新语法。我们为 `email` 设置了一个新值，但除此之外，我们使用了在列表 5-2 中创建的 `user1` 相同的值。

![[Pasted image 20240509223943.png]]

使用结构更新语法，我们可以用更少的代码实现相同的效果，如清单 5-7 所示。语法 `..` 指定未明确设置的其余字段应具有与给定实例中的字段相同的值。

![[Pasted image 20240509224024.png]]

在列表 5-7 中的代码还创建了一个实例，该实例在 `user2` 中具有不同的 `email` 值，但与 `user1` 中的 `username` 、 `active` 和 `sign_in_count` 字段具有相同的值。 `..user1` 必须放在最后，以指定任何剩余字段应从 `user1` 中的相应字段获取其值，但我们可以选择以任何顺序为尽可能多的字段指定值，而不考虑结构定义中字段的顺序。

请注意，结构体更新语法使用 `=` 类似于赋值；这是因为它移动数据，就像我们在“变量和数据与移动交互”部分看到的那样。在这个例子中，创建 `user2` 后，我们不能再将 `user1` 作为整体使用，因为 `user1` 字段中的 `String` 已经移动到 `user2` 中。如果我们为 `user2` 和 `username` 分别给出了新的 `String` 值，并且只使用了 `user1` 中的 `active` 和 `sign_in_count` 值，那么在创建 `user2` 后， `user1` 仍然有效。 `active` 和 `sign_in_count` 都是实现了 `Copy` 特质的类型，因此我们在“仅限堆栈数据：复制”部分讨论的行为将适用。

### [使用没有命名字段的元组结构创建不同类型](https://doc.rust-lang.org/book/ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types)

Rust 还支持类似于元组的结构体，称为元组结构体。元组结构体具有结构体名称提供的附加含义，但不具有与字段关联的名称；相反，它们只具有字段的类型。当您想要为整个元组命名并使元组成为与其他元组不同类型时，以及在常规结构体中为每个字段命名会显得冗长或多余时，元组结构体是有用的。

要定义一个元组结构体，首先使用 `struct` 关键字，然后是结构体名称，后面跟着元组中的类型。例如，这里我们定义并使用了两个元组结构体，分别命名为 `Color` 和 `Point` ：
![[Pasted image 20240509224340.png]]
请注意， `black` 和 `origin` 的值是不同类型的，因为它们是不同元组结构的实例。您定义的每个结构体都是自己的类型，即使结构体内的字段可能具有相同的类型。例如，一个接受类型为 `Color` 的参数的函数不能接受 `Point` 作为参数，即使这两种类型都由三个 `i32` 值组成。否则，元组结构的实例与元组类似，您可以将它们解构为各个部分，并且您可以使用 `.` 后跟索引来访问单个值。
### [没有任何字段的单元结构](https://doc.rust-lang.org/book/ch05-01-defining-structs.html#unit-like-structs-without-any-fields)

您还可以定义没有任何字段的结构体！这些被称为类似单元的结构体，因为它们的行为类似于 `()` ，我们在“元组类型”部分提到的单元类型。当您需要在某种类型上实现一个特质但又没有任何要存储在类型本身中的数据时，类似单元的结构体会很有用。我们将在第 10 章讨论特质。这里是声明和实例化一个名为 `AlwaysEqual` 的单元结构体的示例：
![[Pasted image 20240509224503.png]]

为了定义 `AlwaysEqual` ，我们使用 `struct` 关键字，我们想要的名称，然后是一个分号。不需要花括号或括号！然后我们可以以类似的方式在 `subject` 变量中获取 `AlwaysEqual` 的实例：使用我们定义的名称，不带任何花括号或括号。想象一下，稍后我们将为这种类型实现行为，使得每个 `AlwaysEqual` 的实例始终等于任何其他类型的实例，也许是为了测试目的而获得已知结果。我们不需要任何数据来实现这种行为！您将在第 10 章中看到如何定义特征并将其实现在任何类型上，包括类似单元的结构。

在清单 5-1 中的 `User` 结构定义中，我们使用了拥有的 `String` 类型，而不是 `&str` 字符串切片类型。这是一个有意为之的选择，因为我们希望这个结构的每个实例都拥有其所有数据，并且这些数据在整个结构有效时都是有效的。

结构体也可以存储对其他所有者拥有的数据的引用，但这需要使用生命周期，这是 Rust 的一个特性，我们将在第 10 章中讨论。生命周期确保结构体引用的数据在结构体存在期间是有效的。假设您尝试在结构体中存储一个引用而没有指定生命周期，就像下面这样；这是行不通的：

![[Pasted image 20240509225031.png]]
编译器会抱怨它需要生命周期标识符：
![[Pasted image 20240509225108.png]]

在第 10 章，我们将讨论如何修复这些错误，以便您可以在结构体中存储引用，但目前，我们将使用拥有类型（如 `String` ）而不是引用（如 `&str` ）来修复这些错误。

要了解何时需要使用结构体，让我们编写一个计算矩形面积的程序。我们将从使用单个变量开始，然后重构程序，直到我们改为使用结构体。

让我们使用 Cargo 创建一个名为 rectangles 的新二进制项目，该项目将获取以像素为单位指定的矩形的宽度和高度，并计算矩形的面积。清单 5-8 显示了一个简短的程序，展示了在项目的 src/main.rs 中以一种方式完成这一任务。

![[Pasted image 20240509225208.png]]
这段代码通过调用 `area` 函数来计算矩形的面积，但我们可以做更多的工作来使这段代码更清晰易读。

fn area(width: u32, height: u32) -> u32 {

`area` 函数应该计算一个矩形的面积，但我们编写的函数有两个参数，在我们的程序中并没有清楚地表明这两个参数是相关的。将宽度和高度组合在一起会更易读和更易管理。我们已经讨论过一种可能的方法，在第 3 章“元组类型”部分中：使用元组。

### [使用元组重构](https://doc.rust-lang.org/book/ch05-02-example-structs.html#refactoring-with-tuples)

![[Pasted image 20240509225329.png]]

在某种程度上，这个程序更好了。元组让我们添加了一点结构，现在我们只传递了一个参数。但在另一方面，这个版本不太清晰：元组没有为它们的元素命名，所以我们必须索引元组的各个部分，使我们的计算不太明显。

混淆宽度和高度对于面积计算并不重要，但如果我们想在屏幕上绘制矩形，那就很重要！我们必须记住 `width` 是元组索引 `0` ， `height` 是元组索引 `1` 。如果其他人要使用我们的代码，要想弄清楚并记住这一点会更加困难。因为我们在代码中没有传达数据的含义，所以现在更容易引入错误。

### [使用结构重构：添加更多含义](https://doc.rust-lang.org/book/ch05-02-example-structs.html#refactoring-with-structs-adding-more-meaning)

我们使用结构体通过为数据加标签来赋予意义。我们可以将正在使用的元组转换为一个具有整体名称和部分名称的结构体，如清单 5-10 所示。

![[Pasted image 20240509225446.png]]

在这里，我们定义了一个结构体并命名为 `Rectangle` 。在花括号内，我们将字段定义为 `width` 和 `height` ，它们的类型都是 `u32` 。然后，在 `main` 中，我们创建了一个特定实例 `Rectangle` ，宽度为 `30` ，高度为 `50` 。

我们的 `area` 函数现在使用一个参数进行定义，我们将其命名为 `rectangle` ，其类型为不可变借用的 `Rectangle` 结构体实例。正如第 4 章中所提到的，我们希望借用结构体而不是拥有它。这样， `main` 保留了它的所有权，并且可以继续使用 `rect1` ，这也是我们在函数签名和调用函数的地方使用 `&` 的原因。

`area` 函数访问 `Rectangle` 实例的 `width` 和 `height` 字段（请注意，访问借用的结构体实例的字段不会移动字段值，这就是为什么经常看到结构体的借用）。我们现在对 `area` 的函数签名准确地表达了我们的意思：计算 `Rectangle` 的面积，使用其 `width` 和 `height` 字段。这表明宽度和高度彼此相关，并为值提供了描述性名称，而不是使用 `0` 和 `1` 的元组索引值。这对于清晰度是一个胜利。

### [使用派生特性添加有用功能](https://doc.rust-lang.org/book/ch05-02-example-structs.html#adding-useful-functionality-with-derived-traits)

在我们调试程序时，能够打印 `Rectangle` 的一个实例并查看其所有字段的值将会很有用。在尝试使用我们在之前章节中使用过的 `println!` 宏的清单 5-11 中，这种方法不起作用。

![[Pasted image 20240509225613.png]]

当我们编译这段代码时，会出现一个错误，错误信息如下：

error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`

`println!` 宏可以执行多种格式化操作，默认情况下，花括号告诉 `println!` 使用称为 `Display` 的格式化：用于直接最终用户消费的输出。到目前为止，我们看到的原始类型默认实现了 `Display` ，因为只有一种方式可以向用户显示 `1` 或其他任何原始类型。但是对于结构体， `println!` 应该如何格式化输出就不那么清晰了，因为有更多的显示可能性：您想要逗号还是不要？您想要打印花括号吗？所有字段都应该显示吗？由于这种模棱两可，Rust 不会尝试猜测我们想要什么，结构体没有提供 `Display` 的实现，供 `println!` 和 `{}` 占位符使用。

如果我们继续阅读错误，我们会发现这个有用的提示：
= help: the trait `std::fmt::Display` is not implemented for `Rectangle` = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead

让我们试试看！现在， `println!` 宏调用将会变成 `println!("rect1 is {:?}", rect1);` 。将占位符 `:?` 放在花括号内告诉 `println!` 我们想要使用一个名为 `Debug` 的输出格式。 `Debug` 特性使我们能够以对开发人员有用的方式打印出我们的结构体，这样我们在调试代码时可以看到它的值。

用这个更改编译代码。该死！我们仍然遇到错误：

error[E0277]: `Rectangle` doesn't implement `Debug`

但是，编译器再次给了我们一个有用的提示：

= help: the trait `Debug` is not implemented for `Rectangle` = note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`

Rust 确实包含打印调试信息的功能，但我们必须明确选择使该功能对我们的结构体可用。为此，我们在结构体定义之前添加外部属性 `#[derive(Debug)]` ，如清单 5-12 所示。
![[Pasted image 20240509225840.png]]
现在当我们运行程序时，不会出现任何错误，我们会看到以下输出：

![[Pasted image 20240509225957.png]]

不错！输出结果可能不是最漂亮的，但它显示了此实例所有字段的值，这在调试过程中肯定会有所帮助。当我们有更大的结构体时，有一个更容易阅读的输出是很有用的；在这种情况下，我们可以在字符串 `println!` 中使用 `{:#?}` 而不是 `{:?}` 。在这个例子中，使用 `{:#?}` 风格将输出以下内容：

![[Pasted image 20240509230023.png]]
使用 `Debug` 格式打印值的另一种方法是使用 `dbg!` 宏，该宏获取表达式的所有权（与 `println!` 相反，它获取引用），打印出 `dbg!` 宏调用在代码中发生的文件和行号以及该表达式的结果值，并返回该值的所有权。

注意：调用 `dbg!` 宏会打印到标准错误控制台流（ `stderr` ），而不是打印到标准输出控制台流（ `stdout` ）。我们将在第 12 章“将错误消息写入标准错误而不是标准输出”部分更多地讨论 `stderr` 和 `stdout` 。

这是一个例子，我们对分配给 `width` 字段的值感兴趣，以及整个结构体在 `rect1` 中的值：
![[Pasted image 20240509230118.png]]

我们可以在表达式 `30 * scale` 周围放置 `dbg!` ，因为 `dbg!` 返回表达式值的所有权，所以 `width` 字段将获得与我们没有 `dbg!` 调用时相同的值。我们不希望 `dbg!` 获取 `rect1` 的所有权，因此在下一个调用中使用 `rect1` 的引用。这个示例的输出如下：

![[Pasted image 20240509230203.png]]

我们可以看到第一部分输出来自 src/main.rs 的第 10 行，我们正在调试表达式 `30 * scale` ，其结果值为 `60` （整数的 `Debug` 格式化实现只打印它们的值）。src/main.rs 的第 14 行上的 `dbg!` 调用输出 `&rect1` 的值，这是 `Rectangle` 结构体。此输出使用 `Rectangle` 类型的漂亮 `Debug` 格式化。当您试图弄清楚代码在做什么时， `dbg!` 宏可能非常有帮助！

除了 `Debug` 特性外，Rust 还为我们提供了许多特性，可以与 `derive` 属性一起使用，为我们的自定义类型添加有用的行为。这些特性及其行为在附录 C 中列出。我们将在第 10 章中介绍如何实现这些特性以及如何创建自己的特性。除了 `derive` 之外，还有许多其他属性；有关更多信息，请参阅 Rust 参考手册中的“属性”部分。

我们的 `area` 函数非常具体：它只计算矩形的面积。将这种行为与我们的 `Rectangle` 结构更紧密地联系在一起会很有帮助，因为它不适用于任何其他类型。让我们看看如何通过将 `area` 函数转换为定义在我们的 `Rectangle` 类型上的 `area` 方法来继续重构这段代码。

方法类似于函数：我们使用 `fn` 关键字和名称声明它们，它们可以有参数和返回值，并且它们包含一些代码，当方法从其他地方调用时运行。与函数不同，方法是在结构体的上下文中定义的（或者在第 6 章和第 17 章中分别介绍的枚举或特质对象中），它们的第一个参数始终是 `self` ，表示方法被调用的结构体实例。

让我们修改具有 `Rectangle` 实例作为参数的 `area` 函数，而是在 `Rectangle` 结构体上定义一个 `area` 方法，如清单 5-13 所示。

![[Pasted image 20240509230545.png]]

在 `Rectangle` 的上下文中定义函数，我们为 `Rectangle` 启动一个 `impl` （实现）块。该 `impl` 块中的所有内容将与 `Rectangle` 类型相关联。然后，我们将 `area` 函数移至 `impl` 花括号内，并将签名中的第一个参数（在这种情况下是唯一的参数）更改为 `self` ，并在整个主体中使用。在 `main` 中，我们调用 `area` 函数并将 `rect1` 作为参数传递时，我们可以改用方法语法在 `Rectangle` 实例上调用 `area` 方法。方法语法在实例之后进行：我们添加一个点，然后是方法名称、括号和任何参数。

在 `area` 的签名中，我们使用 `&self` 而不是 `rectangle: &Rectangle` 。 `&self` 实际上是 `self: &Self` 的缩写。在 `impl` 块中，类型 `Self` 是 `impl` 块所用类型的别名。方法必须有一个名为 `self` 且类型为 `Self` 的参数作为它们的第一个参数，因此 Rust 允许您在第一个参数位置上仅使用名称 `self` 来缩写。请注意，我们仍然需要在 `self` 缩写前面使用 `&` 来指示该方法借用 `Self` 实例，就像我们在 `rectangle: &Rectangle` 中所做的那样。方法可以获取 `self` 的所有权，以不可变方式借用 `self` ，就像我们在这里所做的那样，或者以可变方式借用 `self` ，就像它们可以处理任何其他参数一样。

出于与函数版本中使用 `&Rectangle` 相同的原因，我们在这里选择了 `&self` ：我们不想拥有它，只想读取结构中的数据，而不是写入它。如果我们想要更改作为方法一部分调用的实例，我们将使用 `&mut self` 作为第一个参数。仅使用 `self` 作为第一个参数获取实例所有权的方法很少见；通常在方法将 `self` 转换为其他内容并希望在转换后阻止调用者使用原始实例时使用此技术。

使用方法而不是函数的主要原因，除了提供方法语法并且不必在每个方法的签名中重复 `self` 的类型之外，还有组织性。我们将可以对类型实例执行的所有操作放在一个 `impl` 块中，而不是让我们代码的未来用户在我们提供的库的各个地方搜索 `Rectangle` 的功能。

请注意，我们可以选择将方法命名为结构体字段之一相同的名称。例如，我们可以在 `Rectangle` 上定义一个也被命名为 `width` 的方法：

![[Pasted image 20240509230730.png]]
在这里，我们选择使 `width` 方法返回 `true` ，如果实例的 `width` 字段中的值大于 `0` ，并且如果值为 `0` ，则返回 `false` ：我们可以为任何目的在同名方法中使用字段。在 `main` 中，当我们在 `rect1.width` 后面加上括号时，Rust 知道我们指的是方法 `width` 。当我们不使用括号时，Rust 知道我们指的是字段 `width` 。

通常，但并非总是，当我们给一个方法取与字段相同的名称时，我们希望它只返回字段中的值，而不做其他操作。这样的方法称为 getter，Rust 不像其他一些语言那样自动为结构字段实现它们。Getter 很有用，因为您可以将字段设为私有，但将方法设为公共，从而在类型的公共 API 中启用对该字段的只读访问。我们将在第 7 章讨论公共和私有是什么，以及如何将字段或方法指定为公共或私有。

在 C 和 C++中，调用方法时使用两种不同的运算符：如果直接在对象上调用方法，则使用 `.` ；如果在对象的指针上调用方法并且需要先解引用指针，则使用 `->` 。换句话说，如果 `object` 是一个指针，那么 `object->something()` 类似于 `(*object).something()` 。

Rust 没有等同于 `->` 运算符的功能；相反，Rust 有一个称为自动引用和解引用的特性。在 Rust 中，调用方法是少数具有这种行为的地方之一。

这是它的工作原理：当您使用 `object.something()` 调用一个方法时，Rust 会自动添加 `&` 、 `&mut` 或 `*` ，以使 `object` 与方法的签名匹配。换句话说，以下内容是相同的：
![[Pasted image 20240509232740.png]]

第一个看起来干净多了。这种自动引用行为之所以有效，是因为方法有一个明确的接收者—— `self` 的类型。给定方法的接收者和名称，Rust 可以明确地确定该方法是读取（ `&self` ）、变异（ `&mut self` ）还是消耗（ `self` ）。Rust 使得方法接收者的借用隐式化，这是实际中使所有权使用起来更加方便的重要部分。

### [具有更多参数的方法](https://doc.rust-lang.org/book/ch05-03-method-syntax.html#methods-with-more-parameters)

让我们通过在 `Rectangle` 结构上实现第二个方法来练习使用方法。这次，我们希望 `Rectangle` 的一个实例接受另一个 `Rectangle` 的实例，并在第二个 `Rectangle` 完全适合 `self` （第一个 `Rectangle` ）时返回 `true` ；否则，它应该返回 `false` 。也就是说，一旦我们定义了 `can_hold` 方法，我们希望能够编写列表 5-14 中显示的程序。
![[Pasted image 20240509233143.png]]
由于 `rect2` 的两个维度均小于 `rect1` 的维度，所以预期的输出将如下所示，但 `rect3` 比 `rect1` 更宽：
Can rect1 hold rect2? true 
Can rect1 hold rect3? false

我们知道我们想要定义一个方法，所以它将在 `impl Rectangle` 块内。方法名将是 `can_hold` ，它将以另一个 `Rectangle` 的不可变借用作为参数。我们可以通过查看调用方法的代码来确定参数的类型： `rect1.can_hold(&rect2)` 传入 `&rect2` ，这是对 `rect2` 的不可变借用， `Rectangle` 的一个实例。这是有道理的，因为我们只需要读取 `rect2` （而不是写入，这意味着我们需要一个可变借用），我们希望 `main` 保留对 `rect2` 的所有权，这样我们在调用 `can_hold` 方法后可以再次使用它。 `can_hold` 的返回值将是一个布尔值，实现将检查 `self` 的宽度和高度是否分别大于另一个 `Rectangle` 的宽度和高度。让我们将新的 `can_hold` 方法添加到列表 5-13 中的 `impl` 块中，如列表 5-15 所示。
![[Pasted image 20240509234559.png]]
当我们在列表 5-14 中使用 `main` 函数运行此代码时，我们将获得我们想要的输出。方法可以接受多个参数，我们将这些参数添加到 `self` 参数后的签名中，这些参数的工作方式就像函数中的参数一样。

在 `impl` 块中定义的所有函数都被称为关联函数，因为它们与以 `impl` 命名的类型相关联。我们可以定义不以 `self` 作为第一个参数的关联函数（因此不是方法），因为它们不需要类型的实例来使用。我们已经使用了一个类似的函数：在 `String` 类型上定义的 `String::from` 函数。

与方法不同的相关函数通常用于将返回结构体新实例的构造函数。这些通常被称为 `new` ，但 `new` 不是特殊名称，也不是内置于语言中的。例如，我们可以选择提供一个名为 `square` 的相关函数，该函数将具有一个维度参数，并将其用作宽度和高度，从而更容易创建一个正方形 `Rectangle` ，而不必指定相同的值两次。
![[Pasted image 20240510221639.png]]
返回类型和函数体中的 `Self` 关键字是出现在 `impl` 关键字之后的类型的别名，本例中为 `Rectangle` 。

要调用此关联函数，我们使用 `::` 语法与结构名称； `let sq = Rectangle::square(3);` 是一个示例。此函数由结构命名空间化： `::` 语法用于模块创建的关联函数和命名空间。我们将在第 7 章讨论模块。

### [多个 `impl` 块](https://doc.rust-lang.org/book/ch05-03-method-syntax.html#multiple-impl-blocks)

每个结构体都允许有多个 `impl` 块。例如，列表 5-15 等同于列表 5-16 中显示的代码，其中每个方法都在自己的 `impl` 块中。
![[Pasted image 20240510221729.png]]

结构体允许您创建对您的领域有意义的自定义类型。通过使用结构体，您可以将相关的数据片段连接在一起，并为每个片段命名，以使您的代码清晰。在 `impl` 块中，您可以定义与您的类型相关联的函数，方法是一种关联函数，让您指定结构体实例的行为。

# [枚举和模式匹配](https://doc.rust-lang.org/book/ch06-00-enums.html#enums-and-pattern-matching)
在本章中，我们将看看枚举，也称为 enums。枚举允许您通过列举其可能的变体来定义类型。
首先，我们将定义并使用一个枚举来展示枚举如何可以编码含义以及数据。
接下来，我们将探讨一个特别有用的枚举，称为 `Option` ，它表示一个值可以是某物或无。
然后，我们将看看模式匹配在 `match` 表达式中如何使得针对枚举的不同值运行不同代码变得容易。
最后，我们将介绍 `if let` 结构是另一个方便且简洁的习语，可用于处理代码中的枚举。

## [定义枚举](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html#defining-an-enum)

结构体为您提供了一种将相关字段和数据组合在一起的方式，就像一个 `Rectangle` 与其 `width` 和 `height` 一样，而枚举则为您提供了一种表明一个值是可能值集合中的一个的方式。例如，我们可能想要说 `Rectangle` 是一组可能形状之一，还包括 `Circle` 和 `Triangle` 。为了实现这一点，Rust 允许我们将这些可能性编码为枚举。

让我们看一个我们可能想要在代码中表达的情况，并看看为什么在这种情况下枚举比结构体更有用且更合适。假设我们需要处理 IP 地址。目前，IP 地址使用两种主要标准：第四版和第六版。因为这些是我们的程序将遇到的 IP 地址的唯一可能性，我们可以枚举所有可能的变体，这就是枚举得名的原因。

任何 IP 地址都可以是版本四或版本六地址，但不能同时是两者。IP 地址的这种属性使枚举数据结构合适，因为枚举值只能是其变体之一。版本四和版本六地址仍然基本上是 IP 地址，因此在代码处理适用于任何类型 IP 地址的情况时，它们应被视为相同类型。

我们可以通过定义一个 `IpAddrKind` 枚举并列出 IP 地址可能的种类 `V4` 和 `V6` 来在代码中表达这个概念。这些是枚举的变体：
![[Pasted image 20240510222525.png]]

`IpAddrKind` 现在是我们可以在代码中其他地方使用的自定义数据类型。

我们可以像这样创建 `IpAddrKind` 的两个变体的实例：
![[Pasted image 20240510222553.png]]
请注意，枚举的变体是在其标识符下进行命名空间管理的，我们使用双冒号来分隔这两者。这很有用，因为现在值 `IpAddrKind::V4` 和 `IpAddrKind::V6` 都是相同类型的： `IpAddrKind` 。例如，我们可以定义一个接受任何 `IpAddrKind` 的函数：
![[Pasted image 20240510222617.png]]
我们可以使用任一变体调用此函数：
![[Pasted image 20240510222654.png]]
使用枚举类型还有更多的优势。再考虑一下我们的 IP 地址类型，目前我们没有办法存储实际的 IP 地址数据；我们只知道它是什么类型。考虑到你在第 5 章刚学习过结构体，你可能会想用结构体来解决这个问题，就像清单 6-1 中所示的那样。
![[Pasted image 20240510222717.png]]
在这里，我们定义了一个结构体 `IpAddr` ，它有两个字段：一个 `kind` 字段，类型为 `IpAddrKind` （我们之前定义的枚举），和一个 `address` 字段，类型为 `String` 。我们有两个这个结构体的实例。第一个是 `home` ，它的值为 `IpAddrKind::V4` ，作为其 `kind` ，关联的地址数据为 `127.0.0.1` 。第二个实例是 `loopback` 。它有 `IpAddrKind` 的另一个变体作为其 `kind` 值， `V6` ，并且有关联的地址 `::1` 。我们使用一个结构体将 `kind` 和 `address` 的值捆绑在一起，所以现在变体与值关联在一起。

然而，仅使用枚举来表示相同的概念更为简洁：我们可以将数据直接放入每个枚举变体，而不是将枚举放在结构体内部。这个新的 `IpAddr` 枚举的定义表示， `V4` 和 `V6` 变体都将具有关联的 `String` 值：
![[Pasted image 20240510222826.png]]

我们直接将数据附加到枚举的每个变体上，因此不需要额外的结构。在这里，我们还更容易看到枚举如何工作的另一个细节：我们定义的每个枚举变体的名称也成为构造枚举实例的函数。也就是说， `IpAddr::V4()` 是一个函数调用，接受一个 `String` 参数并返回 `IpAddr` 类型的实例。我们在定义枚举时自动获得这个构造函数。

使用枚举而不是结构体的另一个优势是：每个变体可以具有不同类型和数量的关联数据。 版本四 IP 地址将始终具有四个数值组件，其值将介于 0 和 255 之间。 如果我们想将 `V4` 地址存储为四个 `u8` 值，但仍将 `V6` 地址表示为一个 `String` 值，那么使用结构体是无法实现的。 枚举可以轻松处理这种情况：
![[Pasted image 20240510223937.png]]
我们直接将数据附加到枚举的每个变体上，因此不需要额外的结构。在这里，我们还更容易看到枚举如何工作的另一个细节：我们定义的每个枚举变体的名称也成为构造枚举实例的函数。也就是说， `IpAddr::V4()` 是一个函数调用，接受一个 `String` 参数并返回 `IpAddr` 类型的实例。我们在定义枚举时自动获得这个构造函数。

使用枚举而不是结构体的另一个优势是：每个变体可以具有不同类型和数量的关联数据。 版本四 IP 地址将始终具有四个数值组件，其值将介于 0 和 255 之间。 如果我们想将 `V4` 地址存储为四个 `u8` 值，但仍将 `V6` 地址表示为一个 `String` 值，那么使用结构体是无法实现的。 枚举可以轻松处理这种情况：
![[Pasted image 20240510224356.png]]

我们已经展示了几种不同的定义数据结构来存储版本四和版本六的 IP 地址的方法。然而，事实证明，想要存储 IP 地址并编码它们的类型是如此普遍，以至于标准库有一个我们可以使用的定义！让我们看看标准库是如何定义 `IpAddr` 的：它具有我们定义和使用的确切枚举和变体，但它将地址数据嵌入到变体中，形式为两种不同的结构体，这两种结构体对每个变体进行了不同的定义：

![[Pasted image 20240510224619.png]]
这段代码说明您可以将任何类型的数据放入枚举变体中：例如字符串、数值类型或结构体。您甚至可以包含另一个枚举！此外，标准库类型通常并不比您可能想出的更复杂。

请注意，即使标准库包含 `IpAddr` 的定义，我们仍然可以创建并使用我们自己的定义，而不会发生冲突，因为我们还没有将标准库的定义引入到我们的范围内。我们将在第 7 章更多地讨论将类型引入范围的问题。

让我们看另一个枚举的例子，如清单 6-2 所示：其中包含各种类型嵌入在其变体中。

![[Pasted image 20240510224725.png]]

这个枚举有四个不同类型的变体：

- `Quit` has no data associated with it at all.  
    `Quit` 没有任何关联的数据。
- `Move` has named fields, like a struct does.  
    `Move` 有命名字段，就像结构体一样。
- `Write` includes a single `String`.  
    `Write` 包括一个 `String` 。
- `ChangeColor` includes three `i32` values.  
    `ChangeColor` 包括三个 `i32` 值。

使用列在清单 6-2 中的变体定义枚举类似于定义不同种类的结构定义，不同之处在于枚举不使用 `struct` 关键字，所有变体都在 `Message` 类型下分组在一起。以下结构体可以保存与前述枚举变体相同的数据。

![[Pasted image 20240510224836.png]]
但是，如果我们使用不同的结构体，每个结构体都有自己的类型，那么我们就无法像在列表 6-2 中定义的 `Message` 枚举那样轻松地定义一个函数来接受这些消息中的任何一种，因为枚举是单一类型。

枚举和结构体之间还有一个相似之处：就像我们可以使用 `impl` 在结构体上定义方法一样，我们也可以在枚举上定义方法。这是一个我们可以在 `Message` 枚举上定义的名为 `call` 的方法：

![[Pasted image 20240510225724.png]]

该方法的主体将使用 `self` 来获取我们调用方法时的值。在这个例子中，我们创建了一个变量 `m` ，它的值为 `Message::Write(String::from("hello"))` ，这就是当 `m.call()` 运行时 `call` 方法主体中的 `self` 。

让我们来看看标准库中另一个非常常见和有用的枚举： `Option` 。

### [`Option` 枚举及其优势相对于空值](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html#the-option-enum-and-its-advantages-over-null-values)

本节探讨了一个 `Option` 的案例研究，这是标准库定义的另一个枚举。 `Option` 类型编码了一个非常常见的情况，即一个值可能是某物，也可能是空。

例如，如果您请求非空列表中的第一个项目，您将获得一个值。如果您请求空列表中的第一个项目，您将得到空。用类型系统表达这个概念意味着编译器可以检查您是否处理了应该处理的所有情况；这种功能可以防止在其他编程语言中非常常见的错误。

编程语言设计通常是根据包含哪些特性来考虑的，但排除哪些特性也同样重要。Rust 没有许多其他语言具有的空特性。Null 是一个表示没有值的值。在具有 null 的语言中，变量始终处于两种状态之一：null 或非 null。

在他 2009 年的演讲《空引用：十亿美元的错误》中，null 的发明者 Tony Hoare 说到：
我称之为我的十亿美元错误。那时，我正在为面向对象语言中的引用设计第一个全面的类型系统。我的目标是确保所有引用的使用绝对安全，由编译器自动执行检查。但我无法抗拒放入一个空引用的诱惑，仅仅因为实现起来太容易了。这导致了无数的错误、漏洞和系统崩溃，在过去四十年中可能造成了数十亿美元的痛苦和损失。

空值的问题在于，如果您尝试将空值用作非空值，则会收到某种错误。由于这种空值或非空值属性是无处不在的，因此很容易犯这种错误。

然而，null 试图表达的概念仍然是有用的：null 是一个当前无效或缺失的值。

问题实际上并不在于概念，而在于具体的实现。因此，
Rust 没有空值，但它有一个枚举类型，可以编码值存在或不存在的概念。这个枚举类型是 `Option<T>` ，并且由标准库定义如下：

![[Pasted image 20240510230207.png]]

`Option<T>` 枚举非常有用，甚至包含在预导入模块中；您无需显式地将其引入作用域。它的变体也包含在预导入模块中：您可以直接使用 `Some` 和 `None` ，无需 `Option::` 前缀。 `Option<T>` 枚举仍然只是一个常规枚举， `Some(T)` 和 `None` 仍然是 `Option<T>` 类型的变体。

`<T>` 语法是 Rust 的一个特性，我们还没有讨论过。它是一个泛型类型参数，我们将在第 10 章更详细地介绍泛型。现在，你需要知道的是 `<T>` 意味着 `Some` 枚举的 `Option` 变体可以容纳任何类型的数据，并且每个用于替代 `T` 的具体类型都会使得整体的 `Option<T>` 类型成为不同的类型。以下是一些使用 `Option` 值来保存数字类型和字符串类型的示例：

![[Pasted image 20240510230245.png]]

`some_number` 的类型是 `Option<i32>` 。 `some_char` 的类型是 `Option<char>` ，这是一种不同的类型。Rust 可以推断这些类型，因为我们在 `Some` 变体内指定了一个值。对于 `absent_number` ，Rust 要求我们注释整体的 `Option` 类型：编译器无法仅通过查看 `None` 值来推断相应的 `Some` 变体将保存的类型。在这里，我们告诉 Rust 我们希望 `absent_number` 是 `Option<i32>` 类型。

当我们有一个 `Some` 值时，我们知道存在一个值，并且该值保存在 `Some` 中。当我们有一个 `None` 值时，在某种意义上它意味着与 null 相同：我们没有一个有效的值。那么为什么拥有 `Option<T>` 要比拥有 null 好呢？

简而言之，因为 `Option<T>` 和 `T` （其中 `T` 可以是任何类型）是不同的类型，编译器不会让我们将 `Option<T>` 值用作绝对有效的值。例如，这段代码不会编译，因为它试图将 `i8` 添加到 `Option<i8>` 中：

![[Pasted image 20240511085152.png]]
![[Pasted image 20240511085210.png]]
强烈！实际上，这个错误消息意味着 Rust 不知道如何将 `i8` 和 `Option<i8>` 相加，因为它们是不同的类型。当我们在 Rust 中有一个类型为 `i8` 的值时，编译器将确保我们始终有一个有效的值。我们可以放心地继续，而无需在使用该值之前检查 null。只有当我们有一个 `Option<i8>` （或者我们正在处理的任何类型的值）时，我们才需要担心可能没有值，编译器将确保我们在使用该值之前处理该情况。

换句话说，在执行 `T` 操作之前，您必须将 `Option<T>` 转换为 `T` 。一般来说，这有助于捕捉 null 的最常见问题之一：假设某些东西不是 null，而实际上它是。

消除错误地假设非 null 值的风险有助于您对代码更有信心。为了拥有一个可能为 null 的值，您必须通过将该值的类型明确设置为 `Option<T>` 来显式选择加入。然后，在使用该值时，您必须明确处理值为 null 的情况。在值具有不是 `Option<T>` 的类型的任何地方，您可以安全地假设该值不为 null。这是 Rust 有意为之的设计决定，以限制 null 的普遍性并增加 Rust 代码的安全性。

那么，当您有一个类型为 `Option<T>` 的值时，如何从 `Some` 变体中获取 `T` 值，以便您可以使用该值？ `Option<T>` 枚举有大量在各种情况下非常有用的方法；您可以在其文档中查看这些方法。熟悉 `Option<T>` 上的方法将对您在 Rust 之旅中非常有用。

一般来说，为了使用 `Option<T>` 值，您希望有处理每个变体的代码。您希望一些代码仅在您有一个 `Some(T)` 值时运行，并且此代码可以使用内部的 `T` 。您希望另一些代码仅在您有一个 `None` 值时运行，并且该代码没有 `T` 值可用。 `match` 表达式是一个控制流构造，当与枚举一起使用时，它将根据枚举的哪个变体运行不同的代码，并且该代码可以使用匹配值内部的数据。

## [`match` 控制流构造](https://doc.rust-lang.org/book/ch06-02-match.html#the-match-control-flow-construct)
Rust 拥有一个非常强大的控制流构造，称为 `match` ，它允许您将一个值与一系列模式进行比较，然后根据匹配的模式执行代码。模式可以由文字值、变量名、通配符和许多其他内容组成；第 18 章涵盖了所有不同类型的模式及其功能。 `match` 的强大之处在于模式的表现力，以及编译器确认处理了所有可能的情况。

将 `match` 表达式想象成一个硬币分类机：硬币沿着带有各种大小孔的轨道滑动，每个硬币都会掉入它适合的第一个孔中。同样，值会通过 `match` 中的每个模式，当值“适合”第一个模式时，该值将掉入相关代码块中，在执行过程中使用。

说到硬币，让我们以 `match` 为例！我们可以编写一个函数，接受一个未知的美国硬币，并类似于计数机器，确定它是哪种硬币，并以美分为单位返回其值，如清单 6-3 所示。

![[Pasted image 20240511085519.png]]

让我们来分解 `value_in_cents` 函数中的 `match` 。首先我们列出 `match` 关键字，然后是一个表达式，这里是值 `coin` 。这似乎与在 `if` 中使用的条件表达式非常相似，但有一个很大的区别：在 `if` 中，条件需要求值为布尔值，但在这里可以是任何类型。在这个例子中， `coin` 的类型是我们在第一行定义的 `Coin` 枚举。

接下来是 `match` 个手臂。一个手臂有两部分：一个模式和一些代码。这里的第一个手臂有一个模式，其值为 `Coin::Penny` ，然后是 `=>` 运算符，用于分隔模式和要运行的代码。在这种情况下，代码只是值 `1` 。每个手臂之间用逗号分隔。

当 `match` 表达式执行时，它会将结果值与每个分支的模式进行比较，依次进行。如果某个模式与该值匹配，则执行与该模式关联的代码。如果该模式与该值不匹配，则执行将继续到下一个分支，就像硬币分类机一样。我们可以根据需要设置任意多的分支：在列表 6-3 中，我们的 `match` 有四个分支。

与每个分支相关联的代码是一个表达式，在匹配分支中表达式的结果值是整个 `match` 表达式返回的值。

如果匹配分支代码很短，我们通常不使用花括号，就像在清单 6-3 中每个分支只返回一个值一样。如果要在匹配分支中运行多行代码，必须使用花括号，然后分支后面的逗号是可选的。例如，以下代码每次使用 `Coin::Penny` 调用方法时都会打印“幸运的一分钱！”，但仍然返回块的最后一个值 `1` ：

![[Pasted image 20240511085753.png]]

### [绑定到值的模式](https://doc.rust-lang.org/book/ch06-02-match.html#patterns-that-bind-to-values)

匹配臂的另一个有用功能是它们可以绑定到与模式匹配的值的部分。这就是我们如何从枚举变体中提取值的方法。

举个例子，让我们将枚举变体之一更改为在其中保存数据。从 1999 年到 2008 年，美国铸造了一侧有 50 个州设计的 25 美分硬币。没有其他硬币有州设计，所以只有 25 美分硬币具有这种额外价值。我们可以通过将 `Quarter` 变体更改为包含内部存储的 `UsState` 值来将此信息添加到我们的 `enum` 中，这是我们在清单 6-4 中完成的。
![[Pasted image 20240511085922.png]]
让我们想象一下，一个朋友正在努力收集所有 50 个州纪念币。当我们按硬币类型整理零钱时，我们还会大声说出与每个纪念币相关的州名，这样如果是我们的朋友还没有的，他们就可以把它加入到自己的收藏中。

在此代码的匹配表达式中，我们向匹配变体 `Coin::Quarter` 的模式中添加一个名为 `state` 的变量。当 `Coin::Quarter` 匹配时， `state` 变量将绑定到该季度状态的值。然后我们可以在代码中使用 `state` 来表示该分支，如下所示：
![[Pasted image 20240511090632.png]]
如果我们称 `value_in_cents(Coin::Quarter(UsState::Alaska))` 为 `coin` ，那么 `Coin::Quarter(UsState::Alaska)` 将会是 `Coin::Quarter(state)` 。当我们将该值与每个匹配的分支进行比较时，直到达到 `state` 之前，都没有匹配。在那一点上， `state` 的绑定将是值 `UsState::Alaska` 。然后我们可以在 `println!` 表达式中使用该绑定，从而将 `Coin` 枚举变体的内部状态值取出来，用于 `Quarter` 。

### [与 `Option<T>` 匹配](https://doc.rust-lang.org/book/ch06-02-match.html#matching-with-optiont)

在前一节中，我们想要在使用 `Option<T>` 时从 `Some` 情况中取出内部 `T` 值；我们也可以使用 `match` 处理 `Option<T>` ，就像我们处理 `Coin` 枚举一样！我们不再比较硬币，而是比较 `Option<T>` 的变体，但 `match` 表达式的工作方式仍然相同。

假设我们想要编写一个函数，该函数接受一个 `Option<i32>` ，如果里面有值，则将该值加 1。如果里面没有值，则函数应返回 `None` 值，并且不尝试执行任何操作。

这个函数非常容易编写，多亏了 `match` ，看起来会像 6-5 清单。

![[Pasted image 20240511162126.png]]
让我们更详细地检查 `plus_one` 的第一次执行。当我们调用 `plus_one(five)` 时，在 `plus_one` 的主体中的变量 `x` 将具有值 `Some(5)` 。然后我们将其与每个匹配分支进行比较：
![[Pasted image 20240511162207.png]]

`Some(5)` 的值与模式 `None` 不匹配，因此我们继续到下一个分支：
![[Pasted image 20240511162244.png]]

`Some(5)` 是否匹配 `Some(i)` ？是的！我们有相同的变体。 `i` 绑定到 `Some` 中包含的值，所以 `i` 取值 `5` 。然后执行匹配分支中的代码，所以我们将 `i` 的值加 1，并创建一个新的 `Some` 值，其中包含我们的总计 `6` 。

现在让我们考虑列表 6-5 中 `plus_one` 的第二个调用，其中 `x` 是 `None` 。我们输入 `match` 并与第一个参数进行比较：
![[Pasted image 20240511162320.png]]

匹配成功！没有值可添加，因此程序停止并返回 `=>` 右侧的 `None` 值。由于第一个分支匹配成功，不会比较其他分支。

将 `match` 和枚举结合在一起在许多情况下都很有用。在 Rust 代码中，你会经常看到这种模式：与枚举匹配，将一个变量绑定到其中的数据，然后根据它执行代码。一开始有点棘手，但一旦习惯了，你会希望所有语言都有这个功能。这一直是用户喜爱的功能。

### [比赛是彻底的](https://doc.rust-lang.org/book/ch06-02-match.html#matches-are-exhaustive)

我们需要讨论 `match` 的另一个方面：手臂的模式必须涵盖所有可能性。考虑一下我们 `plus_one` 函数的这个版本，它有一个错误，无法编译：
![[Pasted image 20240511162752.png]]

我们没有处理 `None` 情况，所以这段代码会导致一个错误。幸运的是，这是一个 Rust 知道如何捕捉的错误。如果我们尝试编译这段代码，我们会得到这个错误：
![[Pasted image 20240511162817.png]]
rust 知道我们没有涵盖每种可能情况，甚至知道我们忘记了哪种模式！在 Rust 中，匹配是穷尽的：我们必须穷尽每一种可能性，以使代码有效。特别是在 `Option<T>` 的情况下，当 Rust 防止我们忘记明确处理 `None` 的情况时，它保护我们免于假设我们有一个值，而实际上可能是 null，从而使之前讨论的数十亿美元错误成为不可能。

### [匹配所有模式和 `_` 占位符](https://doc.rust-lang.org/book/ch06-02-match.html#catch-all-patterns-and-the-_-placeholder)
使用枚举，我们还可以针对一些特定值采取特殊操作，但对于所有其他值采取一个默认操作。想象一下，我们正在实现一个游戏，在游戏中，如果你掷骰子掷出 3 点，你的玩家不会移动，而是会得到一个新的花哨帽子。如果你掷出 7 点，你的玩家会失去一个花哨帽子。对于所有其他值，你的玩家会在游戏板上移动相应的空间数。这里有一个 `match` ，它实现了这种逻辑，骰子掷出的结果是硬编码的，而不是随机值，并且所有其他逻辑由没有主体的函数表示，因为实际实现它们超出了此示例的范围。
![[Pasted image 20240511163434.png]]

对于前两个臂，模式是字面值 `3` 和 `7` 。对于覆盖每个其他可能值的最后一个臂，模式是我们选择命名为 `other` 的变量。运行 `other` 臂的代码使用该变量，通过将其传递给 `move_player` 函数。

这段代码可以编译通过，即使我们没有列出 `u8` 可能具有的所有可能值，因为最后一个模式将匹配所有未明确列出的值。这个通配模式满足了 `match` 必须是穷尽的要求。

请注意，我们必须将通配分支放在最后，因为模式是按顺序评估的。如果我们将通配分支放在前面，其他分支将永远不会运行，因此如果我们在通配后添加分支，Rust 会警告我们！

Rust 还有一种模式，当我们想要一个全匹配但又不想使用全匹配值时可以使用： `_` 是一个特殊模式，匹配任何值但不绑定该值。这告诉 Rust 我们不打算使用该值，因此 Rust 不会警告我们有一个未使用的变量。

让我们改变游戏规则：现在，如果你掷出的是 3 或 7 之外的任何数字，你必须再掷一次。我们不再需要使用全匹配值，所以我们可以改变我们的代码，使用 `_` 代替名为 `other` 的变量：
![[Pasted image 20240511195126.png]]
最后，我们将再次更改游戏规则，这样如果您掷出的是 3 或 7 以外的任何数字，您的回合将不会发生任何其他事情。我们可以通过使用单位值（我们在“元组类型”部分提到的空元组类型）作为与 `_` 臂对应的代码来表达这一点：
![[Pasted image 20240511195242.png]]
在这里，我们明确告诉 Rust，我们不打算使用任何与之前一个分支中的模式不匹配的值，并且我们不希望在这种情况下运行任何代码。

在第 18 章中，我们将介绍更多关于模式和匹配的内容。现在，我们将继续讨论 `if let` 语法，这在 `match` 表达有点冗长的情况下非常有用。

## [使用 `if let` 进行简洁的控制流](https://doc.rust-lang.org/book/ch06-03-if-let.html#concise-control-flow-with-if-let)

`if let` 语法允许您将 `if` 和 `let` 结合在一起，以更简洁的方式处理与一个模式匹配的值相匹配的情况，同时忽略其余情况。考虑列表 6-6 中的程序，该程序在 `config_max` 变量中匹配 `Option<u8>` 值，但只想在该值是 `Some` 变体时执行代码。
![[Pasted image 20240511201546.png]]

如果值为 `Some` ，我们通过将该值绑定到模式中的变量 `max` 来打印出 `Some` 变体中的值。我们不想对 `None` 值执行任何操作。为满足 `match` 表达式，我们必须在处理一个变体后添加 `_ => ()` ，这是一种烦人的样板代码。

相反，我们可以使用 `if let` 以更简短的方式编写此代码。以下代码的行为与列表 6-6 中的 `match` 相同：

![[Pasted image 20240511201653.png]]

语法 `if let` 接受一个由等号分隔的模式和表达式。它的工作方式与 `match` 相同，其中表达式提供给 `match` ，而模式是其第一个分支。在这种情况下，模式是 `Some(max)` ，而 `max` 绑定到 `Some` 中的值。然后我们可以在 `if let` 块的主体中使用 `max` ，就像我们在相应的 `match` 分支中使用 `max` 一样。如果值不匹配模式，则不会运行 `if let` 块中的代码。

使用 `if let` 意味着更少的输入、更少的缩进和更少的样板代码。但是，您会失去 `match` 强制执行的详尽检查。在 `match` 和 `if let` 之间的选择取决于您在特定情况下的操作以及简洁性是否值得失去详尽检查。

换句话说，您可以将 `if let` 视为一种语法糖，用于运行代码当值匹配一个模式时，然后忽略所有其他值。

我们可以使用 `else` 和 `if let` 。与 `else` 相关的代码块与等效于 `if let` 和 `else` 的 `match` 表达式中的 `_` 情况的代码块相同。回想一下列表 6-4 中的 `Coin` 枚举定义，其中 `Quarter` 变体还包含一个 `UsState` 值。如果我们想要计算我们看到的所有非四分之一硬币，同时宣布四分之一硬币的状态，我们可以使用 `match` 表达式，如下所示：
![[Pasted image 20240511201806.png]]

或者我们可以使用 `if let` 和 `else` 表达式，如下所示：
![[Pasted image 20240511201850.png]]
如果您的程序逻辑过于冗长，无法使用 `match` 表达，请记住 `if let` 也在您的 Rust 工具箱中。

## [总结](https://doc.rust-lang.org/book/ch06-03-if-let.html#summary)

我们已经介绍了如何使用枚举创建可以是一组枚举值之一的自定义类型。我们展示了标准库的 `Option<T>` 类型如何帮助您使用类型系统来防止错误。当枚举值内部包含数据时，您可以使用 `match` 或 `if let` 来提取和使用这些值，具体取决于您需要处理多少种情况。

您的 Rust 程序现在可以使用结构体和枚举来表达领域中的概念。创建自定义类型以在 API 中使用可确保类型安全：编译器将确保您的函数仅获得每个函数期望的类型的值。

为了向用户提供一个组织良好的 API，易于使用且只暴露用户所需的内容，让我们现在转向 Rust 的模块。

### #4、突破抽象范式
### #5、unsafe #rust
