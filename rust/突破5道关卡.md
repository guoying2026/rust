###  #1、所有权机制
在不需要垃圾收集器的情况下提供内存安全性保证，因此了解所有权的工作原理非常重要。

>借用

> 切片

> rust如何在内存中布局

所有权是一组规则，用于指导rust程序如何管理内存。所有程序在运行时都必须管理它们使用计算机内存的方式。一些语言具有垃圾回收机制，会定期查找程序运行时不再使用的内存。而在其他语言中，程序员必须显示的分配和释放内存。rust使用第三种方法，通过一套所有权规则管理内存，编译器会检查这些规则。如果违反任何规则，程序将无法编译。所有权的任何特性都不会在程序运行时减慢程序的运行速度。

许多编程语言不需要您经常考虑栈和堆。但在像 Rust 这样的系统编程语言中，值是存储在栈上还是堆上会影响语言的行为，以及为什么您必须做出某些决策。本章后面将描述与栈和堆相关的所有权部分，因此在此之前，这里是一个简要的准备说明。

栈和堆都是您的代码在运行时可以使用的内存部分，但它们的结构方式不同。栈按照获取值的顺序存储值，并以相反的顺序移除值。这被称为后进先出。想象一下一叠盘子：当您添加更多盘子时，您将它们放在堆叠的顶部，当您需要一只盘子时，您从顶部取走一只。从中间或底部添加或移除盘子不会那么有效！添加数据称为推入栈，移除数据称为弹出栈。存储在栈上的所有数据必须具有已知的固定大小。在编译时大小未知或大小可能会更改的数据必须存储在堆上。

堆的组织性较差：当您将数据放入堆时，您请求一定量的空间。内存分配器在堆中找到一个足够大的空位，标记为正在使用，并返回一个指针，即该位置的地址。这个过程称为在堆上分配，有时简称为分配（将值推送到堆栈上不被视为分配）。由于堆的指针是已知的固定大小，您可以将指针存储在堆栈上，但当您需要实际数据时，必须跟随指针。想象一下在餐厅就座。当您进入时，告知您组里的人数，主人找到一个适合所有人的空桌并带您过去。如果您组里有人迟到，他们可以询问您就座的位置以找到您。

将数据推送到堆栈比在堆上分配更快，因为分配器永远不必搜索存储新数据的位置；该位置始终位于堆栈顶部。相比之下，在堆上分配空间需要更多工作，因为分配器必须首先找到足够大的空间来容纳数据，然后执行簿记以准备下一次分配。

在堆中访问数据比在栈中访问数据慢，因为你必须跟随指针才能到达那里。当代处理器在内存中跳跃较少时速度更快。延续这个类比，考虑一家餐厅的服务器从许多桌子上接订单。在转移到下一桌之前，最有效的方法是先获取一桌的所有订单。先从 A 桌接订单，然后从 B 桌接订单，再从 A 桌接订单，然后再从 B 桌接订单会是一个更慢的过程。同样地，处理器可以更好地完成工作，如果它处理的数据靠近其他数据（就像在栈上）而不是远离（就像在堆上）。

当您的代码调用一个函数时，传递给函数的值（包括可能指向堆上数据的指针）和函数的局部变量被推送到堆栈上。当函数结束时，这些值会从堆栈中弹出。

跟踪代码的哪些部分正在使用堆上的数据，最小化堆上重复数据的数量，并清理未使用的堆数据，以免空间不足，这些都是所有权解决的问题。一旦理解了所有权，你就不需要经常考虑栈和堆，但知道所有权的主要目的是管理堆数据可以帮助解释它为什么以这种方式工作。

----------------------------------------------------
所有权规则
一、Rust 中的每个值都有一个所有者。
二、一次只能有一个所有者。
三、当所有者超出范围时，该值将被丢弃。

作为所有权的第一个示例，我们将看一下一些变量的范围。范围是程序中项目有效的范围。拿以下变量为例：

`let s = "hello";`

变量 `s` 指的是一个字符串字面量，其中字符串的值是硬编码到我们程序的文本中的。该变量从声明的点开始有效，直到当前作用域的结束。图 4-1 显示了一个程序，其中有注释标注变量 `s` 的有效范围。
    {                      // s is not valid here, it’s not yet declared
        let s = "hello";   // s is valid from this point forward

        // do stuff with s
    }                      // this scope is now over, and s is no longer valid

当 `s` 进入范围时，它是有效的。
它在超出范围之前仍然有效。

在这一点上，作用域和变量有效的时间之间的关系类似于其他编程语言中的情况。现在我们将在这种理解的基础上介绍 `String` 类型。

为了说明所有权规则，我们需要一种比我们在第 3 章“数据类型”部分中涵盖的更复杂的数据类型。之前涵盖的类型是已知大小的，可以存储在堆栈上，并在其作用域结束时从堆栈中弹出，并且可以快速且轻松地复制以创建一个新的、独立的实例，如果代码的另一部分需要在不同的作用域中使用相同的值。但我们想要查看存储在堆上的数据，并探讨 Rust 如何知道何时清理这些数据， `String` 类型是一个很好的例子。

我们将集中讨论与所有权相关的 `String` 部分。这些方面也适用于其他复杂数据类型，无论是由标准库提供还是由您创建。我们将在第 8 章更深入地讨论 `String` 。

我们已经看到了字符串字面量，其中字符串值是硬编码到我们的程序中的。字符串字面量很方便，但并不适用于我们可能希望使用文本的每种情况。一个原因是它们是不可变的。另一个原因是，当我们编写代码时，并不是每个字符串值都是已知的：例如，如果我们想要接受用户输入并存储它会怎样？对于这些情况，Rust 有第二种字符串类型， `String` 。这种类型管理在堆上分配的数据，因此能够存储我们在编译时不知道的文本量。您可以使用 `from` 函数从字符串字面量创建一个 `String` ，就像这样：

`let s = String::from("hello");`

双冒号 `::` 运算符允许我们将这个特定的 `from` 函数命名空间化到 `String` 类型下，而不是使用类似 `string_from` 的名称。我们将在第 5 章的“方法语法”部分更详细地讨论这种语法，以及在第 7 章的“模块中项目引用路径”中讨论使用模块进行命名空间化。

这种字符串可以被改变：

那么，这里有什么区别呢？为什么 `String` 可以被改变，但字面值不能呢？区别在于这两种类型处理内存的方式。

在字符串字面值的情况下，我们在编译时知道内容，因此文本直接硬编码到最终可执行文件中。这就是为什么字符串字面值快速高效的原因。但这些特性只来自于字符串字面值的不可变性。不幸的是，我们无法为每个在编译时大小未知且在运行程序时可能会更改大小的文本块放入二进制文件中。

使用 `String` 类型，为了支持一个可变的、可增长的文本片段，我们需要在堆上分配一定数量的内存，编译时未知，以容纳内容。这意味着：
一、内存必须在运行时从内存分配器请求。
二、当我们完成 `String` 后，我们需要一种将这些内存返回给分配器的方法。

第一部分由我们完成：当我们调用 `String::from` 时，其实现会请求所需的内存。这在编程语言中几乎是普遍的。

然而，第二部分是不同的。在具有垃圾收集器（GC）的语言中，GC 会跟踪和清理不再使用的内存，我们不需要考虑这一点。在大多数没有 GC 的语言中，我们有责任识别何时不再使用内存，并调用代码显式释放它，就像我们请求它一样。正确地执行这一点在历史上一直是一个困难的编程问题。如果我们忘记了，我们会浪费内存。如果我们太早这样做，我们会有一个无效的变量。如果我们这样做两次，那也是一个错误。我们需要精确地将一个 `allocate` 与一个 `free` 配对。

rust采取了一种不同的路径：一旦拥有它的变量超出范围，内存就会自动返回。这是我们在列表 4-1 中使用 `String` 而不是字符串文字的作用域示例的一个版本：

    {
        let s = String::from("hello"); // s is valid from this point forward

        // do stuff with s
    }                                  // this scope is now over, and s is no
                                       // longer valid

当 `s` 超出范围时，我们可以在自然点将 `String` 需要的内存返回给分配器。当变量超出范围时，Rust 会为我们调用一个特殊函数。这个函数被称为 `drop` ，作者可以在其中放置返回内存的代码。Rust 会在闭合大括号处自动调用 `drop`.

这种模式对 Rust 代码的编写方式产生了深远影响。现在看起来可能很简单，但当我们想要让多个变量使用我们在堆上分配的数据时，在更复杂的情况下，代码的行为可能会出乎意料。让我们现在探讨一些这些情况。

#### [变量和数据与移动交互](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#variables-and-data-interacting-with-move)

    let x = 5;
    let y = x;
我们可能猜到这是在做什么：“将值 `5` 绑定到 `x` ；然后复制 `x` 中的值并绑定到 `y` 。”现在我们有两个变量， `x` 和 `y` ，两者都等于 `5` 。这确实是正在发生的事情，因为整数是已知固定大小的简单值，并且这两个 `5` 值被推送到堆栈上。

    let s1 = String::from("hello");
    let s2 = s1;

这看起来非常相似，因此我们可能会假设它的工作方式是相同的：也就是说，第二行会复制 `s1` 中的值并将其绑定到 `s2` 。但实际情况并非完全如此。
看看 `String` 在底层发生了什么。一个 `String` 由三部分组成，如左侧所示：指向保存字符串内容的内存的指针，长度和容量。这组数据存储在堆栈上。右侧是保存内容的堆上的内存。
![[Pasted image 20240509151230.png]]
长度是 `String` 内容当前使用的内存量（以字节为单位）。容量是 `String` 从分配器接收的总内存量（以字节为单位）。长度和容量之间的差异很重要，但在这种情况下并不重要，所以现在可以忽略容量。

当我们将 `s1` 分配给 `s2` 时， `String` 数据被复制，意味着我们复制了在堆栈上的指针、长度和容量。我们没有复制指针所指向的堆上的数据。换句话说，内存中的数据表示如图 4-2 所示。

![[Pasted image 20240509151402.png]]
如果 Rust 复制堆数据，内存看起来会是什么样子。如果 Rust 这样做了，如果堆上的数据很大，操作 `s2 = s1` 在运行时性能方面可能会非常昂贵。
![[Pasted image 20240509151450.png]]
当一个变量超出作用域时，Rust 会自动调用 `drop` 函数并清理该变量的堆内存。但图 4-2 显示两个数据指针指向同一位置。这是一个问题：当 `s2` 和 `s1` 超出作用域时，它们都会尝试释放相同的内存。这被称为双重释放错误，是我们之前提到的内存安全错误之一。释放内存两次可能导致内存损坏，进而可能导致安全漏洞。

为了确保内存安全，在 `let s2 = s1;` 之后，Rust 认为 `s1` 不再有效。因此，当 `s1` 超出范围时，Rust 不需要释放任何内容。看看当你尝试在创建 `s2` 之后使用 `s1` 时会发生什么；它不会起作用：
    let s1 = String::from("hello");
    let s2 = s1;

    println!("{}, world!", s1);
由于 Rust 阻止您使用无效的引用，您会收到这样的错误。
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:5:28
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{}, world!", s1);
  |                            ^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
  |
3 |     let s2 = s1.clone();
  |                ++++++++

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error

如果您在使用其他语言时听过浅拷贝和深拷贝这两个术语，那么在不拷贝数据的情况下拷贝指针、长度和容量的概念可能听起来像是在进行浅拷贝。但是因为 Rust 还会使第一个变量无效，所以不叫浅拷贝，而是称为移动。在这个例子中，我们会说 `s1` 被移动到 `s2`。
![[Pasted image 20240509151642.png]]
这解决了我们的问题！只有 `s2` 有效，当它超出范围时，它将自行释放内存，我们就完成了。
这暗示了一个设计选择：Rust 永远不会自动创建您的数据的“深”副本。因此，可以假定任何自动复制在运行时性能方面都是廉价的。

#### [变量和数据与克隆交互](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#variables-and-data-interacting-with-clone)

如果我们确实想要深度复制 `String` 的堆数据，而不仅仅是栈数据，我们可以使用一种常见的方法称为 `clone` 。我们将在第 5 章讨论方法语法，但由于方法是许多编程语言中的常见特性，您可能以前见过它们。
    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {}, s2 = {}", s1, s2);
当您看到对 `clone` 的调用时，您知道正在执行一些任意代码，并且该代码可能很昂贵。这是一个视觉指示，表明正在发生一些不同的事情。

#### [堆栈数据：复制](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#stack-only-data-copy)

还有一个我们还没有讨论的问题。这个使用整数的代码——其中部分在列表 4-2 中显示——是有效的。

    let x = 5;
    let y = x;

    println!("x = {}, y = {}", x, y);

但是这段代码似乎与我们刚学到的内容相矛盾：我们没有调用 `clone` ，但 `x` 仍然有效，并且没有移动到 `y` 。

原因是在编译时已知大小的整数等类型完全存储在堆栈上，因此实际值的副本制作起来很快。这意味着在创建变量 `y` 后，我们不希望阻止 `x` 有效。换句话说，在这里深复制和浅复制没有区别，因此调用 `clone` 不会产生任何与通常的浅复制不同的效果，我们可以省略它。

rust有一个特殊的注解叫做 `Copy` 特性，我们可以放在存储在堆栈上的类型上，就像整数一样（我们会在第 10 章更多地讨论特性）。如果一个类型实现了 `Copy` 特性，使用它的变量不会移动，而是被简单地复制，使得它们在分配给另一个变量后仍然有效。

如果类型或其任何部分已实现 `Drop` 特性，则rust不会让我们使用 `Copy` 注释类型。如果类型在值超出范围时需要发生特殊情况，并且我们为该类型添加 `Copy` 注释，则会收到编译时错误。要了解如何添加 `Copy` 注释以实现特性，请参阅附录 C 中的“可派生特性”。

那么，哪些类型实现了 `Copy` 特质？您可以查看给定类型的文档以确保，但通常来说，任何一组简单标量值都可以实现 `Copy` ，而任何需要分配或是某种资源形式的内容都不能实现 `Copy` 。以下是一些实现 `Copy` 的类型：

1、所有整数类型，例如 `u32` 。
2、布尔类型， `bool` ，具有值 `true` 和 `false` 。
3、所有的浮点类型，比如 `f64` 。
4、字符类型， `char` 。
5、元组，如果它们只包含也实现 `Copy` 的类型。例如， `(i32, i32)` 实现 `Copy` ，但 `(i32, String)` 不实现。

将值传递给函数的机制与将值分配给变量时类似。将变量传递给函数将移动或复制，就像赋值一样。图 4-3 中有一个示例，其中一些注释显示变量何时进入和退出作用域。
![[Pasted image 20240509153340.png]]
如果我们在调用 `takes_ownership` 之后尝试使用 `s` ，Rust 会抛出编译时错误。这些静态检查可以保护我们免受错误的影响。尝试添加代码到 `main` ，使用 `s` 和 `x` ，看看在哪里可以使用它们，以及所有权规则阻止你这样做的地方。

### [返回值和作用域](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#return-values-and-scope)

返回值也可以转移所有权。图 4-4 显示了一个返回某个值的函数示例，其注释与图 4-3 中的注释类似。
![[Pasted image 20240509153458.png]]

变量的所有权每次都遵循相同的模式：将值分配给另一个变量会移动它。当包含堆上数据的变量超出范围时，该值将由 `drop` 清理，除非数据的所有权已转移到另一个变量。

虽然这样可以运作，但是在每个函数中都要获取所有权然后再归还所有权有点繁琐。如果我们想让一个函数使用一个值但不获取所有权怎么办？如果我们想要再次使用传入的任何东西，除了可能想要返回的函数体产生的任何数据，也需要将其传回，这是相当烦人的。

rust让我们使用元组返回多个值。
![[Pasted image 20240509153617.png]]
但这太过于繁琐，对于一个本应普遍的概念来说，需要做很多工作。幸运的是，Rust 有一个特性，可以使用值而不转移所有权，称为引用。
###  #2、借用和生命周期

在列表 4-5 中的元组代码存在的问题是，我们必须将 `String` 返回给调用函数，这样我们在调用 `calculate_length` 后仍然可以使用 `String` ，因为 `String` 已经移动到 `calculate_length` 中。相反，我们可以提供对 `String` 值的引用。引用类似于指针，因为它是一个地址，我们可以跟随该地址以访问存储在该地址的数据；该数据由其他变量拥有。与指针不同，引用保证在引用的生命周期内指向特定类型的有效值。

这是您如何定义和使用一个具有对象引用作为参数而不是获取值所有权的 `calculate_length` 函数：
![[Pasted image 20240509153815.png]]
首先，请注意变量声明和函数返回值中的所有元组代码已经消失。其次，请注意我们将 `&s1` 传递给 `calculate_length` ，在其定义中，我们取 `&String` 而不是 `String` 。这些和符号代表引用，它们允许您引用某个值而不获取其所有权。图 4-5 描绘了这个概念。
![[Pasted image 20240509153900.png]]
![[Pasted image 20240509153915.png]]
让我们仔细看一下这里的函数调用：
![[Pasted image 20240509153947.png]]
`&s1` 语法允许我们创建一个引用，该引用指向 `s1` 的值，但并不拥有它。因为它不拥有该值，所以当引用停止使用时，它指向的值不会被丢弃。
同样，函数的签名使用 `&` 来表示参数 `s` 的类型是一个引用。

变量 `s` 有效的范围与任何函数参数的范围相同，但引用指向的值在 `s` 停止使用时不会被丢弃，因为 `s` 没有所有权。当函数的参数是引用而不是实际值时，我们不需要返回值来归还所有权，因为我们从未拥有过所有权。

我们称创建引用的行为为借用。就像在现实生活中，如果一个人拥有某物，你可以向他们借用。借用完毕后，你必须归还。你并不拥有它。

那么，如果我们尝试修改我们借用的东西会发生什么呢？尝试列表 4-6 中的代码。剧透警告：它不起作用！
![[Pasted image 20240509154136.png]]
![[Pasted image 20240509154156.png]]
变量默认是不可变的，引用也是如此。我们不允许修改我们引用的内容。

我们可以通过对清单 4-6 中的代码进行一些小的调整，使用可变引用来允许我们修改一个借用值。

![[Pasted image 20240509154227.png]]
首先我们将 `s` 更改为 `mut` 。然后我们使用 `&mut s` 创建一个可变引用，在其中调用 `change` 函数，并更新函数签名以接受一个带有 `some_string: &mut String` 的可变引用。这样非常清楚地表明 `change` 函数将改变它借用的值。

可变引用有一个重要限制：如果您有一个对值的可变引用，那么您不能有对该值的其他引用。试图创建两个对 `s` 的可变引用的代码将失败：

这个错误表示这段代码无效，因为我们不能同时多次借用 `s` 作为可变的。第一个可变借用在 `r1` 中，并且必须持续到在 `println!` 中使用它之前，但在创建该可变引用和使用它之间，我们尝试在 `r2` 中创建另一个可变引用，它借用与 `r1` 相同的数据。

阻止同时对相同数据进行多个可变引用的限制允许进行变异，但以非常受控的方式进行。这是新的 Rustaceans 会遇到困难的地方，因为大多数语言都允许您随时进行变异。具有此限制的好处是 Rust 可以在编译时防止数据竞争。数据竞争类似于竞争条件，当出现以下三种行为时会发生数据竞争：
1、两个或更多指针同时访问相同数据。
2、至少有一个指针被用于写入数据。
3、没有机制用于同步对数据的访问。

数据竞争会导致未定义的行为，并且在运行时尝试跟踪它们时可能很难诊断和修复；Rust 通过拒绝编译具有数据竞争的代码来防止这个问题！

与往常一样，我们可以使用花括号创建新的作用域，允许多个可变引用，只是不能同时存在。
![[Pasted image 20240509154545.png]]

Rust 对于组合可变引用和不可变引用实施了类似的规则。这段代码会导致错误：
![[Pasted image 20240509154604.png]]
![[Pasted image 20240509154652.png]]
当我们拥有对相同值的不可变引用时，也不能拥有可变引用。

不可变引用的用户不希望值在他们底下突然改变！然而，允许多个不可变引用，因为只是读取数据的人没有能力影响其他人对数据的读取。

请注意，引用的范围从引入引用的地方开始，并持续到最后一次使用该引用。例如，此代码将编译，因为不可变引用的最后使用发生在引入可变引用之前：
![[Pasted image 20240509154724.png]]
不可变引用 `r1` 和 `r2` 的作用域在它们最后使用的 `println!` 结束之后，即在可变引用 `r3` 创建之前。这些作用域不重叠，因此这段代码是允许的：编译器可以确定在作用域结束之前引用不再被使用。

尽管有时候借用错误可能会让人沮丧，但请记住，这是 Rust 编译器在编译时早期指出潜在错误（而不是在运行时），并准确告诉您问题出在哪里。这样，您就不必追踪为什么您的数据不是您所认为的那样。

### [悬空引用](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#dangling-references)

在具有指针的语言中，很容易错误地创建悬空指针——指向内存中可能已经分配给其他人的位置的指针——通过释放一些内存同时保留对该内存的指针。相比之下，在 Rust 中，编译器保证引用永远不会是悬空引用：如果您有对某些数据的引用，编译器将确保在对数据的引用消失之前，数据不会超出范围。

让我们尝试创建一个悬空引用，看看 Rust 如何通过编译时错误来防止它们：

![[Pasted image 20240509154922.png]]

![[Pasted image 20240509154939.png]]

这个错误消息指的是一个我们还没有涉及的特性：生命周期。我们将在第 10 章详细讨论生命周期。但是，如果你忽略了关于生命周期的部分，这条消息确实包含了为什么这段代码有问题的关键：

让我们更仔细地看看我们的 `dangle` 代码在每个阶段到底发生了什么：
![[Pasted image 20240509155016.png]]
因为 `s` 是在 `dangle` 内创建的，当 `dangle` 的代码完成时， `s` 将被释放。但我们尝试返回一个对它的引用。这意味着这个引用将指向一个无效的 `String` 。这样不好！Rust 不会让我们这样做。

这里的解决方案是直接返回 `String` ：
![[Pasted image 20240509155044.png]]

在任何时候，您可以拥有一个可变引用或任意数量的不可变引用。

参考文献必须始终有效。

## [切片类型](https://doc.rust-lang.org/book/ch04-03-slices.html#the-slice-type)不同类型的引用

切片允许您引用集合中的连续元素序列，而不是整个集合。切片是一种引用，因此它没有所有权。
这里有一个小的编程问题：编写一个函数，该函数接受一个由空格分隔的单词字符串，并返回在该字符串中找到的第一个单词。如果函数在字符串中找不到空格，则整个字符串必须是一个单词，因此应返回整个字符串。

让我们通过不使用切片来编写此函数的签名，以了解切片将解决的问题：
![[Pasted image 20240509155412.png]]

`first_word` 函数有一个 `&String` 作为参数。我们不想要所有权，所以这很好。但是我们应该返回什么？我们实际上没有办法谈论字符串的一部分。但是，我们可以返回单词结束的索引，由空格表示。让我们尝试一下，如清单 4-7 所示。
![[Pasted image 20240509155436.png]]
因为我们需要逐个遍历 `String` 元素并检查值是否为空格，所以我们将使用 `as_bytes` 方法将我们的 `String` 转换为字节数组。

![[Pasted image 20240509155458.png]]
接下来，我们使用 `iter` 方法在字节数组上创建一个迭代器：
![[Pasted image 20240509155515.png]]
我们将在第 13 章更详细地讨论迭代器。现在，知道 `iter` 是一个方法，它返回集合中的每个元素， `enumerate` 包装 `iter` 的结果，并将每个元素作为元组的一部分返回。从 `enumerate` 返回的元组的第一个元素是索引，第二个元素是元素的引用。这比我们自己计算索引要方便一些。

因为 `enumerate` 方法返回一个元组，我们可以使用模式来解构该元组。我们将在第 6 章更多地讨论模式。在 `for` 循环中，我们指定一个模式，该模式在元组中具有 `i` 索引和 `&item` 单字节。因为我们从 `.iter().enumerate()` 获取元素的引用，所以在模式中使用 `&` 。

在 `for` 循环中，我们使用字节文字语法搜索表示空格的字节。如果找到空格，我们返回位置。否则，我们使用 `s.len()` 返回字符串的长度。

我们现在有一种方法可以找出字符串中第一个单词的末尾索引，但是有一个问题。我们只返回一个 `usize` ，但在 `&String` 的上下文中才是一个有意义的数字。换句话说，因为它是一个独立于 `String` 的值，所以不能保证它在将来仍然有效。考虑使用列表 4-7 中的 `first_word` 函数的列表 4-8 中的程序。

![[Pasted image 20240509155712.png]]
该程序编译时没有任何错误，如果在调用 `s.clear()` 后使用 `word` ，也是如此。因为 `word` 与 `s` 的状态没有任何关联， `word` 仍然包含值 `5` 。我们可以使用该值 `5` 与变量 `s` 尝试提取第一个单词，但这将是一个错误，因为自从我们在 `word` 中保存 `5` 以来， `s` 的内容已经改变。

必须担心 `word` 中的索引与 `s` 中的数据不同步是繁琐且容易出错的！如果编写 `second_word` 函数，管理这些索引将变得更加脆弱。其签名必须如下所示：
![[Pasted image 20240509155739.png]]
现在我们正在跟踪起始索引和结束索引，并且有更多的值是从特定状态中的数据计算出来的，但与该状态没有任何关联。我们有三个无关的变量漂浮在周围，需要保持同步。

幸运的是，Rust 有一个解决这个问题的方法：字符串切片。

### [字符串切片](https://doc.rust-lang.org/book/ch04-03-slices.html#string-slices)

字符串切片是对 `String` 的一部分的引用，它看起来像这样：
![[Pasted image 20240509160514.png]]
与整个 `String` 的引用不同， `hello` 是对 `String` 的一部分的引用，该部分在额外的 `[0..5]` 位中指定。我们使用方括号内的范围指定 `[starting_index..ending_index]` 来创建切片，其中 `starting_index` 是切片中的第一个位置， `ending_index` 比切片中的最后一个位置多一个。在内部，切片数据结构存储切片的起始位置和长度，对应于 `ending_index` 减 `starting_index` 。因此，在 `let world = &s[6..11];` 的情况下， `world` 将是一个包含指向 `s` 索引为 6 的字节的切片，其长度值为 `5` 。
![[Pasted image 20240509160838.png]]
使用 Rust 的 `..` 范围语法，如果要从索引 0 开始，可以在两个句点之前省略值。换句话说，以下两者相等：
![[Pasted image 20240509161000.png]]
同样地，如果您的切片包括 `String` 的最后一个字节，则可以删除尾随的数字。这意味着这些是相等的：
![[Pasted image 20240509161021.png]]
您也可以放弃这两个值，以获取整个字符串的片段。因此，这两者是相等的：
![[Pasted image 20240509161039.png]]
注意：字符串切片范围索引必须出现在有效的 UTF-8 字符边界上。如果您尝试在多字节字符的中间创建字符串切片，您的程序将以错误退出。为了介绍字符串切片，我们在本节中假设仅使用 ASCII；有关 UTF-8 处理的更全面讨论，请参阅第 8 章“使用字符串存储 UTF-8 编码文本”部分。

考虑到所有这些信息，让我们重写 `first_word` 以返回一个切片。表示“字符串切片”的类型写作 `&str`。

![[Pasted image 20240509161118.png]]
我们获取单词结尾的索引方式与在列表 4-7 中相同，即查找第一个空格的出现。当我们找到一个空格时，我们使用字符串的起始和空格的索引作为起始和结束索引返回一个字符串切片。

现在当我们调用 `first_word` 时，我们会得到一个与底层数据相关联的单个值。该值由对切片起始点的引用和切片中元素数量组成。

返回一个切片也适用于 `second_word` 函数：
![[Pasted image 20240509161254.png]]
我们现在有一个简单直接的 API，更难出错，因为编译器会确保对 `String` 的引用保持有效。还记得程序清单 4-8 中的 bug 吗？当我们将索引移到第一个单词的末尾，然后清除字符串，导致我们的索引无效？那段代码在逻辑上是错误的，但没有显示任何立即错误。如果我们继续尝试使用已清空字符串的第一个单词索引，问题将在以后出现。切片使这个 bug 不可能出现，并让我们更早地知道代码存在问题。使用 `first_word` 的切片版本将会抛出编译时错误：
![[Pasted image 20240509161321.png]]
![[Pasted image 20240509161412.png]]
根据借用规则，如果我们有对某物的不可变引用，就不能再获取可变引用。因为 `clear` 需要截断 `String` ，所以它需要获取可变引用。调用 `clear` 后的 `println!` 使用 `word` 中的引用，因此在那一点上不可变引用仍然有效。Rust 不允许同时存在 `clear` 中的可变引用和 `word` 中的不可变引用，因此编译失败。Rust 不仅使我们的 API 更易于使用，还在编译时消除了整个类别的错误！

#### [字符串字面量作为切片](https://doc.rust-lang.org/book/ch04-03-slices.html#string-literals-as-slices)

回想一下我们谈到的字符串字面值存储在二进制中。现在我们了解了切片，我们可以正确理解字符串字面值：
![[Pasted image 20240509161743.png]]
这里的 `s` 类型是 `&str` ：它是指向二进制特定点的切片。这也是为什么字符串字面值是不可变的； `&str` 是一个不可变引用。
#### [字符串切片作为参数](https://doc.rust-lang.org/book/ch04-03-slices.html#string-slices-as-parameters)

知道你可以取字面量和 `String` 值的片段，这让我们对 `first_word` 有了更多的改进，那就是它的签名：
![[Pasted image 20240509161836.png]]
一个更有经验的 Rustacean 会选择在列表 4-9 中显示的签名，因为它允许我们在 `&String` 值和 `&str` 值上使用相同的函数。
![[Pasted image 20240509161859.png]]
如果我们有一个字符串切片，我们可以直接传递它。如果我们有一个 `String` ，我们可以传递一个 `String` 的切片或一个 `String` 的引用。这种灵活性利用了解引用强制转换的特性，这是我们将在第 15 章“函数和方法中的隐式解引用强制转换”部分介绍的功能。

定义一个函数以接受字符串切片而不是 `String` 的引用，使我们的 API 更通用和有用，而不会失去任何功能：
![[Pasted image 20240509162013.png]]

字符串切片，正如你所想象的那样，是特定于字符串的。但也有一种更通用的切片类型。考虑这个数组：
`let a = [1, 2, 3, 4, 5];`

就像我们可能想要引用字符串的一部分一样，我们可能想要引用数组的一部分。我们可以这样做：
![[Pasted image 20240509162110.png]]
这个切片的类型是 `&[i32]` 。它的工作方式与字符串切片相同，通过存储对第一个元素的引用和长度来实现。您将使用这种类型的切片来处理各种其他集合。在第 8 章讨论向量时，我们将详细讨论这些集合。

所有权、借用和切片的概念确保了 Rust 程序在编译时的内存安全。Rust 语言让您像其他系统编程语言一样控制内存使用，但当所有者超出范围时自动清理数据的所有者意味着您无需编写和调试额外代码来获得此控制。

所有权影响 Rust 的许多其他部分的工作方式，因此我们将在本书的其余部分进一步讨论这些概念。让我们继续阅读第 5 章，看看如何将数据片段组合在一个 `struct` 中。

### #3、类型系统与trait

##### 1、结构体
结构体是一种自定义数据类型，允许您打包并命名多个相关值，这些值组成一个有意义的组。如果您熟悉面向对象的语言，那么结构体就像对象的数据属性。在本章中，我们将比较和对比元组与结构体，以便在您已经了解的基础上构建，并演示何时结构体是更好的数据分组方式。

我们将演示如何定义和实例化结构体。我们将讨论如何定义关联函数，特别是称为方法的关联函数，以指定与结构体类型相关联的行为。结构体和枚举（在第 6 章中讨论）是在程序领域中创建新类型的基本组件，以充分利用 Rust 的编译时类型检查。

结构体类似于元组，在“元组类型”部分讨论过，因为两者都包含多个相关值。与元组类似，结构体的各部分可以是不同类型。与元组不同的是，在结构体中，您将为每个数据部分命名，以便清楚地表示值的含义。添加这些名称意味着结构体比元组更灵活：您不必依赖数据的顺序来指定或访问实例的值。

要定义一个结构体，我们输入关键字 `struct` 并命名整个结构体。结构体的名称应描述被组合在一起的数据部分的重要性。然后，在花括号内，我们定义数据部分的名称和类型，我们称之为字段。例如，第 5-1 节显示了一个存储有关用户帐户信息的结构体。

![[Pasted image 20240509163446.png]]
在定义结构体后使用它，我们通过为每个字段指定具体值来创建该结构体的实例。我们通过声明结构体的名称并添加包含键值对的花括号来创建一个实例，其中键是字段的名称，值是我们要存储在这些字段中的数据。我们不必按照在结构体中声明它们的顺序指定字段。换句话说，结构体定义就像类型的通用模板，实例使用特定数据填充该模板以创建类型的值。例如，我们可以声明特定用户，如第 5-2 节所示。
![[Pasted image 20240509163515.png]]
要从结构体中获取特定值，我们使用点表示法。例如，要访问此用户的电子邮件地址，我们使用 `user1.email` 。如果实例是可变的，我们可以通过使用点表示法并分配到特定字段来更改值。图 5-3 显示了如何更改可变 `User` 实例中 `email` 字段中的值。
![[Pasted image 20240509163928.png]]
请注意整个实例必须是可变的；Rust 不允许我们仅标记某些字段为可变的。与任何表达式一样，我们可以在函数体中的最后一个表达式中构造结构体的新实例，以隐式返回该新实例。
清单 5-4 显示了一个 `build_user` 函数，该函数返回一个具有给定电子邮件和用户名的 `User` 实例。 `active` 字段获取 `true` 的值， `sign_in_count` 获取 `1` 的值。

![[Pasted image 20240509164006.png]]
将函数参数命名为与结构字段相同的名称是有道理的，但不得不重复 `email` 和 `username` 字段名称和变量有点乏味。如果结构体有更多字段，重复每个名称会变得更加恼人。幸运的是，有一个方便的简写方式！
![[Pasted image 20240509164347.png]]
### [使用结构更新语法从其他实例创建实例](https://doc.rust-lang.org/book/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax)

通常情况下，创建一个包含另一个实例大部分数值但有所改变的结构体新实例是很有用的。您可以使用结构体更新语法来实现这一点。

首先，在列表 5-6 中，我们展示了如何在 `user2` 中定期创建一个新的 `User` 实例，而不使用更新语法。我们为 `email` 设置了一个新值，但除此之外，我们使用了在列表 5-2 中创建的 `user1` 相同的值。

![[Pasted image 20240509223943.png]]

使用结构更新语法，我们可以用更少的代码实现相同的效果，如清单 5-7 所示。语法 `..` 指定未明确设置的其余字段应具有与给定实例中的字段相同的值。

![[Pasted image 20240509224024.png]]

在列表 5-7 中的代码还创建了一个实例，该实例在 `user2` 中具有不同的 `email` 值，但与 `user1` 中的 `username` 、 `active` 和 `sign_in_count` 字段具有相同的值。 `..user1` 必须放在最后，以指定任何剩余字段应从 `user1` 中的相应字段获取其值，但我们可以选择以任何顺序为尽可能多的字段指定值，而不考虑结构定义中字段的顺序。

请注意，结构体更新语法使用 `=` 类似于赋值；这是因为它移动数据，就像我们在“变量和数据与移动交互”部分看到的那样。在这个例子中，创建 `user2` 后，我们不能再将 `user1` 作为整体使用，因为 `user1` 字段中的 `String` 已经移动到 `user2` 中。如果我们为 `user2` 和 `username` 分别给出了新的 `String` 值，并且只使用了 `user1` 中的 `active` 和 `sign_in_count` 值，那么在创建 `user2` 后， `user1` 仍然有效。 `active` 和 `sign_in_count` 都是实现了 `Copy` 特质的类型，因此我们在“仅限堆栈数据：复制”部分讨论的行为将适用。

### [使用没有命名字段的元组结构创建不同类型](https://doc.rust-lang.org/book/ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types)

Rust 还支持类似于元组的结构体，称为元组结构体。元组结构体具有结构体名称提供的附加含义，但不具有与字段关联的名称；相反，它们只具有字段的类型。当您想要为整个元组命名并使元组成为与其他元组不同类型时，以及在常规结构体中为每个字段命名会显得冗长或多余时，元组结构体是有用的。

要定义一个元组结构体，首先使用 `struct` 关键字，然后是结构体名称，后面跟着元组中的类型。例如，这里我们定义并使用了两个元组结构体，分别命名为 `Color` 和 `Point` ：
![[Pasted image 20240509224340.png]]
请注意， `black` 和 `origin` 的值是不同类型的，因为它们是不同元组结构的实例。您定义的每个结构体都是自己的类型，即使结构体内的字段可能具有相同的类型。例如，一个接受类型为 `Color` 的参数的函数不能接受 `Point` 作为参数，即使这两种类型都由三个 `i32` 值组成。否则，元组结构的实例与元组类似，您可以将它们解构为各个部分，并且您可以使用 `.` 后跟索引来访问单个值。
### [没有任何字段的单元结构](https://doc.rust-lang.org/book/ch05-01-defining-structs.html#unit-like-structs-without-any-fields)

您还可以定义没有任何字段的结构体！这些被称为类似单元的结构体，因为它们的行为类似于 `()` ，我们在“元组类型”部分提到的单元类型。当您需要在某种类型上实现一个特质但又没有任何要存储在类型本身中的数据时，类似单元的结构体会很有用。我们将在第 10 章讨论特质。这里是声明和实例化一个名为 `AlwaysEqual` 的单元结构体的示例：
![[Pasted image 20240509224503.png]]

为了定义 `AlwaysEqual` ，我们使用 `struct` 关键字，我们想要的名称，然后是一个分号。不需要花括号或括号！然后我们可以以类似的方式在 `subject` 变量中获取 `AlwaysEqual` 的实例：使用我们定义的名称，不带任何花括号或括号。想象一下，稍后我们将为这种类型实现行为，使得每个 `AlwaysEqual` 的实例始终等于任何其他类型的实例，也许是为了测试目的而获得已知结果。我们不需要任何数据来实现这种行为！您将在第 10 章中看到如何定义特征并将其实现在任何类型上，包括类似单元的结构。

在清单 5-1 中的 `User` 结构定义中，我们使用了拥有的 `String` 类型，而不是 `&str` 字符串切片类型。这是一个有意为之的选择，因为我们希望这个结构的每个实例都拥有其所有数据，并且这些数据在整个结构有效时都是有效的。

结构体也可以存储对其他所有者拥有的数据的引用，但这需要使用生命周期，这是 Rust 的一个特性，我们将在第 10 章中讨论。生命周期确保结构体引用的数据在结构体存在期间是有效的。假设您尝试在结构体中存储一个引用而没有指定生命周期，就像下面这样；这是行不通的：

![[Pasted image 20240509225031.png]]
编译器会抱怨它需要生命周期标识符：
![[Pasted image 20240509225108.png]]

在第 10 章，我们将讨论如何修复这些错误，以便您可以在结构体中存储引用，但目前，我们将使用拥有类型（如 `String` ）而不是引用（如 `&str` ）来修复这些错误。

要了解何时需要使用结构体，让我们编写一个计算矩形面积的程序。我们将从使用单个变量开始，然后重构程序，直到我们改为使用结构体。

让我们使用 Cargo 创建一个名为 rectangles 的新二进制项目，该项目将获取以像素为单位指定的矩形的宽度和高度，并计算矩形的面积。清单 5-8 显示了一个简短的程序，展示了在项目的 src/main.rs 中以一种方式完成这一任务。

![[Pasted image 20240509225208.png]]
这段代码通过调用 `area` 函数来计算矩形的面积，但我们可以做更多的工作来使这段代码更清晰易读。

fn area(width: u32, height: u32) -> u32 {

`area` 函数应该计算一个矩形的面积，但我们编写的函数有两个参数，在我们的程序中并没有清楚地表明这两个参数是相关的。将宽度和高度组合在一起会更易读和更易管理。我们已经讨论过一种可能的方法，在第 3 章“元组类型”部分中：使用元组。

### [使用元组重构](https://doc.rust-lang.org/book/ch05-02-example-structs.html#refactoring-with-tuples)

![[Pasted image 20240509225329.png]]

在某种程度上，这个程序更好了。元组让我们添加了一点结构，现在我们只传递了一个参数。但在另一方面，这个版本不太清晰：元组没有为它们的元素命名，所以我们必须索引元组的各个部分，使我们的计算不太明显。

混淆宽度和高度对于面积计算并不重要，但如果我们想在屏幕上绘制矩形，那就很重要！我们必须记住 `width` 是元组索引 `0` ， `height` 是元组索引 `1` 。如果其他人要使用我们的代码，要想弄清楚并记住这一点会更加困难。因为我们在代码中没有传达数据的含义，所以现在更容易引入错误。

### [使用结构重构：添加更多含义](https://doc.rust-lang.org/book/ch05-02-example-structs.html#refactoring-with-structs-adding-more-meaning)

我们使用结构体通过为数据加标签来赋予意义。我们可以将正在使用的元组转换为一个具有整体名称和部分名称的结构体，如清单 5-10 所示。

![[Pasted image 20240509225446.png]]

在这里，我们定义了一个结构体并命名为 `Rectangle` 。在花括号内，我们将字段定义为 `width` 和 `height` ，它们的类型都是 `u32` 。然后，在 `main` 中，我们创建了一个特定实例 `Rectangle` ，宽度为 `30` ，高度为 `50` 。

我们的 `area` 函数现在使用一个参数进行定义，我们将其命名为 `rectangle` ，其类型为不可变借用的 `Rectangle` 结构体实例。正如第 4 章中所提到的，我们希望借用结构体而不是拥有它。这样， `main` 保留了它的所有权，并且可以继续使用 `rect1` ，这也是我们在函数签名和调用函数的地方使用 `&` 的原因。

`area` 函数访问 `Rectangle` 实例的 `width` 和 `height` 字段（请注意，访问借用的结构体实例的字段不会移动字段值，这就是为什么经常看到结构体的借用）。我们现在对 `area` 的函数签名准确地表达了我们的意思：计算 `Rectangle` 的面积，使用其 `width` 和 `height` 字段。这表明宽度和高度彼此相关，并为值提供了描述性名称，而不是使用 `0` 和 `1` 的元组索引值。这对于清晰度是一个胜利。

### [使用派生特性添加有用功能](https://doc.rust-lang.org/book/ch05-02-example-structs.html#adding-useful-functionality-with-derived-traits)

在我们调试程序时，能够打印 `Rectangle` 的一个实例并查看其所有字段的值将会很有用。在尝试使用我们在之前章节中使用过的 `println!` 宏的清单 5-11 中，这种方法不起作用。

![[Pasted image 20240509225613.png]]

当我们编译这段代码时，会出现一个错误，错误信息如下：

error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`

`println!` 宏可以执行多种格式化操作，默认情况下，花括号告诉 `println!` 使用称为 `Display` 的格式化：用于直接最终用户消费的输出。到目前为止，我们看到的原始类型默认实现了 `Display` ，因为只有一种方式可以向用户显示 `1` 或其他任何原始类型。但是对于结构体， `println!` 应该如何格式化输出就不那么清晰了，因为有更多的显示可能性：您想要逗号还是不要？您想要打印花括号吗？所有字段都应该显示吗？由于这种模棱两可，Rust 不会尝试猜测我们想要什么，结构体没有提供 `Display` 的实现，供 `println!` 和 `{}` 占位符使用。

如果我们继续阅读错误，我们会发现这个有用的提示：
= help: the trait `std::fmt::Display` is not implemented for `Rectangle` = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead

让我们试试看！现在， `println!` 宏调用将会变成 `println!("rect1 is {:?}", rect1);` 。将占位符 `:?` 放在花括号内告诉 `println!` 我们想要使用一个名为 `Debug` 的输出格式。 `Debug` 特性使我们能够以对开发人员有用的方式打印出我们的结构体，这样我们在调试代码时可以看到它的值。

用这个更改编译代码。该死！我们仍然遇到错误：

error[E0277]: `Rectangle` doesn't implement `Debug`

但是，编译器再次给了我们一个有用的提示：

= help: the trait `Debug` is not implemented for `Rectangle` = note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`

Rust 确实包含打印调试信息的功能，但我们必须明确选择使该功能对我们的结构体可用。为此，我们在结构体定义之前添加外部属性 `#[derive(Debug)]` ，如清单 5-12 所示。
![[Pasted image 20240509225840.png]]
现在当我们运行程序时，不会出现任何错误，我们会看到以下输出：

![[Pasted image 20240509225957.png]]

不错！输出结果可能不是最漂亮的，但它显示了此实例所有字段的值，这在调试过程中肯定会有所帮助。当我们有更大的结构体时，有一个更容易阅读的输出是很有用的；在这种情况下，我们可以在字符串 `println!` 中使用 `{:#?}` 而不是 `{:?}` 。在这个例子中，使用 `{:#?}` 风格将输出以下内容：

![[Pasted image 20240509230023.png]]
使用 `Debug` 格式打印值的另一种方法是使用 `dbg!` 宏，该宏获取表达式的所有权（与 `println!` 相反，它获取引用），打印出 `dbg!` 宏调用在代码中发生的文件和行号以及该表达式的结果值，并返回该值的所有权。

注意：调用 `dbg!` 宏会打印到标准错误控制台流（ `stderr` ），而不是打印到标准输出控制台流（ `stdout` ）。我们将在第 12 章“将错误消息写入标准错误而不是标准输出”部分更多地讨论 `stderr` 和 `stdout` 。

这是一个例子，我们对分配给 `width` 字段的值感兴趣，以及整个结构体在 `rect1` 中的值：
![[Pasted image 20240509230118.png]]

我们可以在表达式 `30 * scale` 周围放置 `dbg!` ，因为 `dbg!` 返回表达式值的所有权，所以 `width` 字段将获得与我们没有 `dbg!` 调用时相同的值。我们不希望 `dbg!` 获取 `rect1` 的所有权，因此在下一个调用中使用 `rect1` 的引用。这个示例的输出如下：

![[Pasted image 20240509230203.png]]

我们可以看到第一部分输出来自 src/main.rs 的第 10 行，我们正在调试表达式 `30 * scale` ，其结果值为 `60` （整数的 `Debug` 格式化实现只打印它们的值）。src/main.rs 的第 14 行上的 `dbg!` 调用输出 `&rect1` 的值，这是 `Rectangle` 结构体。此输出使用 `Rectangle` 类型的漂亮 `Debug` 格式化。当您试图弄清楚代码在做什么时， `dbg!` 宏可能非常有帮助！

除了 `Debug` 特性外，Rust 还为我们提供了许多特性，可以与 `derive` 属性一起使用，为我们的自定义类型添加有用的行为。这些特性及其行为在附录 C 中列出。我们将在第 10 章中介绍如何实现这些特性以及如何创建自己的特性。除了 `derive` 之外，还有许多其他属性；有关更多信息，请参阅 Rust 参考手册中的“属性”部分。

我们的 `area` 函数非常具体：它只计算矩形的面积。将这种行为与我们的 `Rectangle` 结构更紧密地联系在一起会很有帮助，因为它不适用于任何其他类型。让我们看看如何通过将 `area` 函数转换为定义在我们的 `Rectangle` 类型上的 `area` 方法来继续重构这段代码。

方法类似于函数：我们使用 `fn` 关键字和名称声明它们，它们可以有参数和返回值，并且它们包含一些代码，当方法从其他地方调用时运行。与函数不同，方法是在结构体的上下文中定义的（或者在第 6 章和第 17 章中分别介绍的枚举或特质对象中），它们的第一个参数始终是 `self` ，表示方法被调用的结构体实例。

让我们修改具有 `Rectangle` 实例作为参数的 `area` 函数，而是在 `Rectangle` 结构体上定义一个 `area` 方法，如清单 5-13 所示。

![[Pasted image 20240509230545.png]]

在 `Rectangle` 的上下文中定义函数，我们为 `Rectangle` 启动一个 `impl` （实现）块。该 `impl` 块中的所有内容将与 `Rectangle` 类型相关联。然后，我们将 `area` 函数移至 `impl` 花括号内，并将签名中的第一个参数（在这种情况下是唯一的参数）更改为 `self` ，并在整个主体中使用。在 `main` 中，我们调用 `area` 函数并将 `rect1` 作为参数传递时，我们可以改用方法语法在 `Rectangle` 实例上调用 `area` 方法。方法语法在实例之后进行：我们添加一个点，然后是方法名称、括号和任何参数。

在 `area` 的签名中，我们使用 `&self` 而不是 `rectangle: &Rectangle` 。 `&self` 实际上是 `self: &Self` 的缩写。在 `impl` 块中，类型 `Self` 是 `impl` 块所用类型的别名。方法必须有一个名为 `self` 且类型为 `Self` 的参数作为它们的第一个参数，因此 Rust 允许您在第一个参数位置上仅使用名称 `self` 来缩写。请注意，我们仍然需要在 `self` 缩写前面使用 `&` 来指示该方法借用 `Self` 实例，就像我们在 `rectangle: &Rectangle` 中所做的那样。方法可以获取 `self` 的所有权，以不可变方式借用 `self` ，就像我们在这里所做的那样，或者以可变方式借用 `self` ，就像它们可以处理任何其他参数一样。

出于与函数版本中使用 `&Rectangle` 相同的原因，我们在这里选择了 `&self` ：我们不想拥有它，只想读取结构中的数据，而不是写入它。如果我们想要更改作为方法一部分调用的实例，我们将使用 `&mut self` 作为第一个参数。仅使用 `self` 作为第一个参数获取实例所有权的方法很少见；通常在方法将 `self` 转换为其他内容并希望在转换后阻止调用者使用原始实例时使用此技术。

使用方法而不是函数的主要原因，除了提供方法语法并且不必在每个方法的签名中重复 `self` 的类型之外，还有组织性。我们将可以对类型实例执行的所有操作放在一个 `impl` 块中，而不是让我们代码的未来用户在我们提供的库的各个地方搜索 `Rectangle` 的功能。

请注意，我们可以选择将方法命名为结构体字段之一相同的名称。例如，我们可以在 `Rectangle` 上定义一个也被命名为 `width` 的方法：

![[Pasted image 20240509230730.png]]
在这里，我们选择使 `width` 方法返回 `true` ，如果实例的 `width` 字段中的值大于 `0` ，并且如果值为 `0` ，则返回 `false` ：我们可以为任何目的在同名方法中使用字段。在 `main` 中，当我们在 `rect1.width` 后面加上括号时，Rust 知道我们指的是方法 `width` 。当我们不使用括号时，Rust 知道我们指的是字段 `width` 。

通常，但并非总是，当我们给一个方法取与字段相同的名称时，我们希望它只返回字段中的值，而不做其他操作。这样的方法称为 getter，Rust 不像其他一些语言那样自动为结构字段实现它们。Getter 很有用，因为您可以将字段设为私有，但将方法设为公共，从而在类型的公共 API 中启用对该字段的只读访问。我们将在第 7 章讨论公共和私有是什么，以及如何将字段或方法指定为公共或私有。

在 C 和 C++中，调用方法时使用两种不同的运算符：如果直接在对象上调用方法，则使用 `.` ；如果在对象的指针上调用方法并且需要先解引用指针，则使用 `->` 。换句话说，如果 `object` 是一个指针，那么 `object->something()` 类似于 `(*object).something()` 。

Rust 没有等同于 `->` 运算符的功能；相反，Rust 有一个称为自动引用和解引用的特性。在 Rust 中，调用方法是少数具有这种行为的地方之一。

这是它的工作原理：当您使用 `object.something()` 调用一个方法时，Rust 会自动添加 `&` 、 `&mut` 或 `*` ，以使 `object` 与方法的签名匹配。换句话说，以下内容是相同的：
![[Pasted image 20240509232740.png]]

第一个看起来干净多了。这种自动引用行为之所以有效，是因为方法有一个明确的接收者—— `self` 的类型。给定方法的接收者和名称，Rust 可以明确地确定该方法是读取（ `&self` ）、变异（ `&mut self` ）还是消耗（ `self` ）。Rust 使得方法接收者的借用隐式化，这是实际中使所有权使用起来更加方便的重要部分。

### [具有更多参数的方法](https://doc.rust-lang.org/book/ch05-03-method-syntax.html#methods-with-more-parameters)

让我们通过在 `Rectangle` 结构上实现第二个方法来练习使用方法。这次，我们希望 `Rectangle` 的一个实例接受另一个 `Rectangle` 的实例，并在第二个 `Rectangle` 完全适合 `self` （第一个 `Rectangle` ）时返回 `true` ；否则，它应该返回 `false` 。也就是说，一旦我们定义了 `can_hold` 方法，我们希望能够编写列表 5-14 中显示的程序。
![[Pasted image 20240509233143.png]]
由于 `rect2` 的两个维度均小于 `rect1` 的维度，所以预期的输出将如下所示，但 `rect3` 比 `rect1` 更宽：
Can rect1 hold rect2? true 
Can rect1 hold rect3? false

我们知道我们想要定义一个方法，所以它将在 `impl Rectangle` 块内。方法名将是 `can_hold` ，它将以另一个 `Rectangle` 的不可变借用作为参数。我们可以通过查看调用方法的代码来确定参数的类型： `rect1.can_hold(&rect2)` 传入 `&rect2` ，这是对 `rect2` 的不可变借用， `Rectangle` 的一个实例。这是有道理的，因为我们只需要读取 `rect2` （而不是写入，这意味着我们需要一个可变借用），我们希望 `main` 保留对 `rect2` 的所有权，这样我们在调用 `can_hold` 方法后可以再次使用它。 `can_hold` 的返回值将是一个布尔值，实现将检查 `self` 的宽度和高度是否分别大于另一个 `Rectangle` 的宽度和高度。让我们将新的 `can_hold` 方法添加到列表 5-13 中的 `impl` 块中，如列表 5-15 所示。
### #4、突破抽象范式
### #5、unsafe #rust
