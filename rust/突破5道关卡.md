###  #1、所有权机制
在不需要垃圾收集器的情况下提供内存安全性保证，因此了解所有权的工作原理非常重要。

>借用

> 切片

> rust如何在内存中布局

所有权是一组规则，用于指导rust程序如何管理内存。所有程序在运行时都必须管理它们使用计算机内存的方式。一些语言具有垃圾回收机制，会定期查找程序运行时不再使用的内存。而在其他语言中，程序员必须显示的分配和释放内存。rust使用第三种方法，通过一套所有权规则管理内存，编译器会检查这些规则。如果违反任何规则，程序将无法编译。所有权的任何特性都不会在程序运行时减慢程序的运行速度。

许多编程语言不需要您经常考虑栈和堆。但在像 Rust 这样的系统编程语言中，值是存储在栈上还是堆上会影响语言的行为，以及为什么您必须做出某些决策。本章后面将描述与栈和堆相关的所有权部分，因此在此之前，这里是一个简要的准备说明。

栈和堆都是您的代码在运行时可以使用的内存部分，但它们的结构方式不同。栈按照获取值的顺序存储值，并以相反的顺序移除值。这被称为后进先出。想象一下一叠盘子：当您添加更多盘子时，您将它们放在堆叠的顶部，当您需要一只盘子时，您从顶部取走一只。从中间或底部添加或移除盘子不会那么有效！添加数据称为推入栈，移除数据称为弹出栈。存储在栈上的所有数据必须具有已知的固定大小。在编译时大小未知或大小可能会更改的数据必须存储在堆上。

堆的组织性较差：当您将数据放入堆时，您请求一定量的空间。内存分配器在堆中找到一个足够大的空位，标记为正在使用，并返回一个指针，即该位置的地址。这个过程称为在堆上分配，有时简称为分配（将值推送到堆栈上不被视为分配）。由于堆的指针是已知的固定大小，您可以将指针存储在堆栈上，但当您需要实际数据时，必须跟随指针。想象一下在餐厅就座。当您进入时，告知您组里的人数，主人找到一个适合所有人的空桌并带您过去。如果您组里有人迟到，他们可以询问您就座的位置以找到您。

将数据推送到堆栈比在堆上分配更快，因为分配器永远不必搜索存储新数据的位置；该位置始终位于堆栈顶部。相比之下，在堆上分配空间需要更多工作，因为分配器必须首先找到足够大的空间来容纳数据，然后执行簿记以准备下一次分配。

在堆中访问数据比在栈中访问数据慢，因为你必须跟随指针才能到达那里。当代处理器在内存中跳跃较少时速度更快。延续这个类比，考虑一家餐厅的服务器从许多桌子上接订单。在转移到下一桌之前，最有效的方法是先获取一桌的所有订单。先从 A 桌接订单，然后从 B 桌接订单，再从 A 桌接订单，然后再从 B 桌接订单会是一个更慢的过程。同样地，处理器可以更好地完成工作，如果它处理的数据靠近其他数据（就像在栈上）而不是远离（就像在堆上）。

当您的代码调用一个函数时，传递给函数的值（包括可能指向堆上数据的指针）和函数的局部变量被推送到堆栈上。当函数结束时，这些值会从堆栈中弹出。

跟踪代码的哪些部分正在使用堆上的数据，最小化堆上重复数据的数量，并清理未使用的堆数据，以免空间不足，这些都是所有权解决的问题。一旦理解了所有权，你就不需要经常考虑栈和堆，但知道所有权的主要目的是管理堆数据可以帮助解释它为什么以这种方式工作。

----------------------------------------------------
所有权规则
一、Rust 中的每个值都有一个所有者。
二、一次只能有一个所有者。
三、当所有者超出范围时，该值将被丢弃。

作为所有权的第一个示例，我们将看一下一些变量的范围。范围是程序中项目有效的范围。拿以下变量为例：

`let s = "hello";`

变量 `s` 指的是一个字符串字面量，其中字符串的值是硬编码到我们程序的文本中的。该变量从声明的点开始有效，直到当前作用域的结束。图 4-1 显示了一个程序，其中有注释标注变量 `s` 的有效范围。
    {                      // s is not valid here, it’s not yet declared
        let s = "hello";   // s is valid from this point forward

        // do stuff with s
    }                      // this scope is now over, and s is no longer valid

当 `s` 进入范围时，它是有效的。
它在超出范围之前仍然有效。

在这一点上，作用域和变量有效的时间之间的关系类似于其他编程语言中的情况。现在我们将在这种理解的基础上介绍 `String` 类型。

为了说明所有权规则，我们需要一种比我们在第 3 章“数据类型”部分中涵盖的更复杂的数据类型。之前涵盖的类型是已知大小的，可以存储在堆栈上，并在其作用域结束时从堆栈中弹出，并且可以快速且轻松地复制以创建一个新的、独立的实例，如果代码的另一部分需要在不同的作用域中使用相同的值。但我们想要查看存储在堆上的数据，并探讨 Rust 如何知道何时清理这些数据， `String` 类型是一个很好的例子。

我们将集中讨论与所有权相关的 `String` 部分。这些方面也适用于其他复杂数据类型，无论是由标准库提供还是由您创建。我们将在第 8 章更深入地讨论 `String` 。

我们已经看到了字符串字面量，其中字符串值是硬编码到我们的程序中的。字符串字面量很方便，但并不适用于我们可能希望使用文本的每种情况。一个原因是它们是不可变的。另一个原因是，当我们编写代码时，并不是每个字符串值都是已知的：例如，如果我们想要接受用户输入并存储它会怎样？对于这些情况，Rust 有第二种字符串类型， `String` 。这种类型管理在堆上分配的数据，因此能够存储我们在编译时不知道的文本量。您可以使用 `from` 函数从字符串字面量创建一个 `String` ，就像这样：

`let s = String::from("hello");`

双冒号 `::` 运算符允许我们将这个特定的 `from` 函数命名空间化到 `String` 类型下，而不是使用类似 `string_from` 的名称。我们将在第 5 章的“方法语法”部分更详细地讨论这种语法，以及在第 7 章的“模块中项目引用路径”中讨论使用模块进行命名空间化。

这种字符串可以被改变：

那么，这里有什么区别呢？为什么 `String` 可以被改变，但字面值不能呢？区别在于这两种类型处理内存的方式。

在字符串字面值的情况下，我们在编译时知道内容，因此文本直接硬编码到最终可执行文件中。这就是为什么字符串字面值快速高效的原因。但这些特性只来自于字符串字面值的不可变性。不幸的是，我们无法为每个在编译时大小未知且在运行程序时可能会更改大小的文本块放入二进制文件中。

使用 `String` 类型，为了支持一个可变的、可增长的文本片段，我们需要在堆上分配一定数量的内存，编译时未知，以容纳内容。这意味着：
一、内存必须在运行时从内存分配器请求。
二、当我们完成 `String` 后，我们需要一种将这些内存返回给分配器的方法。

第一部分由我们完成：当我们调用 `String::from` 时，其实现会请求所需的内存。这在编程语言中几乎是普遍的。

然而，第二部分是不同的。在具有垃圾收集器（GC）的语言中，GC 会跟踪和清理不再使用的内存，我们不需要考虑这一点。在大多数没有 GC 的语言中，我们有责任识别何时不再使用内存，并调用代码显式释放它，就像我们请求它一样。正确地执行这一点在历史上一直是一个困难的编程问题。如果我们忘记了，我们会浪费内存。如果我们太早这样做，我们会有一个无效的变量。如果我们这样做两次，那也是一个错误。我们需要精确地将一个 `allocate` 与一个 `free` 配对。

rust采取了一种不同的路径：一旦拥有它的变量超出范围，内存就会自动返回。这是我们在列表 4-1 中使用 `String` 而不是字符串文字的作用域示例的一个版本：

    {
        let s = String::from("hello"); // s is valid from this point forward

        // do stuff with s
    }                                  // this scope is now over, and s is no
                                       // longer valid

当 `s` 超出范围时，我们可以在自然点将 `String` 需要的内存返回给分配器。当变量超出范围时，Rust 会为我们调用一个特殊函数。这个函数被称为 `drop` ，作者可以在其中放置返回内存的代码。Rust 会在闭合大括号处自动调用 `drop`.

这种模式对 Rust 代码的编写方式产生了深远影响。现在看起来可能很简单，但当我们想要让多个变量使用我们在堆上分配的数据时，在更复杂的情况下，代码的行为可能会出乎意料。让我们现在探讨一些这些情况。

#### [变量和数据与移动交互](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#variables-and-data-interacting-with-move)

    let x = 5;
    let y = x;
我们可能猜到这是在做什么：“将值 `5` 绑定到 `x` ；然后复制 `x` 中的值并绑定到 `y` 。”现在我们有两个变量， `x` 和 `y` ，两者都等于 `5` 。这确实是正在发生的事情，因为整数是已知固定大小的简单值，并且这两个 `5` 值被推送到堆栈上。

    let s1 = String::from("hello");
    let s2 = s1;

这看起来非常相似，因此我们可能会假设它的工作方式是相同的：也就是说，第二行会复制 `s1` 中的值并将其绑定到 `s2` 。但实际情况并非完全如此。
看看 `String` 在底层发生了什么。一个 `String` 由三部分组成，如左侧所示：指向保存字符串内容的内存的指针，长度和容量。这组数据存储在堆栈上。右侧是保存内容的堆上的内存。
![[Pasted image 20240509151230.png]]
长度是 `String` 内容当前使用的内存量（以字节为单位）。容量是 `String` 从分配器接收的总内存量（以字节为单位）。长度和容量之间的差异很重要，但在这种情况下并不重要，所以现在可以忽略容量。

当我们将 `s1` 分配给 `s2` 时， `String` 数据被复制，意味着我们复制了在堆栈上的指针、长度和容量。我们没有复制指针所指向的堆上的数据。换句话说，内存中的数据表示如图 4-2 所示。

![[Pasted image 20240509151402.png]]
如果 Rust 复制堆数据，内存看起来会是什么样子。如果 Rust 这样做了，如果堆上的数据很大，操作 `s2 = s1` 在运行时性能方面可能会非常昂贵。
![[Pasted image 20240509151450.png]]
当一个变量超出作用域时，Rust 会自动调用 `drop` 函数并清理该变量的堆内存。但图 4-2 显示两个数据指针指向同一位置。这是一个问题：当 `s2` 和 `s1` 超出作用域时，它们都会尝试释放相同的内存。这被称为双重释放错误，是我们之前提到的内存安全错误之一。释放内存两次可能导致内存损坏，进而可能导致安全漏洞。

为了确保内存安全，在 `let s2 = s1;` 之后，Rust 认为 `s1` 不再有效。因此，当 `s1` 超出范围时，Rust 不需要释放任何内容。看看当你尝试在创建 `s2` 之后使用 `s1` 时会发生什么；它不会起作用：
    let s1 = String::from("hello");
    let s2 = s1;

    println!("{}, world!", s1);
由于 Rust 阻止您使用无效的引用，您会收到这样的错误。
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:5:28
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{}, world!", s1);
  |                            ^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
  |
3 |     let s2 = s1.clone();
  |                ++++++++

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error

如果您在使用其他语言时听过浅拷贝和深拷贝这两个术语，那么在不拷贝数据的情况下拷贝指针、长度和容量的概念可能听起来像是在进行浅拷贝。但是因为 Rust 还会使第一个变量无效，所以不叫浅拷贝，而是称为移动。在这个例子中，我们会说 `s1` 被移动到 `s2`。
![[Pasted image 20240509151642.png]]
这解决了我们的问题！只有 `s2` 有效，当它超出范围时，它将自行释放内存，我们就完成了。
这暗示了一个设计选择：Rust 永远不会自动创建您的数据的“深”副本。因此，可以假定任何自动复制在运行时性能方面都是廉价的。

#### [变量和数据与克隆交互](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#variables-and-data-interacting-with-clone)

如果我们确实想要深度复制 `String` 的堆数据，而不仅仅是栈数据，我们可以使用一种常见的方法称为 `clone` 。我们将在第 5 章讨论方法语法，但由于方法是许多编程语言中的常见特性，您可能以前见过它们。
    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {}, s2 = {}", s1, s2);
当您看到对 `clone` 的调用时，您知道正在执行一些任意代码，并且该代码可能很昂贵。这是一个视觉指示，表明正在发生一些不同的事情。

#### [堆栈数据：复制](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#stack-only-data-copy)

还有一个我们还没有讨论的问题。这个使用整数的代码——其中部分在列表 4-2 中显示——是有效的。

    let x = 5;
    let y = x;

    println!("x = {}, y = {}", x, y);

但是这段代码似乎与我们刚学到的内容相矛盾：我们没有调用 `clone` ，但 `x` 仍然有效，并且没有移动到 `y` 。

原因是在编译时已知大小的整数等类型完全存储在堆栈上，因此实际值的副本制作起来很快。这意味着在创建变量 `y` 后，我们不希望阻止 `x` 有效。换句话说，在这里深复制和浅复制没有区别，因此调用 `clone` 不会产生任何与通常的浅复制不同的效果，我们可以省略它。

rust有一个特殊的注解叫做 `Copy` 特性，我们可以放在存储在堆栈上的类型上，就像整数一样（我们会在第 10 章更多地讨论特性）。如果一个类型实现了 `Copy` 特性，使用它的变量不会移动，而是被简单地复制，使得它们在分配给另一个变量后仍然有效。

如果类型或其任何部分已实现 `Drop` 特性，则rust不会让我们使用 `Copy` 注释类型。如果类型在值超出范围时需要发生特殊情况，并且我们为该类型添加 `Copy` 注释，则会收到编译时错误。要了解如何添加 `Copy` 注释以实现特性，请参阅附录 C 中的“可派生特性”。

那么，哪些类型实现了 `Copy` 特质？您可以查看给定类型的文档以确保，但通常来说，任何一组简单标量值都可以实现 `Copy` ，而任何需要分配或是某种资源形式的内容都不能实现 `Copy` 。以下是一些实现 `Copy` 的类型：

1、所有整数类型，例如 `u32` 。
2、布尔类型， `bool` ，具有值 `true` 和 `false` 。
3、所有的浮点类型，比如 `f64` 。
4、字符类型， `char` 。
5、元组，如果它们只包含也实现 `Copy` 的类型。例如， `(i32, i32)` 实现 `Copy` ，但 `(i32, String)` 不实现。

将值传递给函数的机制与将值分配给变量时类似。将变量传递给函数将移动或复制，就像赋值一样。图 4-3 中有一个示例，其中一些注释显示变量何时进入和退出作用域。
![[Pasted image 20240509153340.png]]
如果我们在调用 `takes_ownership` 之后尝试使用 `s` ，Rust 会抛出编译时错误。这些静态检查可以保护我们免受错误的影响。尝试添加代码到 `main` ，使用 `s` 和 `x` ，看看在哪里可以使用它们，以及所有权规则阻止你这样做的地方。

### [返回值和作用域](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#return-values-and-scope)

返回值也可以转移所有权。图 4-4 显示了一个返回某个值的函数示例，其注释与图 4-3 中的注释类似。
![[Pasted image 20240509153458.png]]

变量的所有权每次都遵循相同的模式：将值分配给另一个变量会移动它。当包含堆上数据的变量超出范围时，该值将由 `drop` 清理，除非数据的所有权已转移到另一个变量。

虽然这样可以运作，但是在每个函数中都要获取所有权然后再归还所有权有点繁琐。如果我们想让一个函数使用一个值但不获取所有权怎么办？如果我们想要再次使用传入的任何东西，除了可能想要返回的函数体产生的任何数据，也需要将其传回，这是相当烦人的。

rust让我们使用元组返回多个值。
![[Pasted image 20240509153617.png]]
但这太过于繁琐，对于一个本应普遍的概念来说，需要做很多工作。幸运的是，Rust 有一个特性，可以使用值而不转移所有权，称为引用。
###  #2、借用和生命周期

在列表 4-5 中的元组代码存在的问题是，我们必须将 `String` 返回给调用函数，这样我们在调用 `calculate_length` 后仍然可以使用 `String` ，因为 `String` 已经移动到 `calculate_length` 中。相反，我们可以提供对 `String` 值的引用。引用类似于指针，因为它是一个地址，我们可以跟随该地址以访问存储在该地址的数据；该数据由其他变量拥有。与指针不同，引用保证在引用的生命周期内指向特定类型的有效值。

这是您如何定义和使用一个具有对象引用作为参数而不是获取值所有权的 `calculate_length` 函数：
![[Pasted image 20240509153815.png]]
首先，请注意变量声明和函数返回值中的所有元组代码已经消失。其次，请注意我们将 `&s1` 传递给 `calculate_length` ，在其定义中，我们取 `&String` 而不是 `String` 。这些和符号代表引用，它们允许您引用某个值而不获取其所有权。图 4-5 描绘了这个概念。
![[Pasted image 20240509153900.png]]
![[Pasted image 20240509153915.png]]
让我们仔细看一下这里的函数调用：
![[Pasted image 20240509153947.png]]
`&s1` 语法允许我们创建一个引用，该引用指向 `s1` 的值，但并不拥有它。因为它不拥有该值，所以当引用停止使用时，它指向的值不会被丢弃。
同样，函数的签名使用 `&` 来表示参数 `s` 的类型是一个引用。

变量 `s` 有效的范围与任何函数参数的范围相同，但引用指向的值在 `s` 停止使用时不会被丢弃，因为 `s` 没有所有权。当函数的参数是引用而不是实际值时，我们不需要返回值来归还所有权，因为我们从未拥有过所有权。

我们称创建引用的行为为借用。就像在现实生活中，如果一个人拥有某物，你可以向他们借用。借用完毕后，你必须归还。你并不拥有它。

那么，如果我们尝试修改我们借用的东西会发生什么呢？尝试列表 4-6 中的代码。剧透警告：它不起作用！
![[Pasted image 20240509154136.png]]
![[Pasted image 20240509154156.png]]
变量默认是不可变的，引用也是如此。我们不允许修改我们引用的内容。

我们可以通过对清单 4-6 中的代码进行一些小的调整，使用可变引用来允许我们修改一个借用值。

![[Pasted image 20240509154227.png]]
首先我们将 `s` 更改为 `mut` 。然后我们使用 `&mut s` 创建一个可变引用，在其中调用 `change` 函数，并更新函数签名以接受一个带有 `some_string: &mut String` 的可变引用。这样非常清楚地表明 `change` 函数将改变它借用的值。

可变引用有一个重要限制：如果您有一个对值的可变引用，那么您不能有对该值的其他引用。试图创建两个对 `s` 的可变引用的代码将失败：

这个错误表示这段代码无效，因为我们不能同时多次借用 `s` 作为可变的。第一个可变借用在 `r1` 中，并且必须持续到在 `println!` 中使用它之前，但在创建该可变引用和使用它之间，我们尝试在 `r2` 中创建另一个可变引用，它借用与 `r1` 相同的数据。

阻止同时对相同数据进行多个可变引用的限制允许进行变异，但以非常受控的方式进行。这是新的 Rustaceans 会遇到困难的地方，因为大多数语言都允许您随时进行变异。具有此限制的好处是 Rust 可以在编译时防止数据竞争。数据竞争类似于竞争条件，当出现以下三种行为时会发生数据竞争：
1、两个或更多指针同时访问相同数据。
2、至少有一个指针被用于写入数据。
3、没有机制用于同步对数据的访问。

数据竞争会导致未定义的行为，并且在运行时尝试跟踪它们时可能很难诊断和修复；Rust 通过拒绝编译具有数据竞争的代码来防止这个问题！

与往常一样，我们可以使用花括号创建新的作用域，允许多个可变引用，只是不能同时存在。
![[Pasted image 20240509154545.png]]

Rust 对于组合可变引用和不可变引用实施了类似的规则。这段代码会导致错误：
![[Pasted image 20240509154604.png]]
![[Pasted image 20240509154652.png]]
当我们拥有对相同值的不可变引用时，也不能拥有可变引用。

不可变引用的用户不希望值在他们底下突然改变！然而，允许多个不可变引用，因为只是读取数据的人没有能力影响其他人对数据的读取。

请注意，引用的范围从引入引用的地方开始，并持续到最后一次使用该引用。例如，此代码将编译，因为不可变引用的最后使用发生在引入可变引用之前：
![[Pasted image 20240509154724.png]]
不可变引用 `r1` 和 `r2` 的作用域在它们最后使用的 `println!` 结束之后，即在可变引用 `r3` 创建之前。这些作用域不重叠，因此这段代码是允许的：编译器可以确定在作用域结束之前引用不再被使用。

尽管有时候借用错误可能会让人沮丧，但请记住，这是 Rust 编译器在编译时早期指出潜在错误（而不是在运行时），并准确告诉您问题出在哪里。这样，您就不必追踪为什么您的数据不是您所认为的那样。

### [悬空引用](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#dangling-references)

在具有指针的语言中，很容易错误地创建悬空指针——指向内存中可能已经分配给其他人的位置的指针——通过释放一些内存同时保留对该内存的指针。相比之下，在 Rust 中，编译器保证引用永远不会是悬空引用：如果您有对某些数据的引用，编译器将确保在对数据的引用消失之前，数据不会超出范围。

让我们尝试创建一个悬空引用，看看 Rust 如何通过编译时错误来防止它们：

![[Pasted image 20240509154922.png]]

![[Pasted image 20240509154939.png]]

这个错误消息指的是一个我们还没有涉及的特性：生命周期。我们将在第 10 章详细讨论生命周期。但是，如果你忽略了关于生命周期的部分，这条消息确实包含了为什么这段代码有问题的关键：

让我们更仔细地看看我们的 `dangle` 代码在每个阶段到底发生了什么：
![[Pasted image 20240509155016.png]]
因为 `s` 是在 `dangle` 内创建的，当 `dangle` 的代码完成时， `s` 将被释放。但我们尝试返回一个对它的引用。这意味着这个引用将指向一个无效的 `String` 。这样不好！Rust 不会让我们这样做。

这里的解决方案是直接返回 `String` ：
![[Pasted image 20240509155044.png]]

在任何时候，您可以拥有一个可变引用或任意数量的不可变引用。

参考文献必须始终有效。

## [切片类型](https://doc.rust-lang.org/book/ch04-03-slices.html#the-slice-type)不同类型的引用

切片允许您引用集合中的连续元素序列，而不是整个集合。切片是一种引用，因此它没有所有权。
这里有一个小的编程问题：编写一个函数，该函数接受一个由空格分隔的单词字符串，并返回在该字符串中找到的第一个单词。如果函数在字符串中找不到空格，则整个字符串必须是一个单词，因此应返回整个字符串。

让我们通过不使用切片来编写此函数的签名，以了解切片将解决的问题：
![[Pasted image 20240509155412.png]]

`first_word` 函数有一个 `&String` 作为参数。我们不想要所有权，所以这很好。但是我们应该返回什么？我们实际上没有办法谈论字符串的一部分。但是，我们可以返回单词结束的索引，由空格表示。让我们尝试一下，如清单 4-7 所示。
![[Pasted image 20240509155436.png]]
因为我们需要逐个遍历 `String` 元素并检查值是否为空格，所以我们将使用 `as_bytes` 方法将我们的 `String` 转换为字节数组。

![[Pasted image 20240509155458.png]]
接下来，我们使用 `iter` 方法在字节数组上创建一个迭代器：
![[Pasted image 20240509155515.png]]
我们将在第 13 章更详细地讨论迭代器。现在，知道 `iter` 是一个方法，它返回集合中的每个元素， `enumerate` 包装 `iter` 的结果，并将每个元素作为元组的一部分返回。从 `enumerate` 返回的元组的第一个元素是索引，第二个元素是元素的引用。这比我们自己计算索引要方便一些。

因为 `enumerate` 方法返回一个元组，我们可以使用模式来解构该元组。我们将在第 6 章更多地讨论模式。在 `for` 循环中，我们指定一个模式，该模式在元组中具有 `i` 索引和 `&item` 单字节。因为我们从 `.iter().enumerate()` 获取元素的引用，所以在模式中使用 `&` 。

在 `for` 循环中，我们使用字节文字语法搜索表示空格的字节。如果找到空格，我们返回位置。否则，我们使用 `s.len()` 返回字符串的长度。

我们现在有一种方法可以找出字符串中第一个单词的末尾索引，但是有一个问题。我们只返回一个 `usize` ，但在 `&String` 的上下文中才是一个有意义的数字。换句话说，因为它是一个独立于 `String` 的值，所以不能保证它在将来仍然有效。考虑使用列表 4-7 中的 `first_word` 函数的列表 4-8 中的程序。

![[Pasted image 20240509155712.png]]
该程序编译时没有任何错误，如果在调用 `s.clear()` 后使用 `word` ，也是如此。因为 `word` 与 `s` 的状态没有任何关联， `word` 仍然包含值 `5` 。我们可以使用该值 `5` 与变量 `s` 尝试提取第一个单词，但这将是一个错误，因为自从我们在 `word` 中保存 `5` 以来， `s` 的内容已经改变。

必须担心 `word` 中的索引与 `s` 中的数据不同步是繁琐且容易出错的！如果编写 `second_word` 函数，管理这些索引将变得更加脆弱。其签名必须如下所示：
![[Pasted image 20240509155739.png]]
现在我们正在跟踪起始索引和结束索引，并且有更多的值是从特定状态中的数据计算出来的，但与该状态没有任何关联。我们有三个无关的变量漂浮在周围，需要保持同步。

幸运的是，Rust 有一个解决这个问题的方法：字符串切片。

### [字符串切片](https://doc.rust-lang.org/book/ch04-03-slices.html#string-slices)

字符串切片是对 `String` 的一部分的引用，它看起来像这样：
![[Pasted image 20240509160514.png]]
与整个 `String` 的引用不同， `hello` 是对 `String` 的一部分的引用，该部分在额外的 `[0..5]` 位中指定。我们使用方括号内的范围指定 `[starting_index..ending_index]` 来创建切片，其中 `starting_index` 是切片中的第一个位置， `ending_index` 比切片中的最后一个位置多一个。在内部，切片数据结构存储切片的起始位置和长度，对应于 `ending_index` 减 `starting_index` 。因此，在 `let world = &s[6..11];` 的情况下， `world` 将是一个包含指向 `s` 索引为 6 的字节的切片，其长度值为 `5` 。
![[Pasted image 20240509160838.png]]
使用 Rust 的 `..` 范围语法，如果要从索引 0 开始，可以在两个句点之前省略值。换句话说，以下两者相等：
![[Pasted image 20240509161000.png]]
同样地，如果您的切片包括 `String` 的最后一个字节，则可以删除尾随的数字。这意味着这些是相等的：
![[Pasted image 20240509161021.png]]
您也可以放弃这两个值，以获取整个字符串的片段。因此，这两者是相等的：
![[Pasted image 20240509161039.png]]
注意：字符串切片范围索引必须出现在有效的 UTF-8 字符边界上。如果您尝试在多字节字符的中间创建字符串切片，您的程序将以错误退出。为了介绍字符串切片，我们在本节中假设仅使用 ASCII；有关 UTF-8 处理的更全面讨论，请参阅第 8 章“使用字符串存储 UTF-8 编码文本”部分。

考虑到所有这些信息，让我们重写 `first_word` 以返回一个切片。表示“字符串切片”的类型写作 `&str`。

![[Pasted image 20240509161118.png]]
我们获取单词结尾的索引方式与在列表 4-7 中相同，即查找第一个空格的出现。当我们找到一个空格时，我们使用字符串的起始和空格的索引作为起始和结束索引返回一个字符串切片。

现在当我们调用 `first_word` 时，我们会得到一个与底层数据相关联的单个值。该值由对切片起始点的引用和切片中元素数量组成。

返回一个切片也适用于 `second_word` 函数：
![[Pasted image 20240509161254.png]]
我们现在有一个简单直接的 API，更难出错，因为编译器会确保对 `String` 的引用保持有效。还记得程序清单 4-8 中的 bug 吗？当我们将索引移到第一个单词的末尾，然后清除字符串，导致我们的索引无效？那段代码在逻辑上是错误的，但没有显示任何立即错误。如果我们继续尝试使用已清空字符串的第一个单词索引，问题将在以后出现。切片使这个 bug 不可能出现，并让我们更早地知道代码存在问题。使用 `first_word` 的切片版本将会抛出编译时错误：
![[Pasted image 20240509161321.png]]
![[Pasted image 20240509161412.png]]
根据借用规则，如果我们有对某物的不可变引用，就不能再获取可变引用。因为 `clear` 需要截断 `String` ，所以它需要获取可变引用。调用 `clear` 后的 `println!` 使用 `word` 中的引用，因此在那一点上不可变引用仍然有效。Rust 不允许同时存在 `clear` 中的可变引用和 `word` 中的不可变引用，因此编译失败。Rust 不仅使我们的 API 更易于使用，还在编译时消除了整个类别的错误！

#### [字符串字面量作为切片](https://doc.rust-lang.org/book/ch04-03-slices.html#string-literals-as-slices)

回想一下我们谈到的字符串字面值存储在二进制中。现在我们了解了切片，我们可以正确理解字符串字面值：
![[Pasted image 20240509161743.png]]
这里的 `s` 类型是 `&str` ：它是指向二进制特定点的切片。这也是为什么字符串字面值是不可变的； `&str` 是一个不可变引用。
#### [字符串切片作为参数](https://doc.rust-lang.org/book/ch04-03-slices.html#string-slices-as-parameters)

知道你可以取字面量和 `String` 值的片段，这让我们对 `first_word` 有了更多的改进，那就是它的签名：
![[Pasted image 20240509161836.png]]
一个更有经验的 Rustacean 会选择在列表 4-9 中显示的签名，因为它允许我们在 `&String` 值和 `&str` 值上使用相同的函数。
![[Pasted image 20240509161859.png]]
如果我们有一个字符串切片，我们可以直接传递它。如果我们有一个 `String` ，我们可以传递一个 `String` 的切片或一个 `String` 的引用。这种灵活性利用了解引用强制转换的特性，这是我们将在第 15 章“函数和方法中的隐式解引用强制转换”部分介绍的功能。

定义一个函数以接受字符串切片而不是 `String` 的引用，使我们的 API 更通用和有用，而不会失去任何功能：
![[Pasted image 20240509162013.png]]

字符串切片，正如你所想象的那样，是特定于字符串的。但也有一种更通用的切片类型。考虑这个数组：
`let a = [1, 2, 3, 4, 5];`

就像我们可能想要引用字符串的一部分一样，我们可能想要引用数组的一部分。我们可以这样做：
![[Pasted image 20240509162110.png]]
这个切片的类型是 `&[i32]` 。它的工作方式与字符串切片相同，通过存储对第一个元素的引用和长度来实现。您将使用这种类型的切片来处理各种其他集合。在第 8 章讨论向量时，我们将详细讨论这些集合。

所有权、借用和切片的概念确保了 Rust 程序在编译时的内存安全。Rust 语言让您像其他系统编程语言一样控制内存使用，但当所有者超出范围时自动清理数据的所有者意味着您无需编写和调试额外代码来获得此控制。

所有权影响 Rust 的许多其他部分的工作方式，因此我们将在本书的其余部分进一步讨论这些概念。让我们继续阅读第 5 章，看看如何将数据片段组合在一个 `struct` 中。

### #3、类型系统与trait

##### 1、结构体
结构体是一种自定义数据类型，允许您打包并命名多个相关值，这些值组成一个有意义的组。如果您熟悉面向对象的语言，那么结构体就像对象的数据属性。在本章中，我们将比较和对比元组与结构体，以便在您已经了解的基础上构建，并演示何时结构体是更好的数据分组方式。

我们将演示如何定义和实例化结构体。我们将讨论如何定义关联函数，特别是称为方法的关联函数，以指定与结构体类型相关联的行为。结构体和枚举（在第 6 章中讨论）是在程序领域中创建新类型的基本组件，以充分利用 Rust 的编译时类型检查。

结构体类似于元组，在“元组类型”部分讨论过，因为两者都包含多个相关值。与元组类似，结构体的各部分可以是不同类型。与元组不同的是，在结构体中，您将为每个数据部分命名，以便清楚地表示值的含义。添加这些名称意味着结构体比元组更灵活：您不必依赖数据的顺序来指定或访问实例的值。

要定义一个结构体，我们输入关键字 `struct` 并命名整个结构体。结构体的名称应描述被组合在一起的数据部分的重要性。然后，在花括号内，我们定义数据部分的名称和类型，我们称之为字段。例如，第 5-1 节显示了一个存储有关用户帐户信息的结构体。

![[Pasted image 20240509163446.png]]
在定义结构体后使用它，我们通过为每个字段指定具体值来创建该结构体的实例。我们通过声明结构体的名称并添加包含键值对的花括号来创建一个实例，其中键是字段的名称，值是我们要存储在这些字段中的数据。我们不必按照在结构体中声明它们的顺序指定字段。换句话说，结构体定义就像类型的通用模板，实例使用特定数据填充该模板以创建类型的值。例如，我们可以声明特定用户，如第 5-2 节所示。
![[Pasted image 20240509163515.png]]
要从结构体中获取特定值，我们使用点表示法。例如，要访问此用户的电子邮件地址，我们使用 `user1.email` 。如果实例是可变的，我们可以通过使用点表示法并分配到特定字段来更改值。图 5-3 显示了如何更改可变 `User` 实例中 `email` 字段中的值。
![[Pasted image 20240509163928.png]]
请注意整个实例必须是可变的；Rust 不允许我们仅标记某些字段为可变的。与任何表达式一样，我们可以在函数体中的最后一个表达式中构造结构体的新实例，以隐式返回该新实例。
清单 5-4 显示了一个 `build_user` 函数，该函数返回一个具有给定电子邮件和用户名的 `User` 实例。 `active` 字段获取 `true` 的值， `sign_in_count` 获取 `1` 的值。

![[Pasted image 20240509164006.png]]
将函数参数命名为与结构字段相同的名称是有道理的，但不得不重复 `email` 和 `username` 字段名称和变量有点乏味。如果结构体有更多字段，重复每个名称会变得更加恼人。幸运的是，有一个方便的简写方式！
![[Pasted image 20240509164347.png]]
### [使用结构更新语法从其他实例创建实例](https://doc.rust-lang.org/book/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax)

通常情况下，创建一个包含另一个实例大部分数值但有所改变的结构体新实例是很有用的。您可以使用结构体更新语法来实现这一点。

首先，在列表 5-6 中，我们展示了如何在 `user2` 中定期创建一个新的 `User` 实例，而不使用更新语法。我们为 `email` 设置了一个新值，但除此之外，我们使用了在列表 5-2 中创建的 `user1` 相同的值。

![[Pasted image 20240509223943.png]]

使用结构更新语法，我们可以用更少的代码实现相同的效果，如清单 5-7 所示。语法 `..` 指定未明确设置的其余字段应具有与给定实例中的字段相同的值。

![[Pasted image 20240509224024.png]]

在列表 5-7 中的代码还创建了一个实例，该实例在 `user2` 中具有不同的 `email` 值，但与 `user1` 中的 `username` 、 `active` 和 `sign_in_count` 字段具有相同的值。 `..user1` 必须放在最后，以指定任何剩余字段应从 `user1` 中的相应字段获取其值，但我们可以选择以任何顺序为尽可能多的字段指定值，而不考虑结构定义中字段的顺序。

请注意，结构体更新语法使用 `=` 类似于赋值；这是因为它移动数据，就像我们在“变量和数据与移动交互”部分看到的那样。在这个例子中，创建 `user2` 后，我们不能再将 `user1` 作为整体使用，因为 `user1` 字段中的 `String` 已经移动到 `user2` 中。如果我们为 `user2` 和 `username` 分别给出了新的 `String` 值，并且只使用了 `user1` 中的 `active` 和 `sign_in_count` 值，那么在创建 `user2` 后， `user1` 仍然有效。 `active` 和 `sign_in_count` 都是实现了 `Copy` 特质的类型，因此我们在“仅限堆栈数据：复制”部分讨论的行为将适用。

### [使用没有命名字段的元组结构创建不同类型](https://doc.rust-lang.org/book/ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types)

Rust 还支持类似于元组的结构体，称为元组结构体。元组结构体具有结构体名称提供的附加含义，但不具有与字段关联的名称；相反，它们只具有字段的类型。当您想要为整个元组命名并使元组成为与其他元组不同类型时，以及在常规结构体中为每个字段命名会显得冗长或多余时，元组结构体是有用的。

要定义一个元组结构体，首先使用 `struct` 关键字，然后是结构体名称，后面跟着元组中的类型。例如，这里我们定义并使用了两个元组结构体，分别命名为 `Color` 和 `Point` ：
![[Pasted image 20240509224340.png]]
请注意， `black` 和 `origin` 的值是不同类型的，因为它们是不同元组结构的实例。您定义的每个结构体都是自己的类型，即使结构体内的字段可能具有相同的类型。例如，一个接受类型为 `Color` 的参数的函数不能接受 `Point` 作为参数，即使这两种类型都由三个 `i32` 值组成。否则，元组结构的实例与元组类似，您可以将它们解构为各个部分，并且您可以使用 `.` 后跟索引来访问单个值。
### [没有任何字段的单元结构](https://doc.rust-lang.org/book/ch05-01-defining-structs.html#unit-like-structs-without-any-fields)

您还可以定义没有任何字段的结构体！这些被称为类似单元的结构体，因为它们的行为类似于 `()` ，我们在“元组类型”部分提到的单元类型。当您需要在某种类型上实现一个特质但又没有任何要存储在类型本身中的数据时，类似单元的结构体会很有用。我们将在第 10 章讨论特质。这里是声明和实例化一个名为 `AlwaysEqual` 的单元结构体的示例：
![[Pasted image 20240509224503.png]]

为了定义 `AlwaysEqual` ，我们使用 `struct` 关键字，我们想要的名称，然后是一个分号。不需要花括号或括号！然后我们可以以类似的方式在 `subject` 变量中获取 `AlwaysEqual` 的实例：使用我们定义的名称，不带任何花括号或括号。想象一下，稍后我们将为这种类型实现行为，使得每个 `AlwaysEqual` 的实例始终等于任何其他类型的实例，也许是为了测试目的而获得已知结果。我们不需要任何数据来实现这种行为！您将在第 10 章中看到如何定义特征并将其实现在任何类型上，包括类似单元的结构。

在清单 5-1 中的 `User` 结构定义中，我们使用了拥有的 `String` 类型，而不是 `&str` 字符串切片类型。这是一个有意为之的选择，因为我们希望这个结构的每个实例都拥有其所有数据，并且这些数据在整个结构有效时都是有效的。

结构体也可以存储对其他所有者拥有的数据的引用，但这需要使用生命周期，这是 Rust 的一个特性，我们将在第 10 章中讨论。生命周期确保结构体引用的数据在结构体存在期间是有效的。假设您尝试在结构体中存储一个引用而没有指定生命周期，就像下面这样；这是行不通的：

![[Pasted image 20240509225031.png]]
编译器会抱怨它需要生命周期标识符：
![[Pasted image 20240509225108.png]]

在第 10 章，我们将讨论如何修复这些错误，以便您可以在结构体中存储引用，但目前，我们将使用拥有类型（如 `String` ）而不是引用（如 `&str` ）来修复这些错误。

要了解何时需要使用结构体，让我们编写一个计算矩形面积的程序。我们将从使用单个变量开始，然后重构程序，直到我们改为使用结构体。

让我们使用 Cargo 创建一个名为 rectangles 的新二进制项目，该项目将获取以像素为单位指定的矩形的宽度和高度，并计算矩形的面积。清单 5-8 显示了一个简短的程序，展示了在项目的 src/main.rs 中以一种方式完成这一任务。

![[Pasted image 20240509225208.png]]
这段代码通过调用 `area` 函数来计算矩形的面积，但我们可以做更多的工作来使这段代码更清晰易读。

fn area(width: u32, height: u32) -> u32 {

`area` 函数应该计算一个矩形的面积，但我们编写的函数有两个参数，在我们的程序中并没有清楚地表明这两个参数是相关的。将宽度和高度组合在一起会更易读和更易管理。我们已经讨论过一种可能的方法，在第 3 章“元组类型”部分中：使用元组。

### [使用元组重构](https://doc.rust-lang.org/book/ch05-02-example-structs.html#refactoring-with-tuples)

![[Pasted image 20240509225329.png]]

在某种程度上，这个程序更好了。元组让我们添加了一点结构，现在我们只传递了一个参数。但在另一方面，这个版本不太清晰：元组没有为它们的元素命名，所以我们必须索引元组的各个部分，使我们的计算不太明显。

混淆宽度和高度对于面积计算并不重要，但如果我们想在屏幕上绘制矩形，那就很重要！我们必须记住 `width` 是元组索引 `0` ， `height` 是元组索引 `1` 。如果其他人要使用我们的代码，要想弄清楚并记住这一点会更加困难。因为我们在代码中没有传达数据的含义，所以现在更容易引入错误。

### [使用结构重构：添加更多含义](https://doc.rust-lang.org/book/ch05-02-example-structs.html#refactoring-with-structs-adding-more-meaning)

我们使用结构体通过为数据加标签来赋予意义。我们可以将正在使用的元组转换为一个具有整体名称和部分名称的结构体，如清单 5-10 所示。

![[Pasted image 20240509225446.png]]

在这里，我们定义了一个结构体并命名为 `Rectangle` 。在花括号内，我们将字段定义为 `width` 和 `height` ，它们的类型都是 `u32` 。然后，在 `main` 中，我们创建了一个特定实例 `Rectangle` ，宽度为 `30` ，高度为 `50` 。

我们的 `area` 函数现在使用一个参数进行定义，我们将其命名为 `rectangle` ，其类型为不可变借用的 `Rectangle` 结构体实例。正如第 4 章中所提到的，我们希望借用结构体而不是拥有它。这样， `main` 保留了它的所有权，并且可以继续使用 `rect1` ，这也是我们在函数签名和调用函数的地方使用 `&` 的原因。

`area` 函数访问 `Rectangle` 实例的 `width` 和 `height` 字段（请注意，访问借用的结构体实例的字段不会移动字段值，这就是为什么经常看到结构体的借用）。我们现在对 `area` 的函数签名准确地表达了我们的意思：计算 `Rectangle` 的面积，使用其 `width` 和 `height` 字段。这表明宽度和高度彼此相关，并为值提供了描述性名称，而不是使用 `0` 和 `1` 的元组索引值。这对于清晰度是一个胜利。

### [使用派生特性添加有用功能](https://doc.rust-lang.org/book/ch05-02-example-structs.html#adding-useful-functionality-with-derived-traits)

在我们调试程序时，能够打印 `Rectangle` 的一个实例并查看其所有字段的值将会很有用。在尝试使用我们在之前章节中使用过的 `println!` 宏的清单 5-11 中，这种方法不起作用。

![[Pasted image 20240509225613.png]]

当我们编译这段代码时，会出现一个错误，错误信息如下：

error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`

`println!` 宏可以执行多种格式化操作，默认情况下，花括号告诉 `println!` 使用称为 `Display` 的格式化：用于直接最终用户消费的输出。到目前为止，我们看到的原始类型默认实现了 `Display` ，因为只有一种方式可以向用户显示 `1` 或其他任何原始类型。但是对于结构体， `println!` 应该如何格式化输出就不那么清晰了，因为有更多的显示可能性：您想要逗号还是不要？您想要打印花括号吗？所有字段都应该显示吗？由于这种模棱两可，Rust 不会尝试猜测我们想要什么，结构体没有提供 `Display` 的实现，供 `println!` 和 `{}` 占位符使用。

如果我们继续阅读错误，我们会发现这个有用的提示：
= help: the trait `std::fmt::Display` is not implemented for `Rectangle` = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead

让我们试试看！现在， `println!` 宏调用将会变成 `println!("rect1 is {:?}", rect1);` 。将占位符 `:?` 放在花括号内告诉 `println!` 我们想要使用一个名为 `Debug` 的输出格式。 `Debug` 特性使我们能够以对开发人员有用的方式打印出我们的结构体，这样我们在调试代码时可以看到它的值。

用这个更改编译代码。该死！我们仍然遇到错误：

error[E0277]: `Rectangle` doesn't implement `Debug`

但是，编译器再次给了我们一个有用的提示：

= help: the trait `Debug` is not implemented for `Rectangle` = note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`

Rust 确实包含打印调试信息的功能，但我们必须明确选择使该功能对我们的结构体可用。为此，我们在结构体定义之前添加外部属性 `#[derive(Debug)]` ，如清单 5-12 所示。
![[Pasted image 20240509225840.png]]
现在当我们运行程序时，不会出现任何错误，我们会看到以下输出：

![[Pasted image 20240509225957.png]]

不错！输出结果可能不是最漂亮的，但它显示了此实例所有字段的值，这在调试过程中肯定会有所帮助。当我们有更大的结构体时，有一个更容易阅读的输出是很有用的；在这种情况下，我们可以在字符串 `println!` 中使用 `{:#?}` 而不是 `{:?}` 。在这个例子中，使用 `{:#?}` 风格将输出以下内容：

![[Pasted image 20240509230023.png]]
使用 `Debug` 格式打印值的另一种方法是使用 `dbg!` 宏，该宏获取表达式的所有权（与 `println!` 相反，它获取引用），打印出 `dbg!` 宏调用在代码中发生的文件和行号以及该表达式的结果值，并返回该值的所有权。

注意：调用 `dbg!` 宏会打印到标准错误控制台流（ `stderr` ），而不是打印到标准输出控制台流（ `stdout` ）。我们将在第 12 章“将错误消息写入标准错误而不是标准输出”部分更多地讨论 `stderr` 和 `stdout` 。

这是一个例子，我们对分配给 `width` 字段的值感兴趣，以及整个结构体在 `rect1` 中的值：
![[Pasted image 20240509230118.png]]

我们可以在表达式 `30 * scale` 周围放置 `dbg!` ，因为 `dbg!` 返回表达式值的所有权，所以 `width` 字段将获得与我们没有 `dbg!` 调用时相同的值。我们不希望 `dbg!` 获取 `rect1` 的所有权，因此在下一个调用中使用 `rect1` 的引用。这个示例的输出如下：

![[Pasted image 20240509230203.png]]

我们可以看到第一部分输出来自 src/main.rs 的第 10 行，我们正在调试表达式 `30 * scale` ，其结果值为 `60` （整数的 `Debug` 格式化实现只打印它们的值）。src/main.rs 的第 14 行上的 `dbg!` 调用输出 `&rect1` 的值，这是 `Rectangle` 结构体。此输出使用 `Rectangle` 类型的漂亮 `Debug` 格式化。当您试图弄清楚代码在做什么时， `dbg!` 宏可能非常有帮助！

除了 `Debug` 特性外，Rust 还为我们提供了许多特性，可以与 `derive` 属性一起使用，为我们的自定义类型添加有用的行为。这些特性及其行为在附录 C 中列出。我们将在第 10 章中介绍如何实现这些特性以及如何创建自己的特性。除了 `derive` 之外，还有许多其他属性；有关更多信息，请参阅 Rust 参考手册中的“属性”部分。

我们的 `area` 函数非常具体：它只计算矩形的面积。将这种行为与我们的 `Rectangle` 结构更紧密地联系在一起会很有帮助，因为它不适用于任何其他类型。让我们看看如何通过将 `area` 函数转换为定义在我们的 `Rectangle` 类型上的 `area` 方法来继续重构这段代码。

方法类似于函数：我们使用 `fn` 关键字和名称声明它们，它们可以有参数和返回值，并且它们包含一些代码，当方法从其他地方调用时运行。与函数不同，方法是在结构体的上下文中定义的（或者在第 6 章和第 17 章中分别介绍的枚举或特质对象中），它们的第一个参数始终是 `self` ，表示方法被调用的结构体实例。

让我们修改具有 `Rectangle` 实例作为参数的 `area` 函数，而是在 `Rectangle` 结构体上定义一个 `area` 方法，如清单 5-13 所示。

![[Pasted image 20240509230545.png]]

在 `Rectangle` 的上下文中定义函数，我们为 `Rectangle` 启动一个 `impl` （实现）块。该 `impl` 块中的所有内容将与 `Rectangle` 类型相关联。然后，我们将 `area` 函数移至 `impl` 花括号内，并将签名中的第一个参数（在这种情况下是唯一的参数）更改为 `self` ，并在整个主体中使用。在 `main` 中，我们调用 `area` 函数并将 `rect1` 作为参数传递时，我们可以改用方法语法在 `Rectangle` 实例上调用 `area` 方法。方法语法在实例之后进行：我们添加一个点，然后是方法名称、括号和任何参数。

在 `area` 的签名中，我们使用 `&self` 而不是 `rectangle: &Rectangle` 。 `&self` 实际上是 `self: &Self` 的缩写。在 `impl` 块中，类型 `Self` 是 `impl` 块所用类型的别名。方法必须有一个名为 `self` 且类型为 `Self` 的参数作为它们的第一个参数，因此 Rust 允许您在第一个参数位置上仅使用名称 `self` 来缩写。请注意，我们仍然需要在 `self` 缩写前面使用 `&` 来指示该方法借用 `Self` 实例，就像我们在 `rectangle: &Rectangle` 中所做的那样。方法可以获取 `self` 的所有权，以不可变方式借用 `self` ，就像我们在这里所做的那样，或者以可变方式借用 `self` ，就像它们可以处理任何其他参数一样。

出于与函数版本中使用 `&Rectangle` 相同的原因，我们在这里选择了 `&self` ：我们不想拥有它，只想读取结构中的数据，而不是写入它。如果我们想要更改作为方法一部分调用的实例，我们将使用 `&mut self` 作为第一个参数。仅使用 `self` 作为第一个参数获取实例所有权的方法很少见；通常在方法将 `self` 转换为其他内容并希望在转换后阻止调用者使用原始实例时使用此技术。

使用方法而不是函数的主要原因，除了提供方法语法并且不必在每个方法的签名中重复 `self` 的类型之外，还有组织性。我们将可以对类型实例执行的所有操作放在一个 `impl` 块中，而不是让我们代码的未来用户在我们提供的库的各个地方搜索 `Rectangle` 的功能。

请注意，我们可以选择将方法命名为结构体字段之一相同的名称。例如，我们可以在 `Rectangle` 上定义一个也被命名为 `width` 的方法：

![[Pasted image 20240509230730.png]]
在这里，我们选择使 `width` 方法返回 `true` ，如果实例的 `width` 字段中的值大于 `0` ，并且如果值为 `0` ，则返回 `false` ：我们可以为任何目的在同名方法中使用字段。在 `main` 中，当我们在 `rect1.width` 后面加上括号时，Rust 知道我们指的是方法 `width` 。当我们不使用括号时，Rust 知道我们指的是字段 `width` 。

通常，但并非总是，当我们给一个方法取与字段相同的名称时，我们希望它只返回字段中的值，而不做其他操作。这样的方法称为 getter，Rust 不像其他一些语言那样自动为结构字段实现它们。Getter 很有用，因为您可以将字段设为私有，但将方法设为公共，从而在类型的公共 API 中启用对该字段的只读访问。我们将在第 7 章讨论公共和私有是什么，以及如何将字段或方法指定为公共或私有。

在 C 和 C++中，调用方法时使用两种不同的运算符：如果直接在对象上调用方法，则使用 `.` ；如果在对象的指针上调用方法并且需要先解引用指针，则使用 `->` 。换句话说，如果 `object` 是一个指针，那么 `object->something()` 类似于 `(*object).something()` 。

Rust 没有等同于 `->` 运算符的功能；相反，Rust 有一个称为自动引用和解引用的特性。在 Rust 中，调用方法是少数具有这种行为的地方之一。

这是它的工作原理：当您使用 `object.something()` 调用一个方法时，Rust 会自动添加 `&` 、 `&mut` 或 `*` ，以使 `object` 与方法的签名匹配。换句话说，以下内容是相同的：
![[Pasted image 20240509232740.png]]

第一个看起来干净多了。这种自动引用行为之所以有效，是因为方法有一个明确的接收者—— `self` 的类型。给定方法的接收者和名称，Rust 可以明确地确定该方法是读取（ `&self` ）、变异（ `&mut self` ）还是消耗（ `self` ）。Rust 使得方法接收者的借用隐式化，这是实际中使所有权使用起来更加方便的重要部分。

### [具有更多参数的方法](https://doc.rust-lang.org/book/ch05-03-method-syntax.html#methods-with-more-parameters)

让我们通过在 `Rectangle` 结构上实现第二个方法来练习使用方法。这次，我们希望 `Rectangle` 的一个实例接受另一个 `Rectangle` 的实例，并在第二个 `Rectangle` 完全适合 `self` （第一个 `Rectangle` ）时返回 `true` ；否则，它应该返回 `false` 。也就是说，一旦我们定义了 `can_hold` 方法，我们希望能够编写列表 5-14 中显示的程序。
![[Pasted image 20240509233143.png]]
由于 `rect2` 的两个维度均小于 `rect1` 的维度，所以预期的输出将如下所示，但 `rect3` 比 `rect1` 更宽：
Can rect1 hold rect2? true 
Can rect1 hold rect3? false

我们知道我们想要定义一个方法，所以它将在 `impl Rectangle` 块内。方法名将是 `can_hold` ，它将以另一个 `Rectangle` 的不可变借用作为参数。我们可以通过查看调用方法的代码来确定参数的类型： `rect1.can_hold(&rect2)` 传入 `&rect2` ，这是对 `rect2` 的不可变借用， `Rectangle` 的一个实例。这是有道理的，因为我们只需要读取 `rect2` （而不是写入，这意味着我们需要一个可变借用），我们希望 `main` 保留对 `rect2` 的所有权，这样我们在调用 `can_hold` 方法后可以再次使用它。 `can_hold` 的返回值将是一个布尔值，实现将检查 `self` 的宽度和高度是否分别大于另一个 `Rectangle` 的宽度和高度。让我们将新的 `can_hold` 方法添加到列表 5-13 中的 `impl` 块中，如列表 5-15 所示。
![[Pasted image 20240509234559.png]]
当我们在列表 5-14 中使用 `main` 函数运行此代码时，我们将获得我们想要的输出。方法可以接受多个参数，我们将这些参数添加到 `self` 参数后的签名中，这些参数的工作方式就像函数中的参数一样。

在 `impl` 块中定义的所有函数都被称为关联函数，因为它们与以 `impl` 命名的类型相关联。我们可以定义不以 `self` 作为第一个参数的关联函数（因此不是方法），因为它们不需要类型的实例来使用。我们已经使用了一个类似的函数：在 `String` 类型上定义的 `String::from` 函数。

与方法不同的相关函数通常用于将返回结构体新实例的构造函数。这些通常被称为 `new` ，但 `new` 不是特殊名称，也不是内置于语言中的。例如，我们可以选择提供一个名为 `square` 的相关函数，该函数将具有一个维度参数，并将其用作宽度和高度，从而更容易创建一个正方形 `Rectangle` ，而不必指定相同的值两次。
![[Pasted image 20240510221639.png]]
返回类型和函数体中的 `Self` 关键字是出现在 `impl` 关键字之后的类型的别名，本例中为 `Rectangle` 。

要调用此关联函数，我们使用 `::` 语法与结构名称； `let sq = Rectangle::square(3);` 是一个示例。此函数由结构命名空间化： `::` 语法用于模块创建的关联函数和命名空间。我们将在第 7 章讨论模块。

### [多个 `impl` 块](https://doc.rust-lang.org/book/ch05-03-method-syntax.html#multiple-impl-blocks)

每个结构体都允许有多个 `impl` 块。例如，列表 5-15 等同于列表 5-16 中显示的代码，其中每个方法都在自己的 `impl` 块中。
![[Pasted image 20240510221729.png]]

结构体允许您创建对您的领域有意义的自定义类型。通过使用结构体，您可以将相关的数据片段连接在一起，并为每个片段命名，以使您的代码清晰。在 `impl` 块中，您可以定义与您的类型相关联的函数，方法是一种关联函数，让您指定结构体实例的行为。

# [枚举和模式匹配](https://doc.rust-lang.org/book/ch06-00-enums.html#enums-and-pattern-matching)
在本章中，我们将看看枚举，也称为 enums。枚举允许您通过列举其可能的变体来定义类型。
首先，我们将定义并使用一个枚举来展示枚举如何可以编码含义以及数据。
接下来，我们将探讨一个特别有用的枚举，称为 `Option` ，它表示一个值可以是某物或无。
然后，我们将看看模式匹配在 `match` 表达式中如何使得针对枚举的不同值运行不同代码变得容易。
最后，我们将介绍 `if let` 结构是另一个方便且简洁的习语，可用于处理代码中的枚举。

## [定义枚举](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html#defining-an-enum)

结构体为您提供了一种将相关字段和数据组合在一起的方式，就像一个 `Rectangle` 与其 `width` 和 `height` 一样，而枚举则为您提供了一种表明一个值是可能值集合中的一个的方式。例如，我们可能想要说 `Rectangle` 是一组可能形状之一，还包括 `Circle` 和 `Triangle` 。为了实现这一点，Rust 允许我们将这些可能性编码为枚举。

让我们看一个我们可能想要在代码中表达的情况，并看看为什么在这种情况下枚举比结构体更有用且更合适。假设我们需要处理 IP 地址。目前，IP 地址使用两种主要标准：第四版和第六版。因为这些是我们的程序将遇到的 IP 地址的唯一可能性，我们可以枚举所有可能的变体，这就是枚举得名的原因。

任何 IP 地址都可以是版本四或版本六地址，但不能同时是两者。IP 地址的这种属性使枚举数据结构合适，因为枚举值只能是其变体之一。版本四和版本六地址仍然基本上是 IP 地址，因此在代码处理适用于任何类型 IP 地址的情况时，它们应被视为相同类型。

我们可以通过定义一个 `IpAddrKind` 枚举并列出 IP 地址可能的种类 `V4` 和 `V6` 来在代码中表达这个概念。这些是枚举的变体：
![[Pasted image 20240510222525.png]]

`IpAddrKind` 现在是我们可以在代码中其他地方使用的自定义数据类型。

我们可以像这样创建 `IpAddrKind` 的两个变体的实例：
![[Pasted image 20240510222553.png]]
请注意，枚举的变体是在其标识符下进行命名空间管理的，我们使用双冒号来分隔这两者。这很有用，因为现在值 `IpAddrKind::V4` 和 `IpAddrKind::V6` 都是相同类型的： `IpAddrKind` 。例如，我们可以定义一个接受任何 `IpAddrKind` 的函数：
![[Pasted image 20240510222617.png]]
我们可以使用任一变体调用此函数：
![[Pasted image 20240510222654.png]]
使用枚举类型还有更多的优势。再考虑一下我们的 IP 地址类型，目前我们没有办法存储实际的 IP 地址数据；我们只知道它是什么类型。考虑到你在第 5 章刚学习过结构体，你可能会想用结构体来解决这个问题，就像清单 6-1 中所示的那样。
![[Pasted image 20240510222717.png]]
在这里，我们定义了一个结构体 `IpAddr` ，它有两个字段：一个 `kind` 字段，类型为 `IpAddrKind` （我们之前定义的枚举），和一个 `address` 字段，类型为 `String` 。我们有两个这个结构体的实例。第一个是 `home` ，它的值为 `IpAddrKind::V4` ，作为其 `kind` ，关联的地址数据为 `127.0.0.1` 。第二个实例是 `loopback` 。它有 `IpAddrKind` 的另一个变体作为其 `kind` 值， `V6` ，并且有关联的地址 `::1` 。我们使用一个结构体将 `kind` 和 `address` 的值捆绑在一起，所以现在变体与值关联在一起。

然而，仅使用枚举来表示相同的概念更为简洁：我们可以将数据直接放入每个枚举变体，而不是将枚举放在结构体内部。这个新的 `IpAddr` 枚举的定义表示， `V4` 和 `V6` 变体都将具有关联的 `String` 值：
![[Pasted image 20240510222826.png]]

我们直接将数据附加到枚举的每个变体上，因此不需要额外的结构。在这里，我们还更容易看到枚举如何工作的另一个细节：我们定义的每个枚举变体的名称也成为构造枚举实例的函数。也就是说， `IpAddr::V4()` 是一个函数调用，接受一个 `String` 参数并返回 `IpAddr` 类型的实例。我们在定义枚举时自动获得这个构造函数。

使用枚举而不是结构体的另一个优势是：每个变体可以具有不同类型和数量的关联数据。 版本四 IP 地址将始终具有四个数值组件，其值将介于 0 和 255 之间。 如果我们想将 `V4` 地址存储为四个 `u8` 值，但仍将 `V6` 地址表示为一个 `String` 值，那么使用结构体是无法实现的。 枚举可以轻松处理这种情况：
![[Pasted image 20240510223937.png]]
我们直接将数据附加到枚举的每个变体上，因此不需要额外的结构。在这里，我们还更容易看到枚举如何工作的另一个细节：我们定义的每个枚举变体的名称也成为构造枚举实例的函数。也就是说， `IpAddr::V4()` 是一个函数调用，接受一个 `String` 参数并返回 `IpAddr` 类型的实例。我们在定义枚举时自动获得这个构造函数。

使用枚举而不是结构体的另一个优势是：每个变体可以具有不同类型和数量的关联数据。 版本四 IP 地址将始终具有四个数值组件，其值将介于 0 和 255 之间。 如果我们想将 `V4` 地址存储为四个 `u8` 值，但仍将 `V6` 地址表示为一个 `String` 值，那么使用结构体是无法实现的。 枚举可以轻松处理这种情况：
![[Pasted image 20240510224356.png]]

我们已经展示了几种不同的定义数据结构来存储版本四和版本六的 IP 地址的方法。然而，事实证明，想要存储 IP 地址并编码它们的类型是如此普遍，以至于标准库有一个我们可以使用的定义！让我们看看标准库是如何定义 `IpAddr` 的：它具有我们定义和使用的确切枚举和变体，但它将地址数据嵌入到变体中，形式为两种不同的结构体，这两种结构体对每个变体进行了不同的定义：

![[Pasted image 20240510224619.png]]
这段代码说明您可以将任何类型的数据放入枚举变体中：例如字符串、数值类型或结构体。您甚至可以包含另一个枚举！此外，标准库类型通常并不比您可能想出的更复杂。

请注意，即使标准库包含 `IpAddr` 的定义，我们仍然可以创建并使用我们自己的定义，而不会发生冲突，因为我们还没有将标准库的定义引入到我们的范围内。我们将在第 7 章更多地讨论将类型引入范围的问题。

让我们看另一个枚举的例子，如清单 6-2 所示：其中包含各种类型嵌入在其变体中。

![[Pasted image 20240510224725.png]]

这个枚举有四个不同类型的变体：

- `Quit` has no data associated with it at all.  
    `Quit` 没有任何关联的数据。
- `Move` has named fields, like a struct does.  
    `Move` 有命名字段，就像结构体一样。
- `Write` includes a single `String`.  
    `Write` 包括一个 `String` 。
- `ChangeColor` includes three `i32` values.  
    `ChangeColor` 包括三个 `i32` 值。

使用列在清单 6-2 中的变体定义枚举类似于定义不同种类的结构定义，不同之处在于枚举不使用 `struct` 关键字，所有变体都在 `Message` 类型下分组在一起。以下结构体可以保存与前述枚举变体相同的数据。

![[Pasted image 20240510224836.png]]
但是，如果我们使用不同的结构体，每个结构体都有自己的类型，那么我们就无法像在列表 6-2 中定义的 `Message` 枚举那样轻松地定义一个函数来接受这些消息中的任何一种，因为枚举是单一类型。

枚举和结构体之间还有一个相似之处：就像我们可以使用 `impl` 在结构体上定义方法一样，我们也可以在枚举上定义方法。这是一个我们可以在 `Message` 枚举上定义的名为 `call` 的方法：

![[Pasted image 20240510225724.png]]

该方法的主体将使用 `self` 来获取我们调用方法时的值。在这个例子中，我们创建了一个变量 `m` ，它的值为 `Message::Write(String::from("hello"))` ，这就是当 `m.call()` 运行时 `call` 方法主体中的 `self` 。

让我们来看看标准库中另一个非常常见和有用的枚举： `Option` 。

### [`Option` 枚举及其优势相对于空值](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html#the-option-enum-and-its-advantages-over-null-values)

本节探讨了一个 `Option` 的案例研究，这是标准库定义的另一个枚举。 `Option` 类型编码了一个非常常见的情况，即一个值可能是某物，也可能是空。

例如，如果您请求非空列表中的第一个项目，您将获得一个值。如果您请求空列表中的第一个项目，您将得到空。用类型系统表达这个概念意味着编译器可以检查您是否处理了应该处理的所有情况；这种功能可以防止在其他编程语言中非常常见的错误。

编程语言设计通常是根据包含哪些特性来考虑的，但排除哪些特性也同样重要。Rust 没有许多其他语言具有的空特性。Null 是一个表示没有值的值。在具有 null 的语言中，变量始终处于两种状态之一：null 或非 null。

在他 2009 年的演讲《空引用：十亿美元的错误》中，null 的发明者 Tony Hoare 说到：
我称之为我的十亿美元错误。那时，我正在为面向对象语言中的引用设计第一个全面的类型系统。我的目标是确保所有引用的使用绝对安全，由编译器自动执行检查。但我无法抗拒放入一个空引用的诱惑，仅仅因为实现起来太容易了。这导致了无数的错误、漏洞和系统崩溃，在过去四十年中可能造成了数十亿美元的痛苦和损失。

空值的问题在于，如果您尝试将空值用作非空值，则会收到某种错误。由于这种空值或非空值属性是无处不在的，因此很容易犯这种错误。

然而，null 试图表达的概念仍然是有用的：null 是一个当前无效或缺失的值。

问题实际上并不在于概念，而在于具体的实现。因此，
Rust 没有空值，但它有一个枚举类型，可以编码值存在或不存在的概念。这个枚举类型是 `Option<T>` ，并且由标准库定义如下：

![[Pasted image 20240510230207.png]]

`Option<T>` 枚举非常有用，甚至包含在预导入模块中；您无需显式地将其引入作用域。它的变体也包含在预导入模块中：您可以直接使用 `Some` 和 `None` ，无需 `Option::` 前缀。 `Option<T>` 枚举仍然只是一个常规枚举， `Some(T)` 和 `None` 仍然是 `Option<T>` 类型的变体。

`<T>` 语法是 Rust 的一个特性，我们还没有讨论过。它是一个泛型类型参数，我们将在第 10 章更详细地介绍泛型。现在，你需要知道的是 `<T>` 意味着 `Some` 枚举的 `Option` 变体可以容纳任何类型的数据，并且每个用于替代 `T` 的具体类型都会使得整体的 `Option<T>` 类型成为不同的类型。以下是一些使用 `Option` 值来保存数字类型和字符串类型的示例：

![[Pasted image 20240510230245.png]]

`some_number` 的类型是 `Option<i32>` 。 `some_char` 的类型是 `Option<char>` ，这是一种不同的类型。Rust 可以推断这些类型，因为我们在 `Some` 变体内指定了一个值。对于 `absent_number` ，Rust 要求我们注释整体的 `Option` 类型：编译器无法仅通过查看 `None` 值来推断相应的 `Some` 变体将保存的类型。在这里，我们告诉 Rust 我们希望 `absent_number` 是 `Option<i32>` 类型。

当我们有一个 `Some` 值时，我们知道存在一个值，并且该值保存在 `Some` 中。当我们有一个 `None` 值时，在某种意义上它意味着与 null 相同：我们没有一个有效的值。那么为什么拥有 `Option<T>` 要比拥有 null 好呢？

简而言之，因为 `Option<T>` 和 `T` （其中 `T` 可以是任何类型）是不同的类型，编译器不会让我们将 `Option<T>` 值用作绝对有效的值。例如，这段代码不会编译，因为它试图将 `i8` 添加到 `Option<i8>` 中：

![[Pasted image 20240511085152.png]]
![[Pasted image 20240511085210.png]]
强烈！实际上，这个错误消息意味着 Rust 不知道如何将 `i8` 和 `Option<i8>` 相加，因为它们是不同的类型。当我们在 Rust 中有一个类型为 `i8` 的值时，编译器将确保我们始终有一个有效的值。我们可以放心地继续，而无需在使用该值之前检查 null。只有当我们有一个 `Option<i8>` （或者我们正在处理的任何类型的值）时，我们才需要担心可能没有值，编译器将确保我们在使用该值之前处理该情况。

换句话说，在执行 `T` 操作之前，您必须将 `Option<T>` 转换为 `T` 。一般来说，这有助于捕捉 null 的最常见问题之一：假设某些东西不是 null，而实际上它是。

消除错误地假设非 null 值的风险有助于您对代码更有信心。为了拥有一个可能为 null 的值，您必须通过将该值的类型明确设置为 `Option<T>` 来显式选择加入。然后，在使用该值时，您必须明确处理值为 null 的情况。在值具有不是 `Option<T>` 的类型的任何地方，您可以安全地假设该值不为 null。这是 Rust 有意为之的设计决定，以限制 null 的普遍性并增加 Rust 代码的安全性。

那么，当您有一个类型为 `Option<T>` 的值时，如何从 `Some` 变体中获取 `T` 值，以便您可以使用该值？ `Option<T>` 枚举有大量在各种情况下非常有用的方法；您可以在其文档中查看这些方法。熟悉 `Option<T>` 上的方法将对您在 Rust 之旅中非常有用。

一般来说，为了使用 `Option<T>` 值，您希望有处理每个变体的代码。您希望一些代码仅在您有一个 `Some(T)` 值时运行，并且此代码可以使用内部的 `T` 。您希望另一些代码仅在您有一个 `None` 值时运行，并且该代码没有 `T` 值可用。 `match` 表达式是一个控制流构造，当与枚举一起使用时，它将根据枚举的哪个变体运行不同的代码，并且该代码可以使用匹配值内部的数据。

## [`match` 控制流构造](https://doc.rust-lang.org/book/ch06-02-match.html#the-match-control-flow-construct)
Rust 拥有一个非常强大的控制流构造，称为 `match` ，它允许您将一个值与一系列模式进行比较，然后根据匹配的模式执行代码。模式可以由文字值、变量名、通配符和许多其他内容组成；第 18 章涵盖了所有不同类型的模式及其功能。 `match` 的强大之处在于模式的表现力，以及编译器确认处理了所有可能的情况。

将 `match` 表达式想象成一个硬币分类机：硬币沿着带有各种大小孔的轨道滑动，每个硬币都会掉入它适合的第一个孔中。同样，值会通过 `match` 中的每个模式，当值“适合”第一个模式时，该值将掉入相关代码块中，在执行过程中使用。

说到硬币，让我们以 `match` 为例！我们可以编写一个函数，接受一个未知的美国硬币，并类似于计数机器，确定它是哪种硬币，并以美分为单位返回其值，如清单 6-3 所示。

![[Pasted image 20240511085519.png]]

让我们来分解 `value_in_cents` 函数中的 `match` 。首先我们列出 `match` 关键字，然后是一个表达式，这里是值 `coin` 。这似乎与在 `if` 中使用的条件表达式非常相似，但有一个很大的区别：在 `if` 中，条件需要求值为布尔值，但在这里可以是任何类型。在这个例子中， `coin` 的类型是我们在第一行定义的 `Coin` 枚举。

接下来是 `match` 个手臂。一个手臂有两部分：一个模式和一些代码。这里的第一个手臂有一个模式，其值为 `Coin::Penny` ，然后是 `=>` 运算符，用于分隔模式和要运行的代码。在这种情况下，代码只是值 `1` 。每个手臂之间用逗号分隔。

当 `match` 表达式执行时，它会将结果值与每个分支的模式进行比较，依次进行。如果某个模式与该值匹配，则执行与该模式关联的代码。如果该模式与该值不匹配，则执行将继续到下一个分支，就像硬币分类机一样。我们可以根据需要设置任意多的分支：在列表 6-3 中，我们的 `match` 有四个分支。

与每个分支相关联的代码是一个表达式，在匹配分支中表达式的结果值是整个 `match` 表达式返回的值。

如果匹配分支代码很短，我们通常不使用花括号，就像在清单 6-3 中每个分支只返回一个值一样。如果要在匹配分支中运行多行代码，必须使用花括号，然后分支后面的逗号是可选的。例如，以下代码每次使用 `Coin::Penny` 调用方法时都会打印“幸运的一分钱！”，但仍然返回块的最后一个值 `1` ：

![[Pasted image 20240511085753.png]]

### [绑定到值的模式](https://doc.rust-lang.org/book/ch06-02-match.html#patterns-that-bind-to-values)

匹配臂的另一个有用功能是它们可以绑定到与模式匹配的值的部分。这就是我们如何从枚举变体中提取值的方法。

举个例子，让我们将枚举变体之一更改为在其中保存数据。从 1999 年到 2008 年，美国铸造了一侧有 50 个州设计的 25 美分硬币。没有其他硬币有州设计，所以只有 25 美分硬币具有这种额外价值。我们可以通过将 `Quarter` 变体更改为包含内部存储的 `UsState` 值来将此信息添加到我们的 `enum` 中，这是我们在清单 6-4 中完成的。
![[Pasted image 20240511085922.png]]
让我们想象一下，一个朋友正在努力收集所有 50 个州纪念币。当我们按硬币类型整理零钱时，我们还会大声说出与每个纪念币相关的州名，这样如果是我们的朋友还没有的，他们就可以把它加入到自己的收藏中。

在此代码的匹配表达式中，我们向匹配变体 `Coin::Quarter` 的模式中添加一个名为 `state` 的变量。当 `Coin::Quarter` 匹配时， `state` 变量将绑定到该季度状态的值。然后我们可以在代码中使用 `state` 来表示该分支，如下所示：
![[Pasted image 20240511090632.png]]
如果我们称 `value_in_cents(Coin::Quarter(UsState::Alaska))` 为 `coin` ，那么 `Coin::Quarter(UsState::Alaska)` 将会是 `Coin::Quarter(state)` 。当我们将该值与每个匹配的分支进行比较时，直到达到 `state` 之前，都没有匹配。在那一点上， `state` 的绑定将是值 `UsState::Alaska` 。然后我们可以在 `println!` 表达式中使用该绑定，从而将 `Coin` 枚举变体的内部状态值取出来，用于 `Quarter` 。

### [与 `Option<T>` 匹配](https://doc.rust-lang.org/book/ch06-02-match.html#matching-with-optiont)

在前一节中，我们想要在使用 `Option<T>` 时从 `Some` 情况中取出内部 `T` 值；我们也可以使用 `match` 处理 `Option<T>` ，就像我们处理 `Coin` 枚举一样！我们不再比较硬币，而是比较 `Option<T>` 的变体，但 `match` 表达式的工作方式仍然相同。

假设我们想要编写一个函数，该函数接受一个 `Option<i32>` ，如果里面有值，则将该值加 1。如果里面没有值，则函数应返回 `None` 值，并且不尝试执行任何操作。

这个函数非常容易编写，多亏了 `match` ，看起来会像 6-5 清单。

![[Pasted image 20240511162126.png]]
让我们更详细地检查 `plus_one` 的第一次执行。当我们调用 `plus_one(five)` 时，在 `plus_one` 的主体中的变量 `x` 将具有值 `Some(5)` 。然后我们将其与每个匹配分支进行比较：
![[Pasted image 20240511162207.png]]

`Some(5)` 的值与模式 `None` 不匹配，因此我们继续到下一个分支：
![[Pasted image 20240511162244.png]]

`Some(5)` 是否匹配 `Some(i)` ？是的！我们有相同的变体。 `i` 绑定到 `Some` 中包含的值，所以 `i` 取值 `5` 。然后执行匹配分支中的代码，所以我们将 `i` 的值加 1，并创建一个新的 `Some` 值，其中包含我们的总计 `6` 。

现在让我们考虑列表 6-5 中 `plus_one` 的第二个调用，其中 `x` 是 `None` 。我们输入 `match` 并与第一个参数进行比较：
![[Pasted image 20240511162320.png]]

匹配成功！没有值可添加，因此程序停止并返回 `=>` 右侧的 `None` 值。由于第一个分支匹配成功，不会比较其他分支。

将 `match` 和枚举结合在一起在许多情况下都很有用。在 Rust 代码中，你会经常看到这种模式：与枚举匹配，将一个变量绑定到其中的数据，然后根据它执行代码。一开始有点棘手，但一旦习惯了，你会希望所有语言都有这个功能。这一直是用户喜爱的功能。

### [比赛是彻底的](https://doc.rust-lang.org/book/ch06-02-match.html#matches-are-exhaustive)

我们需要讨论 `match` 的另一个方面：手臂的模式必须涵盖所有可能性。考虑一下我们 `plus_one` 函数的这个版本，它有一个错误，无法编译：
![[Pasted image 20240511162752.png]]

我们没有处理 `None` 情况，所以这段代码会导致一个错误。幸运的是，这是一个 Rust 知道如何捕捉的错误。如果我们尝试编译这段代码，我们会得到这个错误：
![[Pasted image 20240511162817.png]]
rust 知道我们没有涵盖每种可能情况，甚至知道我们忘记了哪种模式！在 Rust 中，匹配是穷尽的：我们必须穷尽每一种可能性，以使代码有效。特别是在 `Option<T>` 的情况下，当 Rust 防止我们忘记明确处理 `None` 的情况时，它保护我们免于假设我们有一个值，而实际上可能是 null，从而使之前讨论的数十亿美元错误成为不可能。

### [匹配所有模式和 `_` 占位符](https://doc.rust-lang.org/book/ch06-02-match.html#catch-all-patterns-and-the-_-placeholder)
使用枚举，我们还可以针对一些特定值采取特殊操作，但对于所有其他值采取一个默认操作。想象一下，我们正在实现一个游戏，在游戏中，如果你掷骰子掷出 3 点，你的玩家不会移动，而是会得到一个新的花哨帽子。如果你掷出 7 点，你的玩家会失去一个花哨帽子。对于所有其他值，你的玩家会在游戏板上移动相应的空间数。这里有一个 `match` ，它实现了这种逻辑，骰子掷出的结果是硬编码的，而不是随机值，并且所有其他逻辑由没有主体的函数表示，因为实际实现它们超出了此示例的范围。
![[Pasted image 20240511163434.png]]

对于前两个臂，模式是字面值 `3` 和 `7` 。对于覆盖每个其他可能值的最后一个臂，模式是我们选择命名为 `other` 的变量。运行 `other` 臂的代码使用该变量，通过将其传递给 `move_player` 函数。

这段代码可以编译通过，即使我们没有列出 `u8` 可能具有的所有可能值，因为最后一个模式将匹配所有未明确列出的值。这个通配模式满足了 `match` 必须是穷尽的要求。

请注意，我们必须将通配分支放在最后，因为模式是按顺序评估的。如果我们将通配分支放在前面，其他分支将永远不会运行，因此如果我们在通配后添加分支，Rust 会警告我们！

Rust 还有一种模式，当我们想要一个全匹配但又不想使用全匹配值时可以使用： `_` 是一个特殊模式，匹配任何值但不绑定该值。这告诉 Rust 我们不打算使用该值，因此 Rust 不会警告我们有一个未使用的变量。

让我们改变游戏规则：现在，如果你掷出的是 3 或 7 之外的任何数字，你必须再掷一次。我们不再需要使用全匹配值，所以我们可以改变我们的代码，使用 `_` 代替名为 `other` 的变量：
![[Pasted image 20240511195126.png]]
最后，我们将再次更改游戏规则，这样如果您掷出的是 3 或 7 以外的任何数字，您的回合将不会发生任何其他事情。我们可以通过使用单位值（我们在“元组类型”部分提到的空元组类型）作为与 `_` 臂对应的代码来表达这一点：
![[Pasted image 20240511195242.png]]
在这里，我们明确告诉 Rust，我们不打算使用任何与之前一个分支中的模式不匹配的值，并且我们不希望在这种情况下运行任何代码。

在第 18 章中，我们将介绍更多关于模式和匹配的内容。现在，我们将继续讨论 `if let` 语法，这在 `match` 表达有点冗长的情况下非常有用。

## [使用 `if let` 进行简洁的控制流](https://doc.rust-lang.org/book/ch06-03-if-let.html#concise-control-flow-with-if-let)

`if let` 语法允许您将 `if` 和 `let` 结合在一起，以更简洁的方式处理与一个模式匹配的值相匹配的情况，同时忽略其余情况。考虑列表 6-6 中的程序，该程序在 `config_max` 变量中匹配 `Option<u8>` 值，但只想在该值是 `Some` 变体时执行代码。
![[Pasted image 20240511201546.png]]

如果值为 `Some` ，我们通过将该值绑定到模式中的变量 `max` 来打印出 `Some` 变体中的值。我们不想对 `None` 值执行任何操作。为满足 `match` 表达式，我们必须在处理一个变体后添加 `_ => ()` ，这是一种烦人的样板代码。

相反，我们可以使用 `if let` 以更简短的方式编写此代码。以下代码的行为与列表 6-6 中的 `match` 相同：

![[Pasted image 20240511201653.png]]

语法 `if let` 接受一个由等号分隔的模式和表达式。它的工作方式与 `match` 相同，其中表达式提供给 `match` ，而模式是其第一个分支。在这种情况下，模式是 `Some(max)` ，而 `max` 绑定到 `Some` 中的值。然后我们可以在 `if let` 块的主体中使用 `max` ，就像我们在相应的 `match` 分支中使用 `max` 一样。如果值不匹配模式，则不会运行 `if let` 块中的代码。

使用 `if let` 意味着更少的输入、更少的缩进和更少的样板代码。但是，您会失去 `match` 强制执行的详尽检查。在 `match` 和 `if let` 之间的选择取决于您在特定情况下的操作以及简洁性是否值得失去详尽检查。

换句话说，您可以将 `if let` 视为一种语法糖，用于运行代码当值匹配一个模式时，然后忽略所有其他值。

我们可以使用 `else` 和 `if let` 。与 `else` 相关的代码块与等效于 `if let` 和 `else` 的 `match` 表达式中的 `_` 情况的代码块相同。回想一下列表 6-4 中的 `Coin` 枚举定义，其中 `Quarter` 变体还包含一个 `UsState` 值。如果我们想要计算我们看到的所有非四分之一硬币，同时宣布四分之一硬币的状态，我们可以使用 `match` 表达式，如下所示：
![[Pasted image 20240511201806.png]]

或者我们可以使用 `if let` 和 `else` 表达式，如下所示：
![[Pasted image 20240511201850.png]]
如果您的程序逻辑过于冗长，无法使用 `match` 表达，请记住 `if let` 也在您的 Rust 工具箱中。

## [总结](https://doc.rust-lang.org/book/ch06-03-if-let.html#summary)

我们已经介绍了如何使用枚举创建可以是一组枚举值之一的自定义类型。我们展示了标准库的 `Option<T>` 类型如何帮助您使用类型系统来防止错误。当枚举值内部包含数据时，您可以使用 `match` 或 `if let` 来提取和使用这些值，具体取决于您需要处理多少种情况。

您的 Rust 程序现在可以使用结构体和枚举来表达领域中的概念。创建自定义类型以在 API 中使用可确保类型安全：编译器将确保您的函数仅获得每个函数期望的类型的值。

为了向用户提供一个组织良好的 API，易于使用且只暴露用户所需的内容，让我们现在转向 Rust 的模块。

# [使用包、库和模块管理不断增长的项目](https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html#managing-growing-projects-with-packages-crates-and-modules)

随着编写大型程序，组织代码将变得越来越重要。通过将相关功能分组并使用具有不同特性的代码进行分离，您将澄清实现特定功能的代码在哪里以及更改功能工作方式的位置。

到目前为止，我们编写的程序都在一个模块的一个文件中。随着项目的增长，您应该通过将代码拆分为多个模块，然后拆分为多个文件来组织代码。一个包可以包含多个二进制板条箱和可选一个库板条箱。随着包的增长，您可以将部分提取到成为外部依赖项的单独板条箱中。本章涵盖了所有这些技术。对于由一组相互关联的包组成的非常大型项目，这些包一起发展，Cargo 提供了工作区，我们将在第 14 章的“Cargo 工作区”部分中介绍。

我们还将讨论封装实现细节，这使您可以在更高级别重用代码：一旦您实现了一个操作，其他代码可以通过其公共接口调用您的代码，而无需知道实现方式。编写代码的方式定义了哪些部分对其他代码可用，哪些部分是您保留更改权利的私有实现细节。这是限制您必须记住的细节量的另一种方式。

一个相关概念是作用域：编写代码的嵌套上下文具有一组被定义为“在作用域内”的名称。在阅读、编写和编译代码时，程序员和编译器需要知道特定位置的特定名称是否指向变量、函数、结构、枚举、模块、常量或其他项以及该项的含义。您可以创建作用域并更改哪些名称在作用域内或作用域外。您不能在同一作用域中有两个同名项；有工具可用于解决名称冲突。

Rust 具有许多功能，允许您管理代码的组织，包括哪些细节是公开的，哪些细节是私有的，以及程序中每个作用域中有哪些名称。这些功能有时被统称为模块系统，包括：

- **Packages:** A Cargo feature that lets you build, test, and share crates  
    包：一个 Cargo 功能，可让您构建、测试和共享板条箱
- **Crates:** A tree of modules that produces a library or executable  
    库：生成库或可执行文件的模块树
- **Modules** and **use:** Let you control the organization, scope, and privacy of paths  
    模块和使用：让您控制路径的组织、作用域和私密性
- **Paths:** A way of naming an item, such as a struct, function, or module  
    路径：命名项的一种方式，例如结构、函数或模块

在本章中，我们将涵盖所有这些功能，讨论它们如何交互，并解释如何使用它们来管理作用域。最终，您应该对模块系统有扎实的理解，并能够像专业人士一样处理作用域！

我们将要介绍的模块系统的第一部分是包和 crates。

Crate 是 Rust 编译器一次考虑的最小代码量。即使你运行 `rustc` 而不是 `cargo` 并传递一个单独的源代码文件（正如我们在第一章的“编写和运行一个 Rust 程序”部分所做的），编译器也将该文件视为一个 crate。Crate 可以包含模块，这些模块可能在其他文件中定义，这些文件将与 crate 一起编译，我们将在接下来的部分中看到。

一个 crate 可以有两种形式：二进制 crate 或库 crate。二进制 crate 是你可以编译成可执行文件的程序，你可以运行它，比如命令行程序或服务器。每个二进制 crate 必须有一个名为 main 的函数，定义执行该可执行文件时会发生什么。到目前为止，我们创建的所有 crates 都是二进制 crates。

库 crates 没有 main 函数，它们不编译成可执行文件。相反，它们定义的功能旨在与多个项目共享。例如，我们在第二章中使用的 rand crate 提供了生成随机数的功能。大多数时候，当 Rust 开发者提到“crate”时，他们指的是库 crate，并且他们将“crate”与一般编程概念中的“库”这一词互换使用。

Crate 的根是 Rust 编译器开始的源文件，构成你的 crate 的根模块（我们将在“定义模块以控制范围和隐私”部分中深入解释模块）。

包是一个或多个 crates 的捆绑，提供一组功能。包含一个 Cargo.toml 文件的包描述了如何构建这些 crates。Cargo 实际上是一个包，包含了你一直在使用的命令行工具的二进制 crate。Cargo 包还包含一个二进制 crate 依赖的库 crate。其他项目可以依赖 Cargo 库 crate 来使用 Cargo 命令行工具使用的相同逻辑。

一个包可以包含尽可能多的二进制 crates，但最多只能有一个库 crate。一个包必须至少包含一个 crate，无论是库还是二进制 crate。

让我们来看看当我们创建一个包时会发生什么。首先，我们输入命令 cargo new：

![[Pasted image 20240511205311.png]]

运行 `cargo new` 后，我们使用 `ls` 来查看 Cargo 创建了什么。在项目目录中，有一个 Cargo.toml 文件，给我们一个包。还有一个包含 main.rs 的 src 目录。打开你的文本编辑器中的 Cargo.toml，注意没有提到 src/main.rs。Cargo 遵循一个约定，src/main.rs 是与包同名的二进制 crate 的 crate 根。同样，Cargo 知道如果包目录包含 src/lib.rs，那么包含一个库 crate 且与包同名，src/lib.rs 是其 crate 根。Cargo 将 crate 根文件传递给 rustc 以构建库或二进制。

在这里，我们有一个只包含 src/main.rs 的包，意味着它只包含一个名为 my-project 的二进制 crate。如果一个包包含 src/main.rs 和 src/lib.rs，它有两个 crates：一个二进制和一个库，两者都与包的名称相同。通过在 src/bin 目录放置文件，一个包可以有多个二进制 crates：每个文件将是一个单独的二进制 crate。

在本节中，我们将讨论模块及其他模块系统部分，例如允许你命名项目的路径；`use`关键字用于引入作用域内的路径；以及`pub`关键字用来使项目公开。我们还将讨论`as`关键字、外部包和全局操作符。

首先，我们将开始列出一些规则，供你在未来组织代码时参考。然后我们将详细解释每条规则。

模块速查表：
	这里我们提供了一个关于模块、路径、`use`关键字和`pub`关键字在编译器中的工作方式的快速参考，以及大多数开发者如何组织他们的代码。我们将在本章中通过示例逐一讲解这些规则，但这是一个很好的参考点，用以回忆模块是如何工作的。

从 crate 根开始：编译 crate 时，编译器首先在 crate 根文件中查找代码以编译（通常对于库 crate 是 src/lib.rs，对于二进制 crate 是 src/main.rs）。

声明模块：在 crate 根文件中，你可以声明新的模块；比如，你声明了一个名为 `garden` 的模块，使用`mod garden;`。

编译器将在以下位置查找该模块的代码： 
- 在花括号内联地替代跟在 `mod garden;`后的分号 
- 在文件 src/garden.rs 中 
- 在文件 src/garden/mod.rs 中 声明子模块：
- 在 crate 根文件以外的任何文件中，你可以声明子模块。例如，你可能在 src/garden.rs 中声明 `mod vegetables;`。
编译器将在以父模块命名的目录中的以下位置查找子模块的代码： 
- 在 `mod vegetables;` 之后直接跟随的花括号内 
- 在文件 src/garden/vegetables.rs 中 
- 在文件 src/garden/vegetables/mod.rs 中。

模块中代码的路径：一旦一个模块成为你的 crate 的一部分，只要隐私规则允许，你就可以从同一个 crate 的任何其他地方引用该模块中的代码，使用代码的路径。
例如，`garden vegetables`模块中的`Asparagus`类型将在`crate::garden::vegetables::Asparagus`找到。

私有与公开：模块中的代码默认对其父模块是私有的。要使一个模块公开，用`pub mod`声明它，而不是`mod`。要使公开模块内的项目也公开，使用它们的声明前的`pub`。

`use`关键字：在一个作用域内，`use`关键字创建到项目的快捷方式，以减少长路径的重复。
在任何可以引用`crate::garden::vegetables::Asparagus`的作用域中，
你可以用`use crate::garden::vegetables::Asparagus;`创建一个快捷方式，此后在作用域中只需写`Asparagus`即可使用该类型。 

这里我们创建了一个名为 backyard 的二进制 crate，用以示范这些规则。这个 crate 的目录也叫 backyard，包含以下文件和目录：
![[Pasted image 20240511205747.png]]

在这种情况下，crate 根文件是 src/main.rs，它包含：

![[Pasted image 20240511205820.png]]

`pub mod garden;` 这行告诉编译器包含它在 src/garden.rs 中找到的代码，其中是：

src/garden.rs
![[Pasted image 20240511211419.png]]
这里，`pub mod vegetables;` 表示 src/garden/vegetables.rs 中的代码也包含在内。那代码是：
![[Pasted image 20240511211453.png]]
现在让我们深入了解这些规则并展示它们的实际应用！

通过模块组织相关代码：
模块让我们可以为了可读性和易于重用而在 crate 内组织代码。
模块还允许我们控制项目的隐私，因为模块内的代码默认是私有的。
私有项目是不可供外部使用的内部实现细节。
我们可以选择使模块及其中的项目公开，这样就可以暴露它们，允许外部代码使用和依赖它们。

例如，让我们编写一个提供餐厅功能的库 crate。我们将定义函数的签名但留下空的函数体，以专注于代码的组织而非餐厅的实际实现。

在餐饮业中，有些部分被称为前厅，有些被称为后厅。前厅是顾客所在的地方；这包括主人带客人入座、服务员接单和收款，以及调酒师制作饮料的地方。后厅是厨师和厨工在厨房工作、洗碗工清洁以及经理进行行政工作的地方。

为了以这种方式构建我们的 crate，我们可以将其功能组织到嵌套模块中。通过运行 cargo new restaurant --lib 创建一个名为 restaurant 的新库；然后将代码输入到 src/lib.rs 中，以定义一些模块和函数签名。

这是前厅部分：
![[Pasted image 20240511211657.png]]
清单 7-1：一个包含其他模块的 front_of_house 模块，这些模块中包含函数

我们使用 `mod` 关键字后跟模块名称（在这个案例中是 front_of_house）定义一个模块。模块的主体放在花括号内。在模块内部，我们可以放置其他模块，就像本例中的 hosting 和 serving 模块一样。模块也可以包含其他项目的定义，如结构、枚举、常量、特质，以及如清单 7-1 中的函数。

通过使用模块，我们可以将相关的定义组织在一起并命名它们的相关原因。使用这段代码的程序员可以根据组织而非阅读所有定义来导航代码，这使得找到与他们相关的定义变得更容易。向这段代码添加新功能的程序员会知道在哪里放置代码以保持程序的组织性。

之前我们提到，src/main.rs 和 src/lib.rs 被称为 crate 根。之所以这样命名是因为这两个文件中的内容形成了一个名为 crate 的模块，位于 crate 的模块结构的根部，被称为模块树。

![[Pasted image 20240511211951.png]]

这棵树显示了一些模块是如何相互嵌套的；例如，hosting 嵌套在 front_of_house 中。树还显示了一些模块是彼此的兄弟，意味着它们在同一个模块中定义；hosting 和 serving 是在 front_of_house 中定义的兄弟。如果模块 A 包含在模块 B 内，我们说模块 A 是模块 B 的子模块，而模块 B 是模块 A 的父模块。注意整个模块树都根植于名为 crate 的隐式模块之下。

模块树可能会让你想起计算机上文件系统的目录树；这是一个非常恰当的比喻！就像文件系统中的目录一样，你使用模块来组织你的代码。就像目录中的文件一样，我们需要一种找到我们模块的方法。

在模块树中引用项的路径 要告诉 Rust 在模块树中找到一个项，我们使用路径，就像在导航文件系统时使用路径一样。要调用函数，我们需要知道它的路径。

路径可以采用两种形式：

绝对路径是从 crate 根目录开始的完整路径；对于来自外部 crate 的代码，绝对路径以 crate 名称开头，对于来自当前 crate 的代码，它以字面量 crate 开头。 相对路径从当前模块开始，并使用 self，super 或当前模块中的标识符。 绝对路径和相对路径都由一个或多个由双冒号（::）分隔的标识符组成。

回到清单 7-1，假设我们想要调用 add_to_waitlist 函数。这等同于问：add_to_waitlist 函数的路径是什么？清单 7-3 包含了清单 7-1，其中删除了一些模块和函数。

我们将展示两种从 crate 根目录中定义的新函数 eat_at_restaurant 调用 add_to_waitlist 函数的方法。这些路径是正确的，但仍然存在另一个问题，这将阻止此示例直接编译。我们稍后会解释原因。

eat_at_restaurant 函数是我们库 crate 的公共 API 的一部分，因此我们使用 pub 关键字标记它。在“使用 pub 关键字暴露路径”部分，我们将更详细地讨论 pub。

![[Pasted image 20240511213922.png]]

清单 7-3：使用绝对和相对路径调用 add_to_waitel ist 函数

第一次在 eat_at_restaurant 中调用 add_to_waitlist 函数时，我们使用绝对路径。add_to_waitlist 函数定义在与 eat_at_restaurant 相同的 crate 中，这意味着我们可以使用 crate 关键字来开始一个绝对路径。然后我们包含每个连续的模块，直到我们到达 add_to_waitlist。你可以想象一个具有相同结构的文件系统：我们会指定路径 /front_of_house/hosting/add_to_waitlist 来运行 add_to_waitlist 程序；使用 crate 名称从 crate 根开始就像在你的 shell 中使用 / 从文件系统根开始一样。

第二次我们在 eat_at_restaurant 中调用 add_to_waitlist 时，我们使用相对路径。路径从 front_of_house 开始，这是在模块树中与 eat_at_restaurant 同一层级定义的模块名称。这里文件系统的等价物是使用路径 front_of_house/hosting/add_to_waitlist。从一个模块名称开始意味着路径是相对的。

选择使用相对路径还是绝对路径是基于你的项目的决定，这取决于你是否更有可能分别移动项定义代码或与使用项的代码一起移动。例如，如果我们将 front_of_house 模块和 eat_at_restaurant 函数移动到一个名为 customer_experience 的模块中，我们需要更新 add_to_waitlist 的绝对路径，但相对路径仍然有效。然而，如果我们将 eat_at_restaurant 函数单独移动到一个名为 dining 的模块中，add_to_waitlist 调用的绝对路径将保持不变，但相对路径需要更新。我们通常倾向于指定绝对路径，因为更有可能我们希望独立地移动代码定义和项调用。

让我们尝试编译清单 7-3 并找出为什么它还不能编译！我们得到的错误显示在清单 7-4 中。

![[Pasted image 20240511214046.png]]
有关此错误的更多信息，请尝试 `rustc --explain E0603`。 错误：无法编译 `restaurant` (lib)，因为有两个先前的错误 清单 7-4：从构建清单 7-3 中的代码得到的编译器错误

错误消息说 hosting 模块是私有的。换句话说，我们有正确的 hosting 模块和 add_to_waitlist 函数的路径，但 Rust 不允许我们使用它们，因为它没有访问私有部分的权限。在 Rust 中，所有项（函数、方法、结构、枚举、模块和常量）默认对父模块是私有的。如果你想让像函数或结构这样的项保持私有，你可以将它们放在一个模块中。

父模块中的项不能使用子模块内的私有项，但子模块中的项可以使用其祖先模块中的项。这是因为子模块包装并隐藏其实现细节，但子模块可以看到它们被定义的上下文。继续我们的比喻，可以把隐私规则想象成餐厅的后台办公室：那里发生的事情对餐厅的客人来说是私密的，但办公室经理可以看到并做餐厅中的一切事情。

Rust 选择让模块系统以这种方式功能，以便隐藏内部实现细节是默认行为。这样，你就知道哪些内部代码的部分你可以更改而不会破坏外部代码。然而，Rust 也提供了一个选项，允许你通过使用 pub 关键字使一个项公开，以将子模块的内部部分暴露给外部祖先模块。

使用 pub 关键字暴露路径 让我们返回到清单 7-4 中告诉我们 hosting 模块是私有的错误。我们希望父模块中的 eat_at_restaurant 函数能够访问子模块中的 add_to_waitlist 函数，所以我们用 pub 关键字标记 hosting 模块，如清单 7-5 所示。
![[Pasted image 20240511222443.png]]

发生了什么？在 mod hosting 前添加 pub 关键字使得该模块公开。通过这种变化，如果我们可以访问 front_of_house，我们就可以访问 hosting。但 hosting 的内容仍然是私有的；使模块公开并不会使其内容公开。模块上的 pub 关键字只允许其祖先模块中的代码引用它，而不是访问其内部代码。因为模块是容器，只使模块公开我们无法做太多事情；我们需要进一步选择使模块内的一个或多个项目公开。

清单 7-6 中的错误表明 add_to_waitlist 函数是私有的。隐私规则适用于结构、枚举、函数和方法以及模块。

让我们通过在其定义前添加 pub 关键字，也将 add_to_waitlist 函数公开，如清单 7-7 所示。
![[Pasted image 20240511222528.png]]

现在代码将编译成功！要了解为什么添加 pub 关键字让我们可以使用这些路径调用 add_to_waitlist，并考虑到隐私规则，让我们看看绝对路径和相对路径。

在绝对路径中，我们从 crate 开始，这是我们 crate 的模块树的根。front_of_house 模块在 crate 根中定义。虽然 front_of_house 不是公开的，但因为 eat_at_restaurant 函数是在与 front_of_house 相同的模块中定义的（即，eat_at_restaurant 和 front_of_house 是兄弟），我们可以从 eat_at_restaurant 引用 front_of_house。接下来是标记为 pub 的 hosting 模块。我们可以访问 hosting 的父模块，所以我们可以访问 hosting。最后，add_to_waitlist 函数标记为 pub，我们可以访问其父模块，所以这个函数调用有效！

在相对路径中，逻辑与绝对路径相同，
除了第一步：不是从 crate 根开始，路径从 front_of_house 开始。
front_of_house 模块在与 eat_at_restaurant 相同的模块内定义，因此从定义 eat_at_restaurant 的模块开始的相对路径有效。然后，因为 hosting 和 add_to_waitlist 标记为 pub，其余的路径有效，这个函数调用有效！

具有二进制和库的包的 #最佳实践 
我们提到包可以同时包含 src/main.rs 二进制 crate 根和 src/lib.rs 库 crate 根，两个 crate 默认具有包名。
通常，包含库和二进制 crate 的包将在二进制 crate 中仅包含足够的代码来启动一个可执行文件，该可执行文件调用库 crate 的代码。这让其他项目受益于包提供的最多功能，因为库 crate 的代码可以共享。

模块树应在 src/lib.rs 中定义。然后，任何公开项都可以在二进制 crate 中通过以包名开头的路径使用。二进制 crate 成为库 crate 的用户，就像完全外部的 crate 使用库 crate 一样：它只能使用公共 API。这有助于你设计一个好的 API；你不仅是作者，也是客户！

在第 12 章中，我们将通过一个包含二进制 crate 和库 crate 的命令行程序来演示这种组织实践。

使用 super 开始相对路径 我们可以构建从父模块开始的相对路径，而不是从当前模块或 crate 根开始，通过在路径开头使用 super。这就像使用文件系统路径中的 .. 语法一样。使用 super 允许我们引用我们知道在父模块中的项，这可以在模块与父模块密切相关但父模块可能有一天会移到模块树的其他地方时，使重新排列模块树更容易。

考虑清单 7-8 中的代码，模拟厨师修正错误的订单并亲自将其送到顾客手中的情况。在 back_of_house 模块中定义的函数 fix_incorrect_order 通过指定以 super 开始的 deliver_order 路径来调用父模块中定义的函数 deliver_order：
![[Pasted image 20240511223237.png]]

fix_incorrect_order 函数在 back_of_house 模块中，所以我们可以使用 super 去到 back_of_house 的父模块，这种情况下是 crate，根。从那里，我们寻找 deliver_order 并找到它。成功！我们认为 back_of_house 模块和 deliver_order 函数可能会保持相同的关系，并在我们决定重新组织 crate 的模块树时一起移动。因此，我们使用了 super，所以如果这段代码移到不同的模块，将来需要更新的代码地方会更少。

使结构和枚举公开 
我们也可以使用 pub 来指定结构和枚举为公开，但在使用 pub 与结构和枚举时有一些额外的细节。如果我们在结构定义前使用 pub，我们使结构公开，但结构的字段仍然是私有的。我们可以根据情况逐个字段决定是否公开。在清单 7-9 中，我们定义了一个公开的 back_of_house::Breakfast 结构，其中 toast 字段公开，而 seasonal_fruit 字段私有。这模拟了餐馆中的情况，顾客可以选择随餐提供的面包类型，但厨师根据当季和库存决定伴随餐点的水果。可用的水果变化很快，所以顾客不能选择水果，甚至看不到他们将得到哪种水果。
![[Pasted image 20240511223857.png]]
一个结构中有一些公开和一些私有字段

由于 back_of_house::Breakfast 结构中的 toast 字段是公开的，在 eat_at_restaurant 中我们可以使用点符号对 toast 字段进行读写。注意我们不能在 eat_at_restaurant 中使用 seasonal_fruit 字段，因为 seasonal_fruit 是私有的。尝试取消注释修改 seasonal_fruit 字段值的行，看看你会得到什么错误！

另外，请注意，因为 back_of_house::Breakfast 有一个私有字段，所以结构需要提供一个公开的关联函数来构造 Breakfast 的实例（我们这里命名为 summer）。如果 Breakfast 没有这样的函数，我们就不能在 eat_at_restaurant 中创建 Breakfast 的实例，因为我们不能在 eat_at_restaurant 中设置私有的 seasonal_fruit 字段的值。

相反，如果我们将枚举公开，它的所有变体都将是公开的。我们只需要在枚举关键字前加 pub，如清单 7-10 所示。

![[Pasted image 20240511224331.png]]
清单 7-10：将枚举指定为公开使其所有变体都公开

由于我们使 Appetizer 枚举公开，我们可以在 eat_at_restaurant 中使用 Soup 和 Salad 变体。

除非枚举的变体是公开的，否则枚举不是很有用；每次都必须用 pub 标注所有枚举变体会很烦人，所以枚举变体的默认是公开的。结构经常在其字段不公开的情况下仍然有用，因此结构字段遵循一切默认为私有的通用规则，除非用 pub 标注。

还有一种涉及 pub 的情况我们还没有涵盖，那就是我们的最后一个模块系统功能：use 关键字。我们将首先单独讨论 use，然后展示如何结合 pub 和 use。

## [使用 `use` 关键字将路径引入作用域](https://doc.rust-lang.org/book/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#bringing-paths-into-scope-with-the-use-keyword)

不得不写出调用函数的路径可能会感到不便和重复。在清单 7-7 中，无论我们选择绝对路径还是相对路径来调用 `add_to_waitlist` 函数，每次我们想要调用 `add_to_waitlist` 时，我们都必须指定 `front_of_house` 和 `hosting` 。幸运的是，有一种方法可以简化这个过程：我们可以使用 `use` 关键字创建一个路径的快捷方式，然后在作用域中的其他地方使用更短的名称。

在清单 7-11 中，我们将 `crate::front_of_house::hosting` 模块引入到 `eat_at_restaurant` 函数的作用域中，因此我们只需要指定 `hosting::add_to_waitlist` 来调用 `eat_at_restaurant` 中的 `add_to_waitlist` 函数。

![[Pasted image 20240511224439.png]]

在作用域中添加 `use` 和路径类似于在文件系统中创建符号链接。通过在 crate 根目录中添加 `use crate::front_of_house::hosting` ， `hosting` 现在是该作用域中的有效名称，就好像 `hosting` 模块已在 crate 根目录中定义一样。使用 `use` 引入作用域的路径也会检查私有性，就像任何其他路径一样。

请注意， `use` 仅为 `use` 出现的特定范围创建快捷方式。清单 7-12 将 `eat_at_restaurant` 函数移动到一个名为 `customer` 的新子模块中，该模块与 `use` 语句不在同一范围，因此函数体将无法编译：

![[Pasted image 20240511224819.png]]
编译器错误显示，快捷方式不再适用于 `customer` 模块内：
请注意，还有一个警告， `use` 在其范围内不再使用！为了解决这个问题，请将 `use` 也移至 `customer` 模块中，或者在父模块中使用 `super::hosting` 引用快捷方式，在子模块中使用 `customer` 。

### [创建惯用的 `use` 路径](https://doc.rust-lang.org/book/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#creating-idiomatic-use-paths)

在清单 7-11 中，您可能会想知道为什么我们在 `eat_at_restaurant` 中指定了 `use crate::front_of_house::hosting` ，然后调用 `hosting::add_to_waitlist` ，而不是一直指定到 `add_to_waitlist` 函数的 `use` 路径来实现相同的结果，就像在清单 7-13 中一样。
![[Pasted image 20240511224919.png]]
尽管列表 7-11 和 7-13 都完成了相同的任务，但列表 7-11 是将函数引入作用域的惯用方式。使用 `use` 将函数的父模块引入作用域意味着在调用函数时必须指定父模块。在调用函数时指定父模块可以清楚地表明该函数并非在本地定义，同时最大程度地减少完整路径的重复。列表 7-13 中的代码不清楚 `add_to_waitlist` 是在哪里定义的。

另一方面，当引入结构体、枚举和其他带有 `use` 的项目时，习惯上要指定完整路径。清单 7-14 展示了将标准库的 `HashMap` 结构体引入二进制 crate 作用域的惯用方式。

![[Pasted image 20240511225013.png]]
这个背后没有强有力的原因：这只是已经形成的惯例，人们已经习惯了用这种方式阅读和编写 Rust 代码。

![[Pasted image 20240511224758.png]]

正如您所看到的，使用父模块可以区分这两种 `Result` 类型。如果我们指定 `use std::fmt::Result` 和 `use std::io::Result` ，那么在同一范围内会有两种 `Result` 类型，Rust 就无法确定我们在使用 `Result` 时指的是哪一种。

### [使用 `as` 关键字提供新名称](https://doc.rust-lang.org/book/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#providing-new-names-with-the-as-keyword)

解决将相同名称的两种类型引入相同范围的问题还有另一个方法：在路径后面，我们可以指定 `as` 和一个新的本地名称，或者类型的别名。清单 7-16 展示了通过使用 `as` 重命名两种 `Result` 类型中的一种来编写清单 7-15 中的代码的另一种方式。
![[Pasted image 20240511225126.png]]
在第 `use` 个语句中，我们选择了新名称 `IoResult` 来表示 `std::io::Result` 类型，这样就不会与我们也引入范围的 `std::fmt` 中的 `Result` 发生冲突。第 7-15 和第 7-16 条目被认为是惯用的，所以选择权在你手中！

### [使用 `pub use` 重新导出名称](https://doc.rust-lang.org/book/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#re-exporting-names-with-pub-use)
当我们使用 `use` 关键字将名称引入作用域时，新作用域中可用的名称是私有的。为了使调用我们代码的代码能够将该名称视为在其作用域中定义的名称，我们可以结合 `pub` 和 `use` 。这种技术称为重新导出，因为我们将一个项目引入作用域，同时也使该项目可供其他人引入其作用域。

清单 7-17 显示了清单 7-11 中根模块中的代码，其中 `use` 已更改为 `pub use` 。

![[Pasted image 20240511225214.png]]

在这个变化之前，外部代码必须通过使用路径 `restaurant::front_of_house::hosting::add_to_waitlist()` 来调用 `add_to_waitlist` 函数。现在，这个 `pub use` 已经从根模块重新导出了 `hosting` 模块，外部代码现在可以使用路径 `restaurant::hosting::add_to_waitlist()` 了。

重新导出在您的代码内部结构与调用您的代码的程序员对领域的理解不同时非常有用。例如，在这个餐厅的隐喻中，经营餐厅的人会考虑“前台”和“后台”。但是访问餐厅的顾客可能不会用这些术语来考虑餐厅的各个部分。通过 `pub use` ，我们可以用一种结构编写我们的代码，但暴露出不同的结构。这样做可以使我们的库对于正在开发该库的程序员和调用该库的程序员来说更有组织性。我们将在第 14 章“使用 `pub use` 导出方便的公共 API”部分中看另一个 `pub use` 的例子，以及它如何影响您的crate的文档。

![[Pasted image 20240511225406.png]]

在 Cargo.toml 中将 `rand` 添加为一个依赖项告诉 Cargo 从 crates.io 下载 `rand` 包和任何依赖项，并使 `rand` 可用于我们的项目。

然后，为了将 `rand` 的定义引入到我们包的作用域中，我们添加了一行以 crate 的名称 `rand` 开头的 `use` 行，并列出了我们想要引入作用域的项。回想一下第 2 章“生成随机数”部分，在那里我们将 `Rng` trait 引入作用域并调用了 `rand::thread_rng` 函数：

![[Pasted image 20240511225437.png]]

Rust 社区的成员在 crates.io 上提供了许多包，将它们中的任何一个引入到您的包中都需要以下相同的步骤：在您的包的 Cargo.toml 文件中列出它们，并使用 `use` 将它们的项目引入作用域。

请注意，标准 `std` 库也是一个与我们的包外部关联的 crate。由于标准库随 Rust 语言一起发布，我们无需更改 Cargo.toml 来包含 `std` 。但我们需要使用 `use` 来引用它，以将其中的项目引入我们包的范围。例如，使用 `HashMap` ，我们会使用这行代码：

![[Pasted image 20240511225518.png]]
这是一个以 `std` 开头的绝对路径，标准库箱的名称。

### [使用嵌套路径来清理大型 `use` 列表](https://doc.rust-lang.org/book/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#using-nested-paths-to-clean-up-large-use-lists)

如果我们在同一个 crate 或同一个模块中使用多个定义的项目，将每个项目列在单独的行上会占用文件中大量的垂直空间。例如，在猜数字游戏中的这两个语句，将 `std` 中的项目引入作用域：

![[Pasted image 20240511225625.png]]

相反，我们可以使用嵌套路径在一行中将相同的项目引入范围。我们通过指定路径的共同部分，接着两个冒号，然后在花括号中列出路径不同的部分来实现这一点，如清单 7-18 所示。

![[Pasted image 20240511225640.png]]

![[Pasted image 20240511225724.png]]

### [通配符操作符](https://doc.rust-lang.org/book/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#the-glob-operator)

如果我们想要将路径中定义的所有公共项引入作用域，我们可以指定该路径，后跟 `*` 通配符操作符:
![[Pasted image 20240511225812.png]]

这个 `use` 语句将 `std::collections` 中定义的所有公共项引入当前范围。在使用全局操作符时要小心！全局操作符可能会使得很难确定哪些名称在范围内，以及程序中使用的名称是在哪里定义的。

glob 操作符通常在测试时使用，将所有要测试的内容引入 `tests` 模块；我们将在第 11 章的“如何编写测试”部分讨论这一点。glob 操作符有时也作为前奏模式的一部分使用：有关该模式的更多信息，请参阅标准库文档。

## [将模块分离到不同的文件中](https://doc.rust-lang.org/book/ch07-05-separating-modules-into-different-files.html#separating-modules-into-different-files)

将模块分离到不同的文件中 到目前为止，本章中的所有示例都在一个文件中定义了多个模块。当模块变得庞大时，你可能希望将它们的定义移到一个单独的文件中，以使代码更容易导航。

例如，我们从清单 7-17 中的代码开始，该代码有多个餐厅模块。我们将把模块提取到文件中，而不是在 crate 根文件中定义所有模块。在这种情况下，crate 根文件是 src/lib.rs，但此程序也适用于二进制 crates，其 crate 根文件是 src/main.rs。

首先，我们将 front_of_house 模块提取到它自己的文件中。从 front_of_house 模块中移除大括号内的代码，只留下 mod front_of_house; 声明，使 src/lib.rs 包含如清单 7-21 所示的代码。注意，在我们创建 src/front_of_house.rs 文件（见清单 7-22）之前，这将无法编译。

![[Pasted image 20240512085704.png]]

清单 7-21：声明 front_of_house 模块，其主体将在 src/front_of_house.rs 中

接下来，将原来在大括号内的代码放入一个名为 src/front_of_house.rs 的新文件中，如清单 7-22 所示。编译器知道在这个文件中查找代码，因为它在 crate 根中遇到了名为 front_of_house 的模块声明。

![[Pasted image 20240512085817.png]]
清单 7-22：src/front_of_house.rs 中 front_of_house 模块内的定义

注意，在你的模块树中，你只需要使用一次 mod 声明来加载文件。一旦编译器知道文件是项目的一部分（并且由于你放置了 mod 语句，知道代码在模块树中的位置），项目中的其他文件应该使用路径来引用已加载文件的代码，如“在模块树中引用项的路径”部分所覆盖。换句话说，mod 不是你可能在其他编程语言中看到的“include”操作。

接下来，我们将 hosting 模块提取到它自己的文件中。这个过程有点不同，因为 hosting 是 front_of_house 的子模块，而不是根模块的子模块。我们将为 hosting 放置文件的新目录命名为其在模块树中的祖先，这种情况下是 src/front_of_house/。

开始移动 hosting，我们更改 src/front_of_house.rs 只包含 hosting 模块的声明：

文件名：src/front_of_house.rs
![[Pasted image 20240512085954.png]]
然后我们创建一个 src/front_of_house 目录和一个 hosting.rs 文件来包含 hosting 模块中的定义：

文件名：src/front_of_house/hosting.rs
![[Pasted image 20240512090012.png]]
如果我们将 hosting.rs 放在 src 目录中，编译器将期望 hosting.rs 中的代码在 crate 根中声明的 hosting 模块中，而不是声明为 front_of_house 模块的子模块。编译器关于检查哪些文件以及哪些模块的代码的规则意味着目录和文件更紧密地匹配模块树。

### [备用文件路径](https://doc.rust-lang.org/book/ch07-05-separating-modules-into-different-files.html#alternate-file-paths)
到目前为止，我们已经介绍了 Rust 编译器使用的最惯用的文件路径，但 Rust 也支持一种较旧风格的文件路径。

对于在 crate 根中声明的名为 front_of_house 的模块，编译器将在以下位置查找模块的代码：

src/front_of_house.rs（我们讨论过的） 
src/front_of_house/mod.rs（较旧的风格，仍然支持的路径） 

对于是 front_of_house 子模块的名为 hosting 的模块，编译器将在以下位置查找模块的代码：
src/front_of_house/hosting.rs（我们讨论过的内容） src/front_of_house/hosting/mod.rs（较旧的风格，仍然支持的路径） 

如果你对同一个模块使用这两种风格，你会得到一个编译器错误。在同一个项目中对不同模块使用不同风格的混合是允许的，但可能会让浏览你的项目的人感到困惑。

使用命名为 mod.rs 的文件的风格的主要缺点是，你的项目最终可能会有许多名为 mod.rs 的文件，当你同时在编辑器中打开它们时，可能会感到困惑。

我们已将每个模块的代码移到了单独的文件中，模块树保持不变。即使定义位于不同的文件中，eat_at_restaurant 中的函数调用也将照常工作。这种技术让你可以在模块增长时将模块移到新文件中。

注意，src/lib.rs 中的 pub use crate::front_of_house::hosting 语句也没有改变，use 也不会对哪些文件作为 crate 的一部分被编译产生影响。mod 关键字声明模块，Rust 在与模块同名的文件中查找进入该模块的代码。

总结 Rust 允许你将包拆分为多个 crates 和将 crate 拆分为模块，这样你就可以引用在一个模块中定义的项到另一个模块。你可以通过指定绝对或相对路径来做到这一点。这些路径可以通过 use 语句引入作用域，这样你可以在该作用域中多次使用该项时使用更短的路径。模块代码默认是私有的，但你可以通过添加 pub 关键字使定义公开。

在下一章中，我们将看看标准库中的一些集合数据结构，你可以在你整洁有序的代码中使用这些数据结构。

# [常见集合](https://doc.rust-lang.org/book/ch08-00-common-collections.html#common-collections)

Rust 的标准库包含一些非常有用的数据结构，称为集合。大多数其他数据类型表示一个特定的值，但集合可以包含多个值。与内置的数组和元组类型不同，这些集合指向的数据存储在堆上，这意味着数据量在编译时不需要知道，并且可以随着程序运行而增长或缩小。每种类型的集合具有不同的功能和成本，选择适合当前情况的集合是您随着时间发展的技能。在本章中，我们将讨论 Rust 程序中经常使用的三种集合：
1、向量允许您将可变数量的值存储在一起。
2、字符串是字符的集合。我们之前提到过 `String` 类型，但在本章中我们将深入讨论它。
3、哈希映射允许您将值与特定键关联起来。这是更一般的称为映射的数据结构的特定实现。

要了解标准库提供的其他类型的集合，请参阅文档。
我们将讨论如何创建和更新向量、字符串和哈希映射，以及每种的特点。

## [使用向量存储值列表](https://doc.rust-lang.org/book/ch08-01-vectors.html#storing-lists-of-values-with-vectors)

我们将要看的第一种集合类型是 `Vec<T>` ，也被称为向量。向量允许您在单个数据结构中存储多个值，这些值在内存中相邻。向量只能存储相同类型的值。当您有一个项目列表时，例如文件中的文本行或购物车中的商品价格时，它们非常有用。
### [创建新的向量](https://doc.rust-lang.org/book/ch08-01-vectors.html#creating-a-new-vector)

要创建一个新的空向量，我们调用 `Vec::new` 函数，如清单 8-1 所示。
![[Pasted image 20240512092730.png]]
请注意，我们在这里添加了类型注释。因为我们没有向这个向量插入任何值，Rust 不知道我们打算存储什么类型的元素。这是一个重要的观点。
向量使用泛型实现；我们将在第 10 章中介绍如何使用泛型与您自己的类型。现在，知道标准库提供的 `Vec<T>` 类型可以保存任何类型。当我们创建一个用于保存特定类型的向量时，我们可以在尖括号内指定类型。在清单 8-1 中，我们告诉 Rust， `Vec<T>` 中的 `v` 将保存 `i32` 类型的元素。

更常见的是，您将创建一个带有初始值的 `Vec<T>` ，Rust 将推断您想要存储的值的类型，因此您很少需要进行此类型注释。Rust 方便地提供了 `vec!` 宏，它将创建一个包含您提供的值的新向量。清单 8-2 创建一个新的 `Vec<i32>` ，其中包含值 `1` ， `2` 和 `3` 。整数类型是 `i32` ，因为那是默认整数类型，正如我们在第 3 章“数据类型”部分讨论的那样。
![[Pasted image 20240512093919.png]]
因为我们已经给出了初始 `i32` 值，Rust 可以推断 `v` 的类型是 `Vec<i32>` ，因此类型注解是不必要的。接下来，我们将看看如何修改一个向量。

### [更新向量](https://doc.rust-lang.org/book/ch08-01-vectors.html#updating-a-vector)

要创建一个向量，然后向其中添加元素，我们可以使用 `push` 方法，如图[[8-3.png]] 所示。

![[8-3.png]]
与任何变量一样，如果我们想要能够更改其值，我们需要使用 `mut` 关键字使其可变，如第 3 章所讨论的那样。我们放入其中的数字都是 `i32` 类型的，Rust 会从数据中推断出来，因此我们不需要 `Vec<i32>` 注释。

### [矢量的元素阅读](https://doc.rust-lang.org/book/ch08-01-vectors.html#reading-elements-of-vectors)

有两种方法可以引用存储在向量中的值：通过索引或使用 `get` 方法。在以下示例中，我们已经注释了从这些函数返回的值的类型，以提供额外的清晰度。

列出 8-4 显示了在向量中访问值的两种方法，使用索引语法和 `get` 方法。

![[Pasted image 20240512094035.png]]
注意这里的一些细节。我们使用 `2` 的索引值来获取第三个元素，因为向量是按数字索引的，从零开始。使用 `&` 和 `[]` 可以让我们引用索引值处的元素。当我们使用 `get` 方法并将索引作为参数传递时，我们会得到一个 `Option<&T>` ，可以与 `match` 一起使用。

Rust 提供这两种引用元素的方式是为了让你可以选择当尝试使用超出现有元素范围的索引值时程序的行为。例如，让我们看看当我们有一个包含五个元素的向量，然后尝试使用每种技术访问索引为 100 的元素时会发生什么，如清单 8-5 所示。

![[Pasted image 20240512094225.png]]

当我们运行这段代码时，第一个 `[]` 方法会导致程序崩溃，因为它引用了一个不存在的元素。当您希望程序在尝试访问向量末尾之后的元素时崩溃时，最好使用这种方法。

当 `get` 方法传递一个超出向量范围的索引时，它会返回 `None` 而不会导致恐慌。在正常情况下，如果偶尔会发生访问超出向量范围的元素，您可以使用此方法。然后，您的代码将具有处理 `Some(&element)` 或 `None` 的逻辑，如第 6 章所讨论的。例如，索引可能来自输入数字的人。如果他们意外输入一个太大的数字，程序得到一个 `None` 值，您可以告诉用户当前向量中有多少项，并让他们有机会输入有效值。这比因为拼写错误而导致程序崩溃更加用户友好！

当程序具有有效引用时，借用检查器会强制执行所有权和借用规则（在第 4 章中介绍），以确保该引用和对向量内容的任何其他引用保持有效。回想一下规则，即在同一作用域中不能同时拥有可变和不可变引用。该规则适用于清单 8-6 中，在该清单中，我们持有对向量中第一个元素的不可变引用，并尝试向末尾添加一个元素。如果我们在函数中稍后还尝试引用该元素，该程序将无法正常工作：
![[8-6.png]]
![[Pasted image 20240512094639.png]]
清单 8-6 中的代码看起来应该能够正常工作：为什么对第一个元素的引用会关心向量末尾的更改？这个错误是由于向量的工作方式造成的：因为向量将值放在内存中相邻的位置，向向量末尾添加一个新元素可能需要分配新的内存并将旧元素复制到新空间，如果没有足够的空间将所有元素放在当前存储向量的位置。在这种情况下，对第一个元素的引用将指向已释放的内存。借用规则可以防止程序陷入这种情况。

### [在向量中迭代值](https://doc.rust-lang.org/book/ch08-01-vectors.html#iterating-over-the-values-in-a-vector)

要依次访问向量中的每个元素，我们将遍历所有元素，而不是使用索引逐个访问。清单 8-7 显示了如何使用一个 `for` 循环来获取向量中每个元素的不可变引用并打印它们。
![[Pasted image 20240512094742.png]]
我们还可以迭代可变向量中每个元素的可变引用，以便对所有元素进行更改。清单 8-8 中的 `for` 循环将向每个元素添加 `50` 。
![[Pasted image 20240512094803.png]]
要更改可变引用所指向的值，我们必须使用 `*` 解引用运算符来访问 `i` 中的值，然后才能使用 `+=` 运算符。

我们将在第 15 章“使用解引用运算符跟踪指针到值”部分更多地讨论解引用运算符。

在向量上进行迭代，无论是不可变地还是可变地，都是安全的，因为借用检查器的规则。

如果我们尝试在清单 8-7 和清单 8-8 中的循环体中插入或移除项目，我们将会得到一个类似于清单 8-6 中代码的编译器错误。循环持有的向量的引用阻止了整个向量的同时修改。

### [使用枚举来存储多种类型](https://doc.rust-lang.org/book/ch08-01-vectors.html#using-an-enum-to-store-multiple-types)

向量只能存储相同类型的值。这可能会不方便；肯定有需要存储不同类型项目列表的用例。幸运的是，枚举的变体是在同一枚举类型下定义的，因此当我们需要一个类型来表示不同类型的元素时，我们可以定义并使用枚举！

例如，假设我们想要从电子表格中的一行中获取值，在该行中，一些列包含整数，一些包含浮点数，一些包含字符串。我们可以定义一个枚举，其变体将保存不同的值类型，并且所有枚举变体将被视为相同类型：枚举的类型。然后，我们可以创建一个向量来保存该枚举，因此，最终，保存不同类型。我们在清单 8-9 中演示了这一点。
![[8-9.png]]
Rust 需要在编译时知道向量中将有哪些类型，以便准确地了解堆上将需要多少内存来存储每个元素。我们还必须明确指定此向量中允许的类型。如果 Rust 允许一个向量保存任何类型，那么有可能其中一个或多个类型会导致对向量元素执行的操作出现错误。使用枚举加上 `match` 表达式意味着 Rust 将在编译时确保处理每种可能的情况，如第 6 章中讨论的那样。

如果您不知道程序在运行时将获得哪些类型的详尽集合以存储在向量中，则枚举技术将无法工作。相反，您可以使用trait对象，我们将在第 17 章中介绍。

现在我们已经讨论了一些最常见的使用向量的方法，请务必查看标准库中定义的所有许多有用方法的 API 文档。例如，除了 `push` ， `pop` 方法还会移除并返回最后一个元素。

### [释放向量会释放其元素](https://doc.rust-lang.org/book/ch08-01-vectors.html#dropping-a-vector-drops-its-elements)

像任何其他 `struct` 一样，当向量超出范围时会被释放，如清单 8-10 中所注释的那样。

![[8-10.png]]
当向量被释放时，它的所有内容也会被释放，这意味着它保存的整数将被清理。借用检查器确保对向量内容的任何引用仅在向量本身有效时使用。

让我们继续下一个集合类型： `String` ！

## [存储使用字符串的 UTF-8 编码文本](https://doc.rust-lang.org/book/ch08-02-strings.html#storing-utf-8-encoded-text-with-strings)

我们在第 4 章讨论过字符串，但现在我们将更深入地研究它们。新的 Rustaceans 通常会因为三个原因而在字符串上遇到困难：Rust 喜欢暴露可能的错误、字符串是一个比许多程序员认为的更复杂的数据结构，以及 UTF-8。这些因素结合在一起，当你来自其他编程语言时，可能会感到困难。

我们在集合的上下文中讨论字符串，因为字符串被实现为一组字节，再加上一些方法，以在将这些字节解释为文本时提供有用的功能。在本节中，我们将讨论每种集合类型都具有的对 `String` 的操作，比如创建、更新和读取。我们还将讨论 `String` 与其他集合不同的方式，即索引到 `String` 的复杂性，这是由于人类和计算机解释 `String` 数据的差异而引起的。

### [什么是字符串？](https://doc.rust-lang.org/book/ch08-02-strings.html#what-is-a-string)
我们首先定义一下我们所说的字符串是什么。Rust 在核心语言中只有一种字符串类型，即通常以其借用形式 `&str` 出现的字符串切片 `str` 。在第 4 章，我们讨论了字符串切片，它们是对某些 UTF-8 编码的字符串数据的引用，该数据存储在其他地方。例如，字符串字面值存储在程序的二进制文件中，因此它们是字符串切片。

`String` 类型是由 Rust 标准库提供的，而不是编码到核心语言中的，它是一种可增长、可变、拥有的、UTF-8 编码的字符串类型。当 Rustaceans 在 Rust 中提到“字符串”时，他们可能指的是 `String` 或字符串切片 `&str` 类型，而不仅仅是其中的一种类型。尽管本节主要是关于 `String` 的，但在 Rust 的标准库中，这两种类型都被广泛使用，而且 `String` 和字符串切片都是 UTF-8 编码的。

### [创建一个新的字符串](https://doc.rust-lang.org/book/ch08-02-strings.html#creating-a-new-string)

许多与 `Vec<T>` 可用的相同操作也适用于 `String` ，因为 `String` 实际上是一个围绕字节向量的包装器，具有一些额外的保证、限制和功能。一个在 `Vec<T>` 和 `String` 上以相同方式工作的函数示例是 `new` 函数用于创建一个实例，如清单 8-11 所示。
![[8-11.png]]
这行代码创建了一个名为 `s` 的新空字符串，我们可以将数据加载到其中。通常，我们会有一些初始数据，我们想要用它来开始字符串。为此，我们使用 `to_string` 方法，该方法适用于实现 `Display` 特性的任何类型，如字符串字面值所示。清单 8-12 展示了两个示例。
![[8-12.png]]
这段代码创建一个包含 `initial contents` 的字符串。

我们也可以使用函数 `String::from` 从字符串字面量创建 `String` 。清单 8-13 中的代码等同于使用 `to_string` 的清单 8-12 中的代码。

![[8-13.png]]

因为字符串用于很多事情，我们可以使用许多不同的通用 API 来处理字符串，为我们提供了很多选择。其中一些可能看起来是多余的，但它们都有各自的用处！在这种情况下， `String::from` 和 `to_string` 做的是同样的事情，所以你选择哪个取决于风格和可读性。

请记住字符串是 UTF-8 编码的，所以我们可以在其中包含任何正确编码的数据，如图 8-14 所示。

![[8-14.png]]
所有这些都是有效的 `String` 值。

### [更新字符串](https://doc.rust-lang.org/book/ch08-02-strings.html#updating-a-string)

一个 `String` 可以增长并且其内容可以改变，就像一个 `Vec<T>` 的内容一样，如果你往里面添加更多数据。此外，你可以方便地使用 `+` 运算符或 `format!` 宏来连接 `String` 值。

#### [使用 `push_str` 和 `push` 追加字符串](https://doc.rust-lang.org/book/ch08-02-strings.html#appending-to-a-string-with-push_str-and-push)

我们可以通过使用 `push_str` 方法来追加字符串切片来扩展 `String` ，如图 8-15 所示。

![[8-15.png]]
在这两行之后， `s` 将包含 `foobar` 。 `push_str` 方法采用字符串切片，因为我们不一定想要获取参数的所有权。例如，在清单 8-16 中的代码中，我们希望在将其内容附加到 `s1` 后能够使用 `s2` 。
![[8-16.png]]
如果 `push_str` 方法接管了 `s2` 的所有权，我们就无法在最后一行打印其值。但是，这段代码按我们的预期工作！

`push` 方法接受一个单个字符作为参数，并将其添加到 `String` 。清单 8-17 使用 `push` 方法将字母“l”添加到 `String` 中。
![[8-17.png]]
结果， `s` 将包含 `lol` 。

#### [使用 `+` 运算符或 `format!` 宏进行连接](https://doc.rust-lang.org/book/ch08-02-strings.html#concatenation-with-the--operator-or-the-format-macro)

通常，您会想要组合两个现有的字符串。一种方法是使用 `+` 运算符，如清单 8-18 所示。
![[Pasted image 20240512103049.png]]
字符串 `s3` 将包含 `Hello, world!` 。添加后，原因 `s1` 不再有效，我们使用对 `s2` 的引用的原因与调用 `+` 运算符时调用的方法的签名有关。 `+` 运算符使用 `add` 方法，其签名看起来像这样：
![[Pasted image 20240512103108.png]]
在标准库中，您会看到 `add` 使用泛型和关联类型定义。在这里，我们已经用具体类型替换了，这就是当我们用 `String` 值调用这个方法时发生的情况。我们将在第 10 章讨论泛型。这个签名给了我们理解 `+` 运算符的棘手部分所需的线索。

首先， `s2` 有一个 `&` ，这意味着我们正在将第二个字符串的引用添加到第一个字符串中。这是因为 `add` 函数中的 `s` 参数：我们只能将 `&str` 添加到 `String` 中；我们不能将两个 `String` 值相加。但等等—— `&s2` 的类型是 `&String` ，而不是 `&str` ，如 `add` 的第二个参数中指定的那样。那么为什么清单 8-18 会编译通过呢？

我们能够在调用 `add` 时使用 `&s2` 的原因是编译器可以将 `&String` 参数强制转换为 `&str` 。当我们调用 `add` 方法时，Rust 使用了一种解引用强制转换，这里将 `&s2` 转换为 `&s2[..]` 。我们将在第 15 章更深入地讨论解引用强制转换。因为 `add` 不会获取 `s` 参数的所有权，所以在此操作之后 `s2` 仍将是一个有效的 `String` 。

其次，我们可以在签名中看到 `add` 接管了 `self` ，因为 `self` 没有 `&` 。这意味着在清单 8-18 中， `s1` 将被移动到 `add` 调用中，并在此之后将不再有效。因此，尽管 `let s3 = s1 + &s2;` 看起来像会复制两个字符串并创建一个新的字符串，但实际上这个语句实际上接管了 `s1` ，附加了 `s2` 的内容的副本，然后返回结果的所有权。换句话说，它看起来像是在做很多复制，但实际上并非如此；实现比复制更有效率。

如果我们需要连接多个字符串， `+` 运算符的行为会变得难以控制：
![[Pasted image 20240512103251.png]]
在这一点上， `s` 将会是 `tic-tac-toe` 。有了所有的 `+` 和 `"` 字符，很难看出发生了什么。对于更复杂的字符串组合，我们可以使用 `format!` 宏：
![[Pasted image 20240512103320.png]]
这段代码还将 `s` 设置为 `tic-tac-toe` 。 `format!` 宏的工作方式类似于 `println!` ，但不是将输出打印到屏幕，而是返回一个包含内容的 `String` 。使用 `format!` 的代码版本更易阅读，而由 `format!` 宏生成的代码使用引用，因此此调用不会获取任何参数的所有权。

### [字符串索引](https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings)

在许多其他编程语言中，通过索引引用字符串中的单个字符是一种有效且常见的操作。然而，在 Rust 中，如果您尝试使用索引语法访问 `String` 的部分，将会出现错误。考虑清单 8-19 中的无效代码。
![[Pasted image 20240512103404.png]]
![[Pasted image 20240512103414.png]]

错误和注释讲述了这个故事：Rust 字符串不支持索引。但为什么呢？要回答这个问题，我们需要讨论 Rust 如何在内存中存储字符串。

####  [内部表示](https://doc.rust-lang.org/book/ch08-02-strings.html#internal-representation)

在这种情况下， `len` 将是 4，这意味着存储字符串“Hola”的向量长度为 4 字节。当用 UTF-8 编码时，每个字母占用 1 个字节。然而，下一行可能会让你感到惊讶。（请注意，此字符串以大写西里尔字母 Ze 开头，而不是数字 3。）

![[Pasted image 20240512103504.png]]
被问及字符串的长度时，你可能会说 12。实际上，Rust 的答案是 24：这是用 UTF-8 编码“Здравствуйте”所需的字节数，因为该字符串中的每个 Unicode 标量值占用 2 个字节的存储空间。因此，对字符串字节的索引并不总是对应有效的 Unicode 标量值。为了演示，考虑以下无效的 Rust 代码：
![[Pasted image 20240512103619.png]]
您已经知道 `answer` 不会是 `З` ，第一个字母。当以 UTF-8 编码时， `З` 的第一个字节是 `208` ，第二个字节是 `151` ，因此似乎 `answer` 实际上应该是 `208` ，但 `208` 本身不是一个有效的字符。如果用户要求这个字符串的第一个字母，返回 `208` 可能不是用户想要的；然而，这是 Rust 在字节索引 0 上唯一拥有的数据。用户通常不希望返回字节值，即使字符串只包含拉丁字母：如果 `&"hello"[0]` 是一个有效的代码，返回字节值将会是 `104` ，而不是 `h` 。

因此，为了避免返回意外值并导致可能不会立即发现的错误，Rust 根本不编译此代码，并在开发过程的早期防止误解。

#### [字节、标量值和图形簇！哦，我的天！](https://doc.rust-lang.org/book/ch08-02-strings.html#bytes-and-scalar-values-and-grapheme-clusters-oh-my)

关于 UTF-8 的另一个要点是，从 Rust 的角度来看，实际上有三种相关的方式来看待字符串：作为字节、标量值和图形簇（最接近我们所说的字母的东西）。

如果我们看一下用天城文写成的印地语单词“नमस्ते”，它被存储为一个看起来像这样的 `u8` 值的向量：

![[Pasted image 20240512103750.png]]
这是 18 字节，也是计算机最终存储这些数据的方式。如果我们将它们视为 Unicode 标量值，这就是 Rust 的 `char` 类型，这些字节看起来像这样：

['न', 'म', 'स', '्', 'त', 'े']
这里有六个 `char` 值，但第四和第六个不是字母：它们是不能独立理解的变音符号。最后，如果我们将它们视为字形簇，我们会得到一个人称为印地语单词的四个字母：

["न", "म", "स्", "ते"]

Rust 提供了不同的方式来解释计算机存储的原始字符串数据，以便每个程序可以选择其所需的解释，无论数据使用哪种人类语言。

Rust 不允许我们索引到 `String` 以获取一个字符的最后一个原因是，索引操作预期始终需要花费恒定时间（O(1)）。但是使用 `String` 无法保证性能，因为 Rust 需要从开头遍历内容到索引，以确定有多少个有效字符。

### [切片字符串](https://doc.rust-lang.org/book/ch08-02-strings.html#slicing-strings)

经常对字符串进行索引是一个不好的主意，因为不清楚字符串索引操作的返回类型应该是什么：一个字节值，一个字符，一个图形簇，还是一个字符串切片。因此，如果您真的需要使用索引来创建字符串切片，Rust 要求您更加具体。

与使用单个数字的 `[]` 进行索引不同，您可以使用 `[]` 与范围来创建包含特定字节的字符串切片：

![[Pasted image 20240512103916.png]]
在这里， `s` 将是一个包含字符串前 4 个字节的 `&str` 。之前我们提到每个字符是 2 个字节，这意味着 `s` 将是 `Зд` 。

如果我们尝试使用类似 `&hello[0..1]` 这样的方式仅切片字符的部分字节，Rust 会在运行时出现恐慌，就像在向量中访问无效索引时一样：

![[Pasted image 20240512104310.png]]
创建字符串切片时应谨慎使用范围，因为这样做可能会导致程序崩溃。

### [遍历字符串的方法](https://doc.rust-lang.org/book/ch08-02-strings.html#methods-for-iterating-over-strings)
操作字符串片段的最佳方式是明确您想要字符还是字节。对于单个 Unicode 标量值，请使用 `chars` 方法。在“Зд”上调用 `chars` 会分离并返回两个类型为 `char` 的值，您可以迭代结果以访问每个元素：

![[Pasted image 20240512104508.png]]
![[Pasted image 20240512104525.png]]
另外， `bytes` 方法返回每个原始字节，这可能适合您的领域：
![[Pasted image 20240512104556.png]]
这段代码将打印组成该字符串的四个字节：
![[Pasted image 20240512104615.png]]
但请记住，有效的 Unicode 标量值可能由多个字节组成。

从字符串中获取象形簇（grapheme clusters）与 Devanagari 脚本一样复杂，因此标准库不提供此功能。如果您需要此功能，可以在 crates.io 上找到相关的 crate。

### [字符串并不那么简单](https://doc.rust-lang.org/book/ch08-02-strings.html#strings-are-not-so-simple)

总结一下，字符串很复杂。不同的编程语言对如何向程序员展示这种复杂性做出了不同选择。Rust 选择使所有 Rust 程序的默认行为是正确处理 `String` 数据，这意味着程序员需要更多地考虑如何处理 UTF-8 数据。这种权衡暴露了字符串的更多复杂性，这在其他编程语言中并不明显，但它可以避免您在开发生命周期后期处理涉及非 ASCII 字符的错误。

好消息是标准库提供了许多基于 `String` 和 `&str` 类型构建的功能，以帮助正确处理这些复杂情况。请务必查看文档，了解有用的方法，如用于在字符串中搜索的 `contains` 和用于用另一个字符串替换字符串部分的 `replace` 。

让我们转而讨论一些不那么复杂的内容：哈希映射！

## [在哈希映射中存储具有关联值的键](https://doc.rust-lang.org/book/ch08-03-hash-maps.html#storing-keys-with-associated-values-in-hash-maps)

我们常见的集合中最后一个是哈希映射。类型 `HashMap<K, V>` 存储了一个由类型为 `K` 的键映射到类型为 `V` 的值的映射，使用哈希函数确定如何将这些键和值放入内存。许多编程语言支持这种数据结构，但它们通常使用不同的名称，比如哈希、映射、对象、哈希表、字典或关联数组等。

当您想要查找数据而不是使用索引时，哈希映射非常有用，就像您可以使用向量一样，而是使用可以是任何类型的键。例如，在游戏中，您可以在哈希映射中跟踪每个团队的得分，其中每个键是一个团队的名称，值是每个团队的得分。给定一个团队名称，您可以检索其得分。

在本节中，我们将介绍哈希映射的基本 API，但标准库中定义的函数中还有更多好东西。像往常一样，查看标准库文档以获取更多信息。

### [创建一个新的哈希映射](https://doc.rust-lang.org/book/ch08-03-hash-maps.html#creating-a-new-hash-map)
创建一个空的哈希映射的一种方法是使用 `new` 并使用 `insert` 添加元素。在清单 8-20 中，我们正在跟踪两支队伍的得分，它们的名称分别是蓝队和黄队。蓝队从 10 分开始，黄队从 50 分开始。

![[Pasted image 20240512105711.png]]

请注意，我们需要首先从标准库的集合部分 `use` `HashMap` 。在我们三种常见的集合中，这个是最不常用的，因此它不会自动包含在预置范围内的功能中。哈希映射在标准库中也得到的支持较少；例如，没有内置的宏来构建它们。

就像向量一样，哈希映射将它们的数据存储在堆上。这个 `HashMap` 有 `String` 类型的键和 `i32` 类型的值。与向量类似，哈希映射是同质的：所有的键必须与彼此具有相同的类型，所有的值也必须具有相同的类型。

### [在哈希映射中访问值](https://doc.rust-lang.org/book/ch08-03-hash-maps.html#accessing-values-in-a-hash-map)

我们可以通过将键提供给 `get` 方法来从哈希映射中获取值，如清单 8-21 所示。
![[Pasted image 20240512105942.png]]
在这里， `score` 将具有与蓝队相关联的值，结果将是 `10` 。 `get` 方法返回一个 `Option<&V>` ；如果哈希映射中没有该键的值， `get` 将返回 `None` 。该程序通过调用 `copied` 处理 `Option` ，以获取 `Option<i32>` 而不是 `Option<&i32>` ，然后如果 `scores` 没有该键的条目，将 `score` 设置为零。

我们可以以类似于处理向量的方式迭代哈希映射中的每个键/值对，使用 `for` 循环：

![[Pasted image 20240512110020.png]]
这段代码将以任意顺序打印每对
![[Pasted image 20240512110049.png]]
### [哈希映射和所有权](https://doc.rust-lang.org/book/ch08-03-hash-maps.html#hash-maps-and-ownership)

对于实现 `Copy` trait 的类型，比如 `i32` ，值会被复制到哈希映射中。对于拥有所有权的值，比如 `String` ，值会被移动，哈希映射将成为这些值的所有者，如清单 8-22 所示。

![[Pasted image 20240512110222.png]]

在调用 `insert` 将变量 `field_name` 和 `field_value` 移入哈希映射后，我们无法再使用它们。

如果我们将值的引用插入哈希映射中，这些值不会被移动到哈希映射中。引用指向的值必须至少在哈希映射有效时有效。我们将在第 10 章的“使用生命周期验证引用”部分更详细地讨论这些问题。

### [更新哈希映射](https://doc.rust-lang.org/book/ch08-03-hash-maps.html#updating-a-hash-map)

尽管键值对的数量是可增长的，但每个唯一键一次只能关联一个值（但反之不成立：例如，蓝队和黄队都可以在 `scores` 哈希映射中存储值 10）。

当您想要更改哈希映射中的数据时，您必须决定如何处理当一个键已经有一个值分配的情况。您可以用新值替换旧值，完全忽略旧值。您可以保留旧值并忽略新值，只有在键尚未有值时才添加新值。或者您可以将旧值和新值合并。让我们看看如何做到这些！

#### [覆盖一个数值](https://doc.rust-lang.org/book/ch08-03-hash-maps.html#overwriting-a-value)

如果我们将一个键和一个值插入哈希映射，然后再次用不同的值插入相同的键，与该键相关联的值将被替换。尽管清单 8-23 中的代码调用 `insert` 两次，但哈希映射只会包含一个键值对，因为我们两次都插入了蓝队键的值。

![[Pasted image 20240512110723.png]]
这段代码将打印 `{"Blue": 25}` 。 `10` 的原始值已被覆盖。

#### [仅在键不存在时添加键和值](https://doc.rust-lang.org/book/ch08-03-hash-maps.html#adding-a-key-and-value-only-if-a-key-isnt-present)

在哈希映射中常见的操作是检查特定键是否已经存在，如果存在，则保持现有值不变；如果不存在，则插入该键和相应的值。

哈希映射有一个特殊的 API，称为 `entry` ，它以要检查的键作为参数。 `entry` 方法的返回值是一个枚举，称为 `Entry` ，表示可能存在或不存在的值。假设我们想要检查黄队的键是否有与之关联的值。如果没有，我们想要插入值 50，蓝队也是一样。使用 `entry` API，代码如清单 8-24 所示。

![[Pasted image 20240512110812.png]]

如果该键存在，则在 `Entry` 上定义的 `or_insert` 方法被定义为返回对应 `Entry` 键的值的可变引用，如果不存在，则将参数插入为该键的新值并返回新值的可变引用。这种技术比自己编写逻辑更清晰，而且与借用检查器更加协调。

在运行清单 8-24 中的代码时，将打印 `{"Yellow": 50, "Blue": 10}` 。第一次调用 `entry` 将插入黄队的键，值为 50，因为黄队还没有值。第二次调用 `entry` 将不会改变哈希映射，因为蓝队已经有值 10。

#### [根据旧值更新数值](https://doc.rust-lang.org/book/ch08-03-hash-maps.html#updating-a-value-based-on-the-old-value)
哈希映射的另一个常见用例是查找键的值，然后根据旧值更新它。例如，清单 8-25 显示了代码，用于计算文本中每个单词出现的次数。我们使用一个哈希映射，将单词作为键，并递增值以跟踪我们看到该单词的次数。如果这是我们第一次看到一个单词，我们将首先插入值 0。

![[Pasted image 20240512113109.png]]

这段代码将打印 `{"world": 2, "hello": 1, "wonderful": 1}` 。您可能会看到相同的键/值对以不同的顺序打印出来：请回忆“访问哈希映射中的值”部分，哈希映射的迭代是以任意顺序进行的。

`split_whitespace` 方法返回一个迭代器，该迭代器遍历由空格分隔的值的子切片。 `or_insert` 方法返回指定键的可变引用（ `&mut V` ）。在这里，我们将这个可变引用存储在 `count` 变量中，因此为了对该值进行赋值，我们必须首先使用星号（ `*` ）对 `count` 进行解引用。可变引用在 `for` 循环结束时超出作用域，因此所有这些更改都是安全的，并且符合借用规则。

### [哈希函数](https://doc.rust-lang.org/book/ch08-03-hash-maps.html#hashing-functions)
默认情况下， `HashMap` 使用一种名为 SipHash 的哈希函数，可以提供对涉及哈希表的拒绝服务（DoS）攻击的抵抗力 [1](https://doc.rust-lang.org/book/ch08-03-hash-maps.html#siphash) 。这并非是最快的哈希算法，但为了更好的安全性而降低性能的权衡是值得的。如果您分析您的代码并发现默认哈希函数对您的目的来说太慢，您可以通过指定不同的哈希器来切换到另一个函数。哈希器是实现 `BuildHasher` 特质的类型。我们将在第 10 章讨论特质以及如何实现它们。您不一定需要从头开始实现自己的哈希器；crates.io 上有其他 Rust 用户共享的库，提供实现许多常见哈希算法的哈希器。

## [摘要](https://doc.rust-lang.org/book/ch08-03-hash-maps.html#summary)
向量、字符串和哈希映射将在程序中提供大量必要的功能，当您需要存储、访问和修改数据时。现在您应该能够解决以下一些练习：

给定一个整数列表，使用向量并返回列表的中位数（排序后，位于中间位置的值）和众数（出现频率最高的值；哈希映射在这里会很有帮助）。

将字符串转换为猪拉丁文。每个单词的第一个辅音字母移动到单词的末尾，并添加“ay”，因此“first”变成“irst-fay”。以元音字母开头的单词末尾添加“hay”（“apple”变成“apple-hay”）。请记住有关 UTF-8 编码的细节！

使用哈希映射和向量，创建一个文本界面，允许用户将员工姓名添加到公司的部门中。例如，“将 Sally 添加到工程部”或“将 Amir 添加到销售部”。然后让用户按部门按字母顺序检索部门中所有人员或公司中所有人员的列表。

标准库 API 文档描述了向量、字符串和哈希映射具有的方法，这些方法对这些练习很有帮助！

我们正在进入更复杂的程序，其中操作可能会失败，所以现在正是讨论错误处理的绝佳时机。我们接下来会讨论这个话题！

# [Error Handling](https://doc.rust-lang.org/book/ch09-00-error-handling.html#error-handling)

错误处理 在软件中，错误是不可避免的现象，因此 Rust 提供了许多特性来处理出现问题的情况。在很多情况下，Rust 要求你在代码编译之前认可错误的可能性并采取一些措施。这一要求通过确保你在代码部署到生产环境之前发现并适当处理错误，使得你的程序更加健壮！

Rust 将错误分为两大类：可恢复的错误和不可恢复的错误。对于可恢复的错误，例如文件未找到错误，我们通常只希望向用户报告问题并重试操作。不可恢复的错误总是程序错误的征兆，比如尝试访问数组末尾之外的位置，因此我们希望立即停止程序。

大多数语言不区分这两种错误，并以相同的方式处理它们，使用如异常等机制。 #Rust没有异常。 相反，它使用类型 Result<T, E> 来处理可恢复的错误，以及当程序遇到不可恢复的错误时停止执行的宏 panic!。本章首先讨论调用 panic!，然后讨论返回 Result<T, E> 值。此外，我们还将探讨在决定是尝试从错误中恢复还是停止执行时需要考虑的因素。

## [与 `panic!` 相关的不可恢复错误](https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html#unrecoverable-errors-with-panic)

有时候，在您的代码中会发生一些糟糕的事情，而您无能为力。在这些情况下，Rust 有 `panic!` 宏。实际上，有两种方法可以引发恐慌：通过执行导致我们的代码恐慌的操作（例如访问数组超出末尾）或者显式调用 `panic!` 宏。在这两种情况下，我们的程序会发生恐慌。默认情况下，这些恐慌会打印失败消息，展开，清理堆栈并退出。通过环境变量，您还可以让 Rust 在发生恐慌时显示调用堆栈，以便更容易追踪恐慌的源头。

### [在恐慌时展开堆栈或中止响应](https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html#unwinding-the-stack-or-aborting-in-response-to-a-panic)

默认情况下，当发生恐慌时，程序会开始展开，这意味着 Rust 会沿着堆栈向上走，并清理遇到的每个函数的数据。然而，这种回溯和清理是很多工作。因此，Rust 允许您选择立即中止的替代方案，这样可以在不清理的情况下结束程序。

程序使用的内存将需要由操作系统清理。如果您的项目需要尽可能地减小生成的二进制文件大小，您可以通过在 Cargo.toml 文件的适当部分添加 `panic = 'abort'` 来从展开切换到中止。例如，如果您想在发布模式下发生恐慌时中止，添加以下内容：
```
[profile.release] 
panic = 'abort'
```
让我们在一个简单的程序中尝试调用 `panic!` ：
![[Pasted image 20240512142730.png]]
![[Pasted image 20240512142748.png]]
对 `panic!` 的调用导致最后两行中包含的错误消息。第一行显示我们的恐慌消息以及恐慌发生的源代码位置：src/main.rs:2:5 表示这是我们的 src/main.rs 文件的第二行，第五个字符。

在这种情况下，指示的行是我们代码的一部分，如果我们转到该行，我们会看到 `panic!` 宏调用。在其他情况下， `panic!` 调用可能在我们的代码调用的代码中，错误消息报告的文件名和行号将是其他人的代码，其中调用了 `panic!` 宏，而不是最终导致 `panic!` 调用的我们代码的行。我们可以使用 `panic!` 调用来自的函数的回溯来找出导致问题的我们代码的部分。接下来我们将更详细地讨论回溯。

### [使用 `panic!` 回溯](https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html#using-a-panic-backtrace)

让我们看另一个例子，看看当一个 `panic!` 调用来自库，因为我们代码中的错误而不是来自我们代码直接调用宏时会发生什么。清单 9-1 中有一些代码，尝试访问超出有效索引范围的向量中的索引。

![[Pasted image 20240512143000.png]]

在这里，我们试图访问我们向量的第 100 个元素（因为索引从零开始，所以在索引 99 处），但向量只有 3 个元素。在这种情况下，Rust 会发生恐慌。使用 `[]` 应该返回一个元素，但如果传递一个无效的索引，这里没有 Rust 可以返回的正确元素。

在 C 语言中，尝试读取数据结构末尾之外的数据是未定义行为。您可能会得到内存中对应于数据结构中该元素的位置的内容，尽管该内存并不属于该结构。这被称为缓冲区过读，如果攻击者能够以某种方式操纵索引来读取存储在数据结构之后不应被允许读取的数据，可能会导致安全漏洞。

为了保护您的程序免受这种漏洞的影响，如果您尝试读取一个不存在的索引处的元素，Rust 将停止执行并拒绝继续。让我们试一试：
![[Pasted image 20240512143144.png]]

这个错误指向我们的 `main.rs` 的第 4 行，我们尝试访问索引 99。下一个注释行告诉我们，我们可以设置 `RUST_BACKTRACE` 环境变量来获取导致错误的确切回溯。回溯是到达这一点的所有函数的列表。

在 Rust 中，回溯的工作方式与其他语言相同：阅读回溯的关键是从顶部开始阅读，直到看到您编写的文件。那就是问题起源的地方。在该位置上面的行是您的代码调用的代码；在下面的行是调用您的代码的代码。这些前后行可能包括核心 Rust 代码、标准库代码或您正在使用的 crate。让我们尝试通过将 `RUST_BACKTRACE` 环境变量设置为除 0 以外的任何值来获取回溯。清单 9-2 显示了类似于您将看到的输出。

![[Pasted image 20240512143120.png]]
这是很多输出！您看到的确切输出可能会有所不同，这取决于您的操作系统和 Rust 版本。为了获得带有此信息的回溯，必须启用调试符号。在这里使用 `cargo build` 或 `cargo run` 而不使用 `--release` 标志时，默认情况下启用调试符号。

在清单 9-2 的输出中，回溯的第 6 行指向了我们项目中引起问题的那一行：src/main.rs 的第 4 行。如果我们不希望程序发生 panic，我们应该从第一行提到我们编写的文件开始调查。在清单 9-1 中，我们故意编写了会导致 panic 的代码，修复 panic 的方法是不要请求超出向量索引范围的元素。将来当您的代码发生 panic 时，您需要弄清楚代码采取了什么值来导致 panic 以及代码应该做什么。

我们将在本章后面的“ `panic!` 还是不 `panic!` ”部分回顾 `panic!` ，讨论何时应该以及何时不应该使用 `panic!` 来处理错误条件。接下来，我们将看看如何使用 `Result` 来从错误中恢复。

## [使用 `Result` 可恢复的错误](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#recoverable-errors-with-result)

大多数错误并不严重到需要程序完全停止。有时，当一个函数失败时，可能是你可以轻松解释和响应的原因。例如，如果尝试打开一个文件，但由于文件不存在而操作失败，你可能希望创建该文件而不是终止进程。

请回顾第二章“使用 `Result` 处理潜在失败”中， `Result` 枚举被定义为具有两个变体，即 `Ok` 和 `Err` ，如下所示：
![[Pasted image 20240512143338.png]]
`T` 和 `E` 是泛型类型参数：我们将在第十章更详细地讨论泛型。现在你需要知道的是， `T` 代表在 `Ok` 变体的成功情况下将返回的值的类型， `E` 代表在 `Err` 变体的失败情况下将返回的错误的类型。因为 `Result` 有这些泛型类型参数，我们可以在许多不同情况下使用 `Result` 类型和定义在其上的函数，其中我们想要返回的成功值和错误值可能不同。

让我们调用一个可能失败的函数，该函数返回一个 `Result` 值。在清单 9-3 中，我们尝试打开一个文件。

![[Pasted image 20240512143410.png]]
`File::open` 的返回类型是 `Result<T, E>` 。
泛型参数 `T` 已由 `File::open` 的实现填充为成功值的类型 `std::fs::File` ，即文件句柄。
错误值中使用的 `E` 的类型是 `std::io::Error` 。
这个返回类型意味着对 `File::open` 的调用可能成功并返回一个我们可以读取或写入的文件句柄。
函数调用也可能失败：例如，文件可能不存在，或者我们可能没有权限访问文件。 
`File::open` 函数需要一种方式告诉我们它是成功还是失败，并同时给我们文件句柄或错误信息。
这些信息正是 `Result` 枚举传达的内容。

在 `File::open` 成功的情况下，变量 `greeting_file_result` 中的值将是一个包含文件句柄的 `Ok` 实例。在失败的情况下， `greeting_file_result` 中的值将是一个包含更多关于发生的错误类型的信息的 `Err` 实例。

我们需要在列表 9-3 的代码中添加内容，根据 `File::open` 返回的值执行不同的操作。列表 9-4 展示了一种处理 `Result` 的方法，使用了我们在第 6 章讨论过的基本工具，即 `match` 表达式。
![[Pasted image 20240512143934.png]]

请注意，与 `Option` 枚举一样， `Result` 枚举及其变体已被引入到预设范围中，因此我们在 `match` 分支中不需要在 `Ok` 和 `Err` 变体之前指定 `Result::` 。

当结果为 `Ok` 时，此代码将从 `Ok` 变体中返回内部 `file` 值，然后我们将该文件句柄值分配给变量 `greeting_file` 。在 `match` 之后，我们可以使用文件句柄进行读取或写入。

`match` 的另一个分支处理了当我们从 `File::open` 得到一个 `Err` 值的情况。在这个例子中，我们选择调用 `panic!` 宏。如果在我们当前目录中没有名为 hello.txt 的文件并且运行此代码，我们将从 `panic!` 宏看到以下输出：
![[Pasted image 20240512144015.png]]
通常情况下，这个输出准确告诉我们出了什么问题。

### [在不同错误上匹配](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#matching-on-different-errors)
在清单 9-4 中的代码将无论原因如何都会失败。然而，我们希望针对不同的失败原因采取不同的操作：如果 `File::open` 失败是因为文件不存在，我们希望创建该文件并返回新文件的句柄。如果 `File::open` 因为其他原因失败，例如因为我们没有权限打开文件，我们仍希望代码像在清单 9-4 中那样执行。为此，我们添加了一个内部 `match` 表达式，如清单 9-5 所示。

![[Pasted image 20240512144048.png]]
`File::open` 在 `Err` 变体内返回的值类型是 `io::Error` ，这是标准库提供的一个结构体。这个结构体有一个方法 `kind` ，我们可以调用它来获取一个 `io::ErrorKind` 值。枚举 `io::ErrorKind` 由标准库提供，其中的变体代表可能由 `io` 操作导致的不同类型的错误。我们想要使用的变体是 `ErrorKind::NotFound` ，表示我们尝试打开的文件尚不存在。因此我们对 `greeting_file_result` 进行匹配，但同时也在 `error.kind()` 上进行内部匹配。

我们想要在内部匹配中检查的条件是 `error.kind()` 返回的值是否是 `ErrorKind` 枚举的 `NotFound` 变体。如果是，我们尝试使用 `File::create` 创建文件。然而，由于 `File::create` 也可能失败，我们需要在内部 `match` 表达式中有第二个分支。当文件无法创建时，会打印不同的错误消息。外部 `match` 的第二个分支保持不变，因此除了缺少文件错误之外的任何错误都会导致程序崩溃。

### [使用 `Result<T, E>` 的替代方案](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#alternatives-to-using-match-with-resultt-e)

这是很多 `match` ！ `match` 表达式非常有用，但也很原始。在第 13 章，您将学习有关闭包的知识，它们与 `Result<T, E>` 上定义的许多方法一起使用。在处理代码中的 `Result<T, E>` 值时，这些方法可能比使用 `match` 更简洁。

例如，这里是另一种写法，与列表 9-5 中显示的逻辑相同，这次使用闭包和 `unwrap_or_else` 方法：
![[Pasted image 20240512144153.png]]
尽管这段代码的行为与清单 9-5 相同，但它不包含任何 `match` 表达式，更易阅读。在阅读完第 13 章后回到这个例子，并查阅标准库文档中的 `unwrap_or_else` 方法。当处理错误时，许多这样的方法可以简化庞大的嵌套 `match` 表达式。

### [错误恐慌的快捷键： `unwrap` 和 `expect`](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#shortcuts-for-panic-on-error-unwrap-and-expect)
使用 `match` 足够好，但可能有点啰嗦，而且并不总是能很好地传达意图。 `Result<T, E>` 类型上定义了许多辅助方法，用于执行各种更具体的任务。 `unwrap` 方法是一个快捷方法，实现方式与我们在列表 9-4 中编写的 `match` 表达式类似。如果 `Result` 值是 `Ok` 变体， `unwrap` 将返回 `Ok` 中的值。如果 `Result` 是 `Err` 变体， `unwrap` 将为我们调用 `panic!` 宏。以下是 `unwrap` 的示例：

![[Pasted image 20240512144227.png]]

如果我们在没有 hello.txt 文件的情况下运行此代码，我们将看到来自 `unwrap` 方法生成的 `panic!` 调用的错误消息:
![[Pasted image 20240512144250.png]]

同样， `expect` 方法也让我们选择 `panic!` 错误消息。使用 `expect` 而不是 `unwrap` 并提供良好的错误消息可以传达您的意图，并使追踪 panic 源头更容易。 `expect` 的语法如下：
![[Pasted image 20240512144806.png]]
我们使用 `expect` 与 `unwrap` 相同的方式：返回文件句柄或调用 `panic!` 宏。 `expect` 在调用 `panic!` 时使用的错误消息将是我们传递给 `expect` 的参数，而不是 `unwrap` 使用的默认 `panic!` 消息。以下是示例：
![[Pasted image 20240512144822.png]]
在生产质量的代码中，大多数 Rustaceans 选择 `expect` 而不是 `unwrap` ，并提供更多关于为什么操作预期总是成功的上下文。这样，如果你的假设被证明是错误的，你就有更多信息可以用于调试。

### [传播错误](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#propagating-errors)
当函数的实现调用可能失败的内容时，可以将错误返回给调用代码，让其决定如何处理错误。这被称为错误传播，可以给调用代码更多控制权，因为调用代码可能包含更多信息或逻辑，决定了如何处理错误，而这些信息可能比你在代码上下文中拥有的信息更多。

例如，清单 9-6 显示了一个从文件中读取用户名的函数。如果文件不存在或无法读取，该函数将把这些错误返回给调用该函数的代码。

![[Pasted image 20240512144925.png]]
这个函数可以用更简短的方式来编写，但我们将首先手动完成大部分工作，以便探索错误处理；最后，我们将展示更简短的方式。让我们先看看函数的返回类型： `Result<String, io::Error>` 。这意味着函数返回的是类型为 `Result<T, E>` 的值，其中泛型参数 `T` 已经填充为具体类型 `String` ，泛型类型 `E` 已经填充为具体类型 `io::Error` 。

如果此函数成功执行且没有任何问题，调用此函数的代码将收到一个 `Ok` 值，其中包含此函数从文件中读取的 `String` ——用户名。如果此函数遇到任何问题，调用代码将收到一个 `Err` 值，其中包含一个 `io::Error` 实例，其中包含有关问题的更多信息。我们选择 `io::Error` 作为此函数的返回类型，因为这恰好是我们在此函数体中调用的两个可能失败的操作返回的错误值的类型： `File::open` 函数和 `read_to_string` 方法。

该函数的主体从调用 `File::open` 函数开始。然后，我们使用类似于列表 9-4 中的 `match` 的 `match` 处理 `Result` 值。如果 `File::open` 成功，模式变量 `file` 中的文件句柄将成为可变变量 `username_file` 中的值，函数将继续执行。在 `Err` 情况下，我们不会调用 `panic!` ，而是使用 `return` 关键字完全提前退出函数，并将 `File::open` 中的错误值（现在在模式变量 `e` 中）传递回调用代码作为该函数的错误值。

因此，如果我们在 `username_file` 中有一个文件句柄，那么该函数将在变量 `username` 中创建一个新的 `String` ，并调用 `read_to_string` 方法来读取文件句柄中的内容到 `username` 中。 `read_to_string` 方法也会返回一个 `Result` ，因为它可能会失败，即使 `File::open` 成功了。因此，我们需要另一个 `match` 来处理这个 `Result` ：如果 `read_to_string` 成功，那么我们的函数就成功了，并且我们返回现在在 `username` 中的文件中的用户名，用 `Ok` 包装起来。如果 `read_to_string` 失败，我们以与我们处理 `File::open` 的返回值的 `match` 中返回错误值的方式返回错误值。然而，我们不需要明确地说 `return` ，因为这是函数中的最后一个表达式。

调用此代码的代码将处理包含用户名的 `Ok` 值或包含 `io::Error` 的 `Err` 值。由调用代码决定如何处理这些值。如果调用代码获得 `Err` 值，它可以调用 `panic!` 并使程序崩溃，使用默认用户名，或者从文件之外的其他地方查找用户名，例如。我们没有足够的信息来了解调用代码实际上想要做什么，因此我们将所有成功或错误信息向上传播，以便适当处理。

在 Rust 中，这种错误传播模式是如此常见，以至于 Rust 提供了问号运算符来简化这一过程。

#### [传播错误的快捷方式： `?` 运算符](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator)

在示例 9-7 中展示了一个与示例 9-6 中具有相同功能的 `read_username_from_file` 实现，但此实现使用了 `?` 运算符。

![[Pasted image 20240512150024.png]]
在一个 `Result` 值后面放置的 `?` 被定义为几乎与我们在列表 9-6 中定义的处理 `Result` 值的 `match` 表达式相同的方式工作。如果 `Result` 的值是 `Ok` ，那么 `Ok` 中的值将从此表达式返回，程序将继续执行。如果值是 `Err` ，那么 `Err` 将从整个函数返回，就好像我们使用了 `return` 关键字一样，因此错误值会传播到调用代码。

在列表 9-6 中， `match` 表达式和 `?` 运算符之间存在差异：对于调用 `?` 运算符的错误值，会经过标准库中 `From` trait 中定义的 `from` 函数进行转换，用于将一个类型的值转换为另一个类型。当 `?` 运算符调用 `from` 函数时，接收到的错误类型会被转换为当前函数返回类型中定义的错误类型。当一个函数返回一个错误类型来表示函数可能失败的所有方式时，即使部分失败的原因可能有很多不同的情况，这是很有用的。

例如，我们可以将清单 9-7 中的 `read_username_from_file` 函数更改为返回我们定义的自定义错误类型 `OurError` 。如果我们还定义 `impl From<io::Error> for OurError` 来从 `io::Error` 构造 `OurError` 的实例，那么 `read_username_from_file` 主体中的 `?` 操作符调用将调用 `from` 并转换错误类型，而无需向函数添加任何其他代码。

在列表 9-7 的上下文中， `File::open` 调用末尾的 `?` 将把 `Ok` 中的值返回给变量 `username_file` 。如果发生错误， `?` 运算符将提前退出整个函数，并给调用代码任何 `Err` 值。相同的情况也适用于 `read_to_string` 调用末尾的 `?` 。

`?` 运算符消除了很多样板代码，使得这个函数的实现更简单。我们甚至可以在 `?` 之后立即链接方法调用，进一步缩短这段代码，如清单 9-8 所示。

![[Pasted image 20240512150306.png]]
我们已将在 `username` 中创建新 `String` 的过程移至函数的开头；这部分没有改变。我们不再创建变量 `username_file` ，而是直接将 `read_to_string` 的调用链接到 `File::open("hello.txt")?` 的结果上。在 `read_to_string` 调用的末尾仍然有一个 `?` ，并且在 `File::open` 和 `read_to_string` 都成功时，我们仍然返回一个包含 `username` 的 `Ok` 值，而不是返回错误。功能与 9-6 和 9-7 清单中的相同；这只是一种不同、更符合人体工程学的写法。

清单 9-9 显示了使用 `fs::read_to_string` 来进一步缩短这个过程的方法。

![[Pasted image 20240512150516.png]]

将文件读取为字符串是一种相当常见的操作，因此标准库提供了方便的 `fs::read_to_string` 函数，它打开文件，创建一个新的 `String` ，读取文件的内容，将内容放入该 `String` ，然后返回它。当然，使用 `fs::read_to_string` 并没有给我们解释所有的错误处理的机会，所以我们首先用更长的方式做了。

#### [`?` 运算符可以使用的地方](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used)
`?` 运算符只能在返回类型与 `?` 上使用的值兼容的函数中使用。这是因为 `?` 运算符被定义为以与我们在列表 9-6 中定义的 `match` 表达式相同的方式提前返回函数中的值。在列表 9-6 中， `match` 使用了一个 `Result` 值，而提前返回的分支返回了一个 `Err(e)` 值。函数的返回类型必须是一个 `Result` ，以便与这个 `return` 兼容。

在列表 9-10 中，让我们看看如果我们在一个 `main` 函数中使用 `?` 运算符，并且返回类型与我们在 `?` 上使用的值的类型不兼容时会得到什么错误：

![[Pasted image 20240512150625.png]]
这段代码打开一个文件，可能会失败。 `?` 操作符跟在 `File::open` 返回的 `Result` 值后面，但这个 `main` 函数的返回类型是 `()` ，而不是 `Result` 。当我们编译这段代码时，会得到以下错误消息：

![[Pasted image 20240512150645.png]]
这个错误指出我们只能在返回 `Result` 、 `Option` 或另一个实现了 `FromResidual` 的类型的函数中使用 `?` 运算符。

要修复错误，你有两个选择。一个选择是将函数的返回类型更改为与你正在使用 `?` 运算符的值兼容，只要没有任何限制阻止这样做。另一种技术是使用 `match` 或 `Result<T, E>` 方法之一来以适当的方式处理 `Result<T, E>` 。

错误消息还提到 `?` 也可以与 `Option<T>` 值一起使用。与在 `Result` 上使用 `?` 一样，您只能在返回 `Option` 的函数中使用 `?` 在 `Option` 上。当在 `Option<T>` 上调用 `?` 运算符时，其行为类似于在 `Result<T, E>` 上调用时的行为：如果值为 `None` ，则 `None` 将从该点提前从函数中返回。如果值为 `Some` ，则 `Some` 中的值是表达式的结果值，函数继续。清单 9-11 中有一个示例函数，该函数查找给定文本中第一行的最后一个字符：

![[Pasted image 20240512160417.png]]
这个函数返回 `Option<char>` ，因为可能存在一个字符，但也可能不存在。这段代码接受 `text` 字符串切片参数，并在其上调用 `lines` 方法，返回字符串中每行的迭代器。因为这个函数想要检查第一行，它调用迭代器上的 `next` 来获取迭代器中的第一个值。如果 `text` 是空字符串，对 `next` 的调用将返回 `None` ，在这种情况下我们使用 `?` 来停止并从 `last_char_of_first_line` 返回 `None` 。如果 `text` 不是空字符串， `next` 将返回一个 `Some` 值，其中包含 `text` 中第一行的字符串切片。

`?` 提取字符串切片，然后我们可以在该字符串切片上调用 `chars` 以获得其字符的迭代器。我们对第一行中的最后一个字符感兴趣，因此我们调用 `last` 来返回迭代器中的最后一项。这是一个 `Option` ，因为第一行可能是空字符串，例如如果 `text` 以空行开头但其他行有字符，如 `"\nhi"` 。然而，如果第一行有最后一个字符，它将在 `Some` 变体中返回。中间的 `?` 运算符为我们提供了一种简洁的方式来表达这种逻辑，使我们能够在一行中实现该函数。如果我们不能在 `Option` 上使用 `?` 运算符，我们将不得不使用更多的方法调用或 `match` 表达式来实现这种逻辑。

请注意，在返回 `Result` 的函数中，您可以在 `Result` 上使用 `?` 运算符，在返回 `Option` 的函数中，您可以在 `Option` 上使用 `?` 运算符，但不能混合使用。 `?` 运算符不会自动将 `Result` 转换为 `Option` 或反之亦然；在这些情况下，您可以使用 `Result` 上的 `ok` 方法或 `Option` 上的 `ok_or` 方法来显式进行转换。

到目前为止，我们使用的所有 `main` 函数都返回 `()` 。 `main` 函数很特殊，因为它是可执行程序的入口和出口点，并且对于程序表现如预期，其返回类型有一定限制。

幸运的是， `main` 也可以返回一个 `Result<(), E>` 。清单 9-12 中包含了清单 9-10 的代码，但我们已将 `main` 的返回类型更改为 `Result<(), Box<dyn Error>>` ，并在末尾添加了一个返回值 `Ok(())` 。现在这段代码将会编译通过：

![[Pasted image 20240512160656.png]]

第 `Box<dyn Error>` 种类型是一个特质对象，我们将在第 17 章“使用允许不同类型值的特质对象”部分讨论它。目前，你可以将 `Box<dyn Error>` 理解为“任何类型的错误”。在 `main` 函数中对 `Result` 值使用 `?` ，并且使用错误类型 `Box<dyn Error>` 是允许的，因为它允许任何 `Err` 值提前返回。尽管这个 `main` 函数的主体只会返回类型为 `std::io::Error` 的错误，但通过指定 `Box<dyn Error>` ，即使在 `main` 的主体中添加了返回其他错误的代码，这个签名仍将保持正确。

当一个 `main` 函数返回 `Result<(), E>` 时，如果 `main` 返回 `Ok(())` ，可执行文件将以 `0` 的值退出；如果 `main` 返回一个 `Err` 值，则以非零值退出。用 C 编写的可执行文件在退出时返回整数：成功退出的程序返回整数 `0` ，出错的程序返回除 `0` 之外的整数。Rust 也从可执行文件中返回整数，以符合这一约定。

`main` 函数可能返回任何实现了 `std::process::Termination` 特质的类型，该特质包含一个返回 `ExitCode` 的函数 `report` 。请查阅标准库文档，了解如何为您自己的类型实现 `Termination` 特质的更多信息。

现在我们已经讨论了如何调用 `panic!` 或返回 `Result` 的细节，让我们回到如何决定在哪些情况下使用哪种的话题。

## [是否 `panic!` 还是不 `panic!`](https://doc.rust-lang.org/book/ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic)

那么，当您应该调用 `panic!` 以及何时应该返回 `Result` 时，您如何决定呢？当代码发生恐慌时，没有办法恢复。您可以为任何错误情况调用 `panic!` ，无论是否有可能恢复，但这样做意味着您代表调用代码做出了一个不可恢复的决定。当您选择返回 `Result` 值时，您为调用代码提供了选择。调用代码可以选择以适合其情况的方式尝试恢复，或者可以决定在这种情况下 `Err` 值是不可恢复的，因此可以调用 `panic!` 并将您可恢复的错误转变为不可恢复的错误。因此，在定义可能失败的函数时，返回 `Result` 是一个很好的默认选择。

在诸如示例、原型代码和测试等情况下，编写导致恐慌而不是返回 `Result` 的代码更为合适。让我们探讨原因，然后讨论编译器无法判断失败是否不可能的情况，但您作为人类可以。本章将以一些关于如何决定在库代码中是否恐慌的一般准则结束。

### [示例、原型代码和测试](https://doc.rust-lang.org/book/ch09-03-to-panic-or-not-to-panic.html#examples-prototype-code-and-tests)

当您编写一个示例来说明某个概念时，包括健壮的错误处理代码可能会使示例不够清晰。在示例中，人们理解调用可能会发生恐慌的方法，比如 `unwrap` ，是作为您希望应用程序处理错误的方式的占位符，这可能会根据代码的其余部分而有所不同。

同样，在原型设计时， `unwrap` 和 `expect` 方法非常方便，在您准备好决定如何处理错误之前。它们在您的代码中留下清晰的标记，以便在准备使程序更加健壮时使用。

如果测试中的方法调用失败，您希望整个测试失败，即使该方法不是正在测试的功能。因为 `panic!` 是测试标记为失败的方式，调用 `unwrap` 或 `expect` 正是应该发生的。

### [编译器拥有更多信息的情况](https://doc.rust-lang.org/book/ch09-03-to-panic-or-not-to-panic.html#cases-in-which-you-have-more-information-than-the-compiler)

当您有一些其他逻辑来确保 `Result` 将具有 `Ok` 值时，调用 `unwrap` 或 `expect` 也是合适的，但这种逻辑并非编译器能理解的。您仍然会有一个 `Result` 值需要处理：您调用的任何操作仍然有可能在一般情况下失败，即使在您特定情况下逻辑上不可能失败。如果您可以通过手动检查代码来确保永远不会有 `Err` 变体，那么调用 `unwrap` 是完全可以接受的，甚至最好在 `expect` 文本中记录您认为永远不会有 `Err` 变体的原因。这里是一个例子：

![[Pasted image 20240512161141.png]]

我们通过解析一个硬编码字符串来创建一个 `IpAddr` 实例。我们可以看到 `127.0.0.1` 是一个有效的 IP 地址，因此在这里使用 `expect` 是可以接受的。然而，拥有一个硬编码的有效字符串并不会改变 `parse` 方法的返回类型：我们仍然会得到一个 `Result` 值，并且编译器仍然会要求我们处理 `Result` ，就好像 `Err` 变体是可能的，因为编译器并不聪明到能够看到这个字符串总是一个有效的 IP 地址。如果 IP 地址字符串来自用户而不是硬编码到程序中，因此可能失败，我们肯定希望以更健壮的方式处理 `Result` 。提及这个 IP 地址是硬编码的假设将促使我们在将来如果需要从其他来源获取 IP 地址时，将 `expect` 更改为更好的错误处理代码。

### [错误处理指南](https://doc.rust-lang.org/book/ch09-03-to-panic-or-not-to-panic.html#guidelines-for-error-handling)

当您的代码可能处于糟糕状态时，最好让代码发生恐慌。在这种情况下，糟糕状态是指某些假设、保证、合同或不变量被打破的情况，例如当无效值、矛盾值或缺失值被传递给您的代码时，再加上以下一项或多项：

糟糕状态是意外的，而不是可能偶尔发生的事情，比如用户以错误格式输入数据。

在此之后，您的代码需要依赖于不处于这种糟糕状态，而不是在每一步都检查问题。

您使用的类型中没有很好的方法来编码这些信息。我们将在第 17 章“将状态和行为编码为类型”部分中通过一个示例来说明我们的意思。

如果有人调用您的代码并传递不合理的值，最好返回一个错误，以便库的用户可以决定在这种情况下要做什么。然而，在继续可能不安全或有害的情况下，最好的选择可能是调用 `panic!` 并警告使用您的库的人存在其代码中的错误，以便他们在开发过程中修复它。类似地，如果您调用的是您无法控制的外部代码，并且它返回一个您无法修复的无效状态，通常是适当的。

然而，当失败是预期的时，返回 `Result` 比进行 `panic!` 调用更合适。例如，解析器提供了格式不正确的数据或 HTTP 请求返回指示您已达到速率限制的状态。在这些情况下，返回 `Result` 表示失败是一个预期可能性，调用代码必须决定如何处理。

当您的代码执行可能使用户处于风险中的操作时，您的代码应该首先验证这些值是否有效，如果值无效，则发生恐慌。这主要是出于安全原因：尝试在无效数据上操作可能会使您的代码暴露于漏洞。这也是标准库在您尝试越界访问内存时会调用 `panic!` 的主要原因：尝试访问不属于当前数据结构的内存是一个常见的安全问题。函数通常有合同：只有在输入满足特定要求时，它们的行为才能得到保证。当合同被违反时发生恐慌是有道理的，因为合同违反总是表示调用方的错误，并且这不是您希望调用代码必须显式处理的一种错误。实际上，没有合理的方法让调用代码恢复；调用程序员需要修复代码。函数的合同，特别是违反将导致恐慌的合同，应该在函数的 API 文档中解释。

然而，在所有函数中都有大量的错误检查将会冗长且烦人。幸运的是，您可以使用 Rust 的类型系统（以及编译器执行的类型检查）来为您执行许多检查。如果您的函数具有特定类型作为参数，您可以继续使用代码逻辑，因为编译器已经确保您具有有效值。例如，如果您有一个类型而不是 `Option` ，则您的程序期望有某些东西而不是没有。然后，您的代码不必处理 `Some` 和 `None` 变体的两种情况：它只有一种情况，即肯定有一个值。试图将空值传递给您的函数的代码甚至不会编译，因此您的函数不必在运行时检查该情况。另一个例子是使用无符号整数类型，例如 `u32` ，它确保参数永远不会为负数。

### [为验证创建自定义类型](https://doc.rust-lang.org/book/ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation)

让我们进一步利用 Rust 的类型系统来确保我们拥有有效的值，并考虑创建一个用于验证的自定义类型。回想一下第 2 章中的猜数字游戏，我们的代码要求用户猜一个介于 1 和 100 之间的数字。在将用户的猜测与我们的秘密数字进行比较之前，我们从未验证过用户的猜测是否在这些数字之间；我们只验证过猜测是正数。在这种情况下，后果并不是非常严重：我们的输出“太高”或“太低”仍然是正确的。但是，引导用户进行有效猜测并在用户猜测超出范围的数字时具有不同的行为，将是一个有用的增强。

一种方法是将猜测解析为 `i32` 而不仅仅是 `u32` ，以允许潜在的负数，并添加一个检查以确保数字在范围内，如下所示：

![[Pasted image 20240512162222.png]]
`if` 表达式检查我们的值是否超出范围，告知用户问题，并调用 `continue` 启动循环的下一次迭代并请求另一个猜测。在 `if` 表达式之后，我们可以继续比较 `guess` 和秘密数字，知道 `guess` 在 1 和 100 之间。

然而，这并不是一个理想的解决方案：如果程序仅在 1 和 100 之间的值上运行是绝对关键的，并且有许多具有此要求的函数，那么在每个函数中都进行这样的检查将是乏味的（并可能影响性能）。

相反，我们可以创建一个新类型，并将验证放在一个函数中，以创建类型的实例，而不是在每个地方重复验证。这样，函数可以安全地在其签名中使用新类型，并自信地使用它们接收到的值。第 9-13 节显示了定义一个 `Guess` 类型的一种方式，只有当 `new` 函数接收到介于 1 和 100 之间的值时，才会创建 `Guess` 的实例。

![[Pasted image 20240512162328.png]]
首先，我们定义一个名为 `Guess` 的结构体，其中有一个名为 `value` 的字段，保存一个 `i32` 。这是数字将被存储的地方。

然后我们在 `Guess` 上实现一个名为 `new` 的关联函数，用于创建 `Guess` 值的实例。 `new` 函数被定义为具有一个名为 `value` 的 `i32` 类型参数，并返回一个 `Guess` 。 `new` 函数体中的代码测试 `value` 以确保它在 1 到 100 之间。如果 `value` 未通过此测试，我们进行 `panic!` 调用，这将提醒编写调用代码的程序员存在需要修复的错误，因为使用 `value` 超出此范围创建 `Guess` 将违反 `Guess::new` 依赖的合同。 `Guess::new` 可能发生恐慌的条件应在其面向公众的 API 文档中讨论；我们将在您在第 14 章中创建的 API 文档中涵盖指示可能发生 `panic!` 的文档约定。如果 `value` 通过了测试，我们将创建一个新的 `Guess` ，其 `value` 字段设置为 `value` 参数，并返回 `Guess` 。

接下来，我们实现一个名为 `value` 的方法，它借用 `self` ，没有其他参数，并返回一个 `i32` 。这种方法有时被称为 getter，因为它的目的是从其字段获取一些数据并返回。这个公共方法是必要的，因为 `Guess` 结构体的 `value` 字段是私有的。 `value` 字段保持私有是很重要的，这样使用 `Guess` 结构体的代码就不能直接设置 `value` ：模块外的代码必须使用 `Guess::new` 函数来创建 `Guess` 的实例，从而确保 `Guess` 不可能拥有一个未经 `Guess::new` 函数中条件检查的 `value` 。

一个具有参数或仅返回介于 1 和 100 之间的数字的函数可以在其签名中声明它接受或返回一个 `Guess` 而不是一个 `i32` ，并且在其主体中不需要进行任何额外的检查。

Rust 的错误处理功能旨在帮助您编写更健壮的代码。 `panic!` 宏表示您的程序处于无法处理的状态，并允许您告诉进程停止，而不是尝试继续使用无效或不正确的值。 `Result` 枚举使用 Rust 的类型系统指示操作可能以您的代码可以从中恢复的方式失败。您可以使用 `Result` 告诉调用您的代码的代码需要处理潜在的成功或失败。在适当的情况下使用 `panic!` 和 `Result` 将使您的代码在面对不可避免的问题时更可靠。

现在您已经看到标准库如何使用泛型与 `Option` 和 `Result` 枚举的有用方式，我们将讨论泛型的工作原理以及您如何在代码中使用它们。

### 使用 `Result` 类型

`Result` 类型是 Rust 中用于处理可恢复错误的主要方式。它是一个枚举，具有两个变体：`Ok(T)` 和 `Err(E)`，其中 `T` 是操作成功时返回的类型，而 `E` 是操作失败时的错误类型。

- **可恢复性**：`Result` 用于那些可能失败但不会导致程序终止的情况，例如文件读写、网络请求等。这些错误通常是预期之内的，因此可以通过错误处理逻辑来恢复。
- **显式处理**：使用 `Result` 强制开发者显式地处理错误。这意味着你必须使用 `match` 或 `if let` 等语句来检查操作是成功还是失败，并据此决定如何进一步操作。
- **控制流**：`Result` 类型允许错误信息被传递或转换，使得错误处理更加灵活和强大。

### 调用 `panic!` 宏

`panic!` 宏用于处理不可恢复的错误，通常是那些指示程序内部状态出现严重错误的情况，如数组越界、不可能的分支等。

- **不可恢复性**：当 `panic!` 被调用时，程序将会打印一个错误消息、清理其正在使用的资源，然后退出。这通常用于测试和处理那些理论上不应该发生的错误。
- **立即终止**：`panic!` 会导致当前线程的立即终止，如果它是主线程，则会导致程序的终止。这是一种适用于处理程序逻辑错误的方式，这些错误通常指示存在代码缺陷。
- **简单直接**：在一些开发场景中，当错误确实意味着严重的问题且无法（或不应该）恢复时，使用 `panic!` 可以简化错误处理的复杂性。

### 选择 `Result` 还是 `panic!`

选择使用 `Result` 或 `panic!` 主要取决于你的错误是否可以（或应该）被恢复。如果错误的发生不影响程序的整体稳定性，并且可以通过用户或程序的后续操作来修正，那么使用 `Result` 是更合适的。这样可以给用户或调用者提供错误处理的机会。如果错误是致命的，并且反映了不可恢复的状态或程序逻辑错误，使用 `panic!` 更为合适。

简而言之，`Result` 用于可以预期和处理的错误情况，而 `panic!` 用于那些不应该发生且无法恢复的错误。通过这种方式，Rust 增加了软件的可靠性，确保开发者在部署代码之前就处理了潜在的错误。



### #4、突破抽象范式
### #5、unsafe #rust
